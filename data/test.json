[{"sentId": 86, "articleId": "4", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 195, "text": "snooping in between and intercepting the message", "label": "ATTACK"}], "sentText": "pretty simple and straight forward. everything works fine. but i'm afraid that the websocket connection to node.js is unsecure. when node.js sends a message to the recipient, i don't want anyone snooping in between and intercepting the message. i would like to make sure my users feel safe and trust the service i have built for them. "}, {"sentId": 120, "articleId": "6", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 72, "text": "attacker can post behalf of a user using get request", "label": "ATTACK"}], "sentText": "xhr other origin is blocked because of security reason, as an instance, attacker can post behalf of a user using get request(consider the fact that it is not possible because of lack of cookies). however, the above script tag will do the same(same, cookies are not available). so why xhr get request is not allowed? "}, {"sentId": 65, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 76, "text": "sql injection", "label": "ATTACK"}], "sentText": "everyone knows or should know parameterized queries help to protect against sql injection. all of the tutorials and documentation i have seen have revolved around using prepared sql queries to process form input. but what about when there isn't any form input? i.e. a subsequent query after a user has been logged in such as [code] so in short, the question is trust. if you absolutely trust the source of the data (like for example because it's static, hard-coded, or for some other reason), that's fine to use it directly in queries. but in case of sql injection, using it properly (ie. in parameters) is so easy that you should just do that. "}, {"sentId": 26, "articleId": "3", "threatType": "I", "relationMentions": [{"em1Text": "hack around your javascript code", "em2Text": "know backdoors to your services and apis", "label": "None"}, {"em1Text": "know backdoors to your services and apis", "em2Text": "hack around your javascript code", "label": "PARENT"}], "entityMentions": [{"start": 183, "text": "hack around your javascript code", "label": "ATTACK"}, {"start": 221, "text": "know backdoors to your services and apis", "label": "ATTACK"}], "sentText": "and when i say to my fellow java developers, i start using a javascript mvc, they start saying it's not secure enough, as javascript is all about client-side there is always a way to hack around your javascript code, and know backdoors to your services and apis.   there is always a way to hack around your javascript code, and know backdoors to your services and apis. "}, {"sentId": 62, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 73, "text": "steal these credentials", "label": "ATTACK"}], "sentText": "however, i still think there are edge cases here where it is possible to steal these credentials, and believe they should be sent via an https post.  is this actually a safe means of sending login/token data? "}, {"sentId": 78, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "allowing the user to exercise any form of control over the running of such code", "em2Text": "injecting or altering the code itself", "label": "None"}, {"em1Text": "injecting or altering the code itself", "em2Text": "allowing the user to exercise any form of control over the running of such code", "label": "PARENT"}], "entityMentions": [{"start": 143, "text": "allowing the user to exercise any form of control over the running of such code", "label": "ATTACK"}, {"start": 244, "text": "injecting or altering the code itself", "label": "ATTACK"}], "sentText": "the security concerns that you mention aren't, per se, about \"allowing the user to invoke python code\" which runs with high access levels, but allowing the user to exercise any form of control over the running of such code -- most obviously by injecting or altering the code itself. "}, {"sentId": 12, "articleId": "4", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 89, "text": "man-in-middle attacks", "label": "ATTACK"}], "sentText": "encrypt my communication (c->s &amp; s->c)do 2-way authentication (c->s &amp; s->c)avoid man-in-middle attacks "}, {"sentId": 94, "articleId": "2", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 19, "text": "malicious applications which cover whole screen and pretend to be browsers, or even os's settings windows etc", "label": "ATTACK"}], "sentText": "how one can combat malicious applications which cover whole screen and pretend to be browsers, or even os's settings windows etc? "}, {"sentId": 71, "articleId": "6", "threatType": "D", "relationMentions": [{"em1Text": "someone with malicious intent can write a script", "em2Text": "register thousands of accounts in seconds", "label": "None"}, {"em1Text": "register thousands of accounts in seconds", "em2Text": "someone with malicious intent can write a script", "label": "PARENT"}], "entityMentions": [{"start": 75, "text": "someone with malicious intent can write a script", "label": "ATTACK"}, {"start": 127, "text": "register thousands of accounts in seconds", "label": "ATTACK"}], "sentText": "my app has a register service that users can register themselves. however, someone with malicious intent can write a script to register thousands of accounts in seconds. "}, {"sentId": 35, "articleId": "1", "threatType": "I", "relationMentions": [{"em1Text": "format string attack", "em2Text": "%x format specifier can be used to read values from the stack", "label": "PARENT"}, {"em1Text": "%x format specifier can be used to read values from the stack", "em2Text": "format string attack", "label": "None"}], "entityMentions": [{"start": 109, "text": "format string attack", "label": "ATTACK"}, {"start": 42, "text": "%x format specifier can be used to read values from the stack", "label": "ATTACK"}], "sentText": "i have a small question.  i know that the %x format specifier can be used to read values from the stack in a format string attack. "}, {"sentId": 33, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 197, "text": "xsrf", "label": "ATTACK"}], "sentText": "introduce an artificial server-side pause into each admin password check to prevent brute force attacks [developer art]use separate login pages for users and admin using the same db table (to stop xsrf and session-stealing granting access to admin areas) [thief master]consider also adding webserver native authentication to the admin area (e.g. via .htaccess)  [thief master]consider blocking users ip after a number of failed admin login attempts [thief master]add captcha after failed admin login attempts [thief master]provide equally strong mechanisms (using the above techniques) for users as well as admins (e.g. don't treat admins specially) [lo'oris]consider second level authentication (e.g. client certificates, smart cards, cardspace, etc.) [joegeeky]only allow access from trusted ips/domains, add check to basic http pipeline (via e.g. httpmodules) if possible. [joegeeky][asp.net] lock down iprincipal &amp; principal (make them immutable and non-enumerable) [joegeeky]federate rights elevation - e.g. email other admins when any admin's rights are upgraded.[joegeeky]consider fine-grained rights for admins - e.g. rather than roles based rights, define rights for indicidual actions per admin [joegeeky]restrict creation of admins - e.g. admins cannot change or create other admin accounts.  use a locked-down 'superadmin' client for this. [joegeeky]consider client side ssl certificates, or rsa type keyfobs (electronic tokens) [daniel papasian]if using cookies for authentication, use separate cookies for admin and normal pages, by e.g. putting the admin section on a different domain. [daniel papasian]if practical, consider keeping the admin site on a private subnet, off the public internet. [john hartsock]reissue auth/session tickets when moving between admin/normal usage contexts of the website [richard jp le guen] "}, {"sentId": 50, "articleId": "4", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 136, "text": "buffer overflow attack", "label": "ATTACK"}], "sentText": "oh, and yes i am not referring to other kinds of attacks which use return-to-libc, ptrace etc. ; i just wish to know why the most basic buffer overflow attack is demonstrated in the first way and not the second everywhere. "}, {"sentId": 21, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "someone attacked my application", "em2Text": "grab the api key", "label": "PARENT"}, {"em1Text": "someone attacked my application", "em2Text": "fraudulent clicks made using my api key", "label": "None"}, {"em1Text": "grab the api key", "em2Text": "someone attacked my application", "label": "None"}, {"em1Text": "grab the api key", "em2Text": "fraudulent clicks made using my api key", "label": "AND"}, {"em1Text": "fraudulent clicks made using my api key", "em2Text": "someone attacked my application", "label": "None"}, {"em1Text": "fraudulent clicks made using my api key", "em2Text": "grab the api key", "label": "None"}], "entityMentions": [{"start": 104, "text": "someone attacked my application", "label": "ATTACK"}, {"start": 140, "text": "grab the api key", "label": "ATTACK"}, {"start": 270, "text": "fraudulent clicks made using my api key", "label": "ATTACK"}], "sentText": "i am currently working on a project which uses blogger api from google. day before yesterday (saturday) someone attacked my application and grab the api key, my daily limit for accessing posts is 100,000 (100k/24 hrs). i hit limit on saturday (i suspect that those were fraudulent clicks made using my api key, since i've only around 4k customers using the application, i embedded the api key in client side code). "}, {"sentId": 159, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "injecting data into the mysql tables", "em2Text": "make a get request to the [code] script", "label": "PARENT"}, {"em1Text": "make a get request to the [code] script", "em2Text": "injecting data into the mysql tables", "label": "None"}], "entityMentions": [{"start": 265, "text": "injecting data into the mysql tables", "label": "ATTACK"}, {"start": 339, "text": "make a get request to the [code] script", "label": "ATTACK"}], "sentText": "i found a couple vbulletin sites i administer getting hacked recently. they use the latest version of the 3.8 series (3.8.7 patch level 2). i am usually pretty good at finding the holes where they get in and patching them up, but this one is stumping me.  they are injecting data into the mysql tables. the attack always happens when they make a get request to the [code] script. i was able to save data when the attack occurs.  this was the [code], [code], [code], [code], and [code] arrays.  the only thing i saw that looked out of place is that there were two new [code] keys, [code] and [code]: "}, {"sentId": 103, "articleId": "1", "threatType": "E", "relationMentions": [{"em1Text": "code is run as privileged user", "em2Text": "relying on set-user-id bit on a file", "label": "PARENT"}, {"em1Text": "relying on set-user-id bit on a file", "em2Text": "code is run as privileged user", "label": "None"}], "entityMentions": [{"start": 44, "text": "code is run as privileged user", "label": "ATTACK"}, {"start": 422, "text": "relying on set-user-id bit on a file", "label": "ATTACK"}], "sentText": "this constitues a vulnerability only if the code is run as privileged user. note that the setting of real user id, effective user id and saved set-user-id by a call to [code] before the call to [code] in the vulnerable code posted in the question allows one to exploit the vulnerability even when only effective user id is set to a privileged user id and real user id remains unprivileged (as is for example the case when relying on set-user-id bit on a file as above). without the call to [code] the shell run by [code] would reset the effective user id back to the real user id making the exploit ineffective. however, in the case when the vulnerable code is run with real user id of a privileged user, [code] call alone is enough. quoting [code] man page: "}, {"sentId": 24, "articleId": "2", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 36, "text": "sql injection", "label": "ATTACK"}], "sentText": "i need to avoid being vulnerable to sql injection in my asp.net application. how might i accomplish this? "}, {"sentId": 4, "articleId": "2", "threatType": "E", "relationMentions": [{"em1Text": "access to some information available in the source code", "em2Text": "spam my web server with requests", "label": "None"}, {"em1Text": "spam my web server with requests", "em2Text": "access to some information available in the source code", "label": "PARENT"}], "entityMentions": [{"start": 260, "text": "access to some information available in the source code", "label": "ATTACK"}, {"start": 340, "text": "spam my web server with requests", "label": "ATTACK"}], "sentText": "i'm creating an app for android and ios, and i already know that it's theoretically possible to decompile an android app. the app contains sensitive information that i don't want users to have access to as the app interfaces with a webserver. if a user gained access to some information available in the source code, they could potentially spam my web server with requests. "}, {"sentId": 81, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "[code]", "em2Text": "sql injection", "label": "None"}, {"em1Text": "sql injection", "em2Text": "[code]", "label": "PARENT"}], "entityMentions": [{"start": 0, "text": "[code]", "label": "ATTACK"}, {"start": 54, "text": "sql injection", "label": "ATTACK"}], "sentText": "[code] will this automatically make my code immune to sql injection? do i have to do something extra? [code] because there is simply no way to pass the tablename itself as a parameter and the desire to do exists sometimes - misguided or not. it seems it is then often overlooked, that tablename (unless maybe only read from a set of static/constant values that do not derive from any input) indeed allows for sql injection. "}, {"sentId": 15, "articleId": "3", "threatType": "E", "relationMentions": [{"em1Text": "'hack' an apache server", "em2Text": "read php files", "label": "AND"}, {"em1Text": "'hack' an apache server", "em2Text": "access to files on the hard disk", "label": "None"}, {"em1Text": "read php files", "em2Text": "'hack' an apache server", "label": "None"}, {"em1Text": "read php files", "em2Text": "access to files on the hard disk", "label": "None"}, {"em1Text": "access to files on the hard disk", "em2Text": "'hack' an apache server", "label": "PARENT"}, {"em1Text": "access to files on the hard disk", "em2Text": "read php files", "label": "None"}], "entityMentions": [{"start": 30, "text": "'hack' an apache server", "label": "ATTACK"}, {"start": 58, "text": "read php files", "label": "ATTACK"}, {"start": 337, "text": "access to files on the hard disk", "label": "ATTACK"}], "sentText": "is it possible for someone to 'hack' an apache server and read php files. i understand that php is a server-side language and cannot be read from anywhere other than the server, but could someone hack the server and read them as if reading a text file? well yes, if they ever actually hack into the server (ssh, ftp etc.), they may have access to files on the hard disk. a properly configured apache server will not serve raw php files though, it should always process them with the php interpreter first. "}, {"sentId": 3, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "attacker modifies his remote host or user agent or something", "em2Text": "inserting attacking code into his remote host or user agent or ect", "label": "PARENT"}, {"em1Text": "inserting attacking code into his remote host or user agent or ect", "em2Text": "attacker modifies his remote host or user agent or something", "label": "None"}], "entityMentions": [{"start": 99, "text": "attacker modifies his remote host or user agent or something", "label": "ATTACK"}, {"start": 185, "text": "inserting attacking code into his remote host or user agent or ect", "label": "ATTACK"}], "sentText": "i am considering to record access log,   and i am considering to view it via wev browser,   but if attacker modifies his remote host or user agent or something, can he attack to me? by inserting attacking code into his remote host or user agent or ect. "}, {"sentId": 133, "articleId": "4", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 34, "text": "bcrypt is hacked", "label": "ATTACK"}], "sentText": "now what i want to say suppose if bcrypt is hacked and is found to be broken and in future there comes new cryptographic function that is more secure and. than this way creating a password from old values will always be time consuming. "}, {"sentId": 25, "articleId": "3", "threatType": "S", "relationMentions": [{"em1Text": "impersonate as the server", "em2Text": "losing my password", "label": "None"}, {"em1Text": "impersonate as the server", "em2Text": "forwards the data to the correct server", "label": "None"}, {"em1Text": "impersonate as the server", "em2Text": "use your private key to execute commands on the machine you were trying to access", "label": "None"}, {"em1Text": "losing my password", "em2Text": "impersonate as the server", "label": "PARENT"}, {"em1Text": "losing my password", "em2Text": "forwards the data to the correct server", "label": "None"}, {"em1Text": "losing my password", "em2Text": "use your private key to execute commands on the machine you were trying to access", "label": "None"}, {"em1Text": "forwards the data to the correct server", "em2Text": "impersonate as the server", "label": "None"}, {"em1Text": "forwards the data to the correct server", "em2Text": "losing my password", "label": "None"}, {"em1Text": "forwards the data to the correct server", "em2Text": "use your private key to execute commands on the machine you were trying to access", "label": "None"}, {"em1Text": "use your private key to execute commands on the machine you were trying to access", "em2Text": "impersonate as the server", "label": "None"}, {"em1Text": "use your private key to execute commands on the machine you were trying to access", "em2Text": "losing my password", "label": "None"}, {"em1Text": "use your private key to execute commands on the machine you were trying to access", "em2Text": "forwards the data to the correct server", "label": "PARENT"}], "entityMentions": [{"start": 230, "text": "impersonate as the server", "label": "ATTACK"}, {"start": 267, "text": "losing my password", "label": "ATTACK"}, {"start": 727, "text": "forwards the data to the correct server", "label": "ATTACK"}, {"start": 796, "text": "use your private key to execute commands on the machine you were trying to access", "label": "ATTACK"}], "sentText": "i am no expert in network security, so pardon if this question is not very smart :).i am automating logins to some machines using ssh. i am currently avoiding host-key warnings using [code].  i naively understand that someone can impersonate as the server and i risk losing my password to him if that were the case. however, if i am using only public/private key based authentication ( using [code] ), can the intruder still cause harm? no. or atleast... not directly. since you never send your private key, the key will be safe. that doesn't mean that the person that is executing the mitm attack can't execute commands and/or read the output you're getting.yes, there are other risks. if the person executing the mitm attack forwards the data to the correct server than it might be possible to use your private key to execute commands on the machine you were trying to access. "}, {"sentId": 116, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "format string vulnerabilities", "em2Text": "exploit this by passing in a format string", "label": "PARENT"}, {"em1Text": "format string vulnerabilities", "em2Text": "make %n overwrite with a specific value", "label": "None"}, {"em1Text": "format string vulnerabilities", "em2Text": "padding the number of bytes written before the %n", "label": "None"}, {"em1Text": "exploit this by passing in a format string", "em2Text": "format string vulnerabilities", "label": "None"}, {"em1Text": "exploit this by passing in a format string", "em2Text": "make %n overwrite with a specific value", "label": "PARENT"}, {"em1Text": "exploit this by passing in a format string", "em2Text": "padding the number of bytes written before the %n", "label": "None"}, {"em1Text": "make %n overwrite with a specific value", "em2Text": "format string vulnerabilities", "label": "None"}, {"em1Text": "make %n overwrite with a specific value", "em2Text": "exploit this by passing in a format string", "label": "None"}, {"em1Text": "make %n overwrite with a specific value", "em2Text": "padding the number of bytes written before the %n", "label": "PARENT"}, {"em1Text": "padding the number of bytes written before the %n", "em2Text": "format string vulnerabilities", "label": "None"}, {"em1Text": "padding the number of bytes written before the %n", "em2Text": "exploit this by passing in a format string", "label": "None"}, {"em1Text": "padding the number of bytes written before the %n", "em2Text": "make %n overwrite with a specific value", "label": "None"}], "entityMentions": [{"start": 39, "text": "format string vulnerabilities", "label": "ATTACK"}, {"start": 292, "text": "exploit this by passing in a format string", "label": "ATTACK"}, {"start": 596, "text": "make %n overwrite with a specific value", "label": "ATTACK"}, {"start": 647, "text": "padding the number of bytes written before the %n", "label": "ATTACK"}], "sentText": "i am reading about and trying to learn format string vulnerabilities. i have a vulnerable function and i understand the gist of what i have to do with my format string. okay, i'll try to be a little more clear. i have a vulnerable program. the vulnerable point is \"printf(input);\". i want to exploit this by passing in a format string. now for example, i have a format string  this format string, when passed into the vulnerable function, will overwrite the memory address of 0xffbfde0c with the number of bytes written. i am looking to find out how i can modify that format string so that i can make %n overwrite with a specific value by somehow padding the number of bytes written before the %n. "}, {"sentId": 64, "articleId": "1", "threatType": "D", "relationMentions": [], "entityMentions": [{"start": 67, "text": "ddos", "label": "ATTACK"}], "sentText": "however, since the function is available globally, it can still be ddos-ed by a bad guy. if the attack is not as strong as google's defence, my function/service may still be responsive. this is good. however, i don't want to pay for those function calls made by the party i didn't authorize to access the function. (since the billing is per number of function invocations). that's why it's important for me to know whether google cloud functions detect ddos attacks and enable counter-measures before i'm being responsible for charges. i have sent an email to google-cloud support, regarding cloud functions and whether they were protected against ddos attacks. i have received this answer from the engineering team (as of 4th of april 2018): "}, {"sentId": 82, "articleId": "2", "threatType": "S", "relationMentions": [{"em1Text": "access that endpoint", "em2Text": "use the token it provides", "label": "None"}, {"em1Text": "use the token it provides", "em2Text": "access that endpoint", "label": "PARENT"}], "entityMentions": [{"start": 302, "text": "access that endpoint", "label": "ATTACK"}, {"start": 327, "text": "use the token it provides", "label": "ATTACK"}], "sentText": "since i do not have control over how the static website is served, i cannot generate a csrf token when someone loads my static website (and insert the token into forms or send it with my ajax requests). i could create a [code] endpoint to retrieve the token, but it seems like an attacker could simply access that endpoint and use the token it provides?   i could create a get endpoint to retrieve the token, but it seems like an attacker could simply access that endpoint and use the token it provides? "}, {"sentId": 108, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 84, "text": "the attacker to pass arbitrary number of arguments", "label": "ATTACK"}], "sentText": "  escapeshellcmd() should be used on the whole command string, and it  still allows the attacker to pass arbitrary number of arguments. for  escaping a single argument escapeshellarg() should be used instead. "}, {"sentId": 46, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 47, "text": "sql injection", "label": "ATTACK"}], "sentText": "the code is working, but now i'm worried about sql injections. how to prevent sql injection? "}, {"sentId": 82, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 326, "text": "enter unwanted strings in the url", "label": "ATTACK"}], "sentText": "i need to prevent the characters that cause vulnerabilities in the url.my sample url is http://localhost/add.aspx?id=4;req=4.please give the list of characters that i need block.i am using an [link] web page. i am binding the information from an [link] database.i just want to list the characters to stay away from hackers to enter unwanted strings in the url. "}, {"sentId": 2, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "mass assignment", "em2Text": "allow mass-assignment on the category_id", "label": "None"}, {"em1Text": "mass assignment", "em2Text": "user could nil it out", "label": "None"}, {"em1Text": "mass assignment", "em2Text": "change it to one of their categories", "label": "None"}, {"em1Text": "mass assignment", "em2Text": "change it to someone else's category", "label": "None"}, {"em1Text": "allow mass-assignment on the category_id", "em2Text": "mass assignment", "label": "None"}, {"em1Text": "allow mass-assignment on the category_id", "em2Text": "user could nil it out", "label": "None"}, {"em1Text": "allow mass-assignment on the category_id", "em2Text": "change it to one of their categories", "label": "None"}, {"em1Text": "allow mass-assignment on the category_id", "em2Text": "change it to someone else's category", "label": "None"}, {"em1Text": "user could nil it out", "em2Text": "mass assignment", "label": "None"}, {"em1Text": "user could nil it out", "em2Text": "allow mass-assignment on the category_id", "label": "None"}, {"em1Text": "user could nil it out", "em2Text": "change it to one of their categories", "label": "OR"}, {"em1Text": "user could nil it out", "em2Text": "change it to someone else's category", "label": "None"}, {"em1Text": "change it to one of their categories", "em2Text": "mass assignment", "label": "OR"}, {"em1Text": "change it to one of their categories", "em2Text": "allow mass-assignment on the category_id", "label": "None"}, {"em1Text": "change it to one of their categories", "em2Text": "user could nil it out", "label": "None"}, {"em1Text": "change it to one of their categories", "em2Text": "change it to someone else's category", "label": "None"}, {"em1Text": "change it to someone else's category", "em2Text": "mass assignment", "label": "None"}, {"em1Text": "change it to someone else's category", "em2Text": "allow mass-assignment on the category_id", "label": "None"}, {"em1Text": "change it to someone else's category", "em2Text": "user could nil it out", "label": "PARENT"}, {"em1Text": "change it to someone else's category", "em2Text": "change it to one of their categories", "label": "None"}], "entityMentions": [{"start": 96, "text": "mass assignment", "label": "ATTACK"}, {"start": 421, "text": "allow mass-assignment on the category_id", "label": "ATTACK"}, {"start": 470, "text": "user could nil it out", "label": "ATTACK"}, {"start": 493, "text": "change it to one of their categories", "label": "ATTACK"}, {"start": 580, "text": "change it to someone else's category", "label": "ATTACK"}], "sentText": "i've been reading up on rails security concerns and the one that makes me the most concerned is mass assignment.  my application is making use of attr_accessible, however i'm not sure if i quite know what the best way to handle the exposed relationships is.  let's assume that we have a basic content creation/ownership website.  a user can have create blog posts, and have one category associated with that blog post. i allow mass-assignment on the category_id, so the user could nil it out, change it to one of their categories, or through mass-assignment, i suppose they could change it to someone else's category.  that is where i'm kind of unsure about what the best way to proceed would be. "}, {"sentId": 22, "articleId": "2", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 42, "text": "someone posting malicious data to/as another user", "label": "ATTACK"}], "sentText": "if you are concerned with the first case (someone posting malicious data to/as another user) the solution is the same whether you are using ajax or not -- you just have to authenticate the user through whatever means is necessary -- usually via session cookie. "}, {"sentId": 20, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "some bad employee could use it for nefarious purposes", "em2Text": "share it with someone else who would", "label": "OR"}, {"em1Text": "share it with someone else who would", "em2Text": "some bad employee could use it for nefarious purposes", "label": "None"}], "entityMentions": [{"start": 236, "text": "some bad employee could use it for nefarious purposes", "label": "ATTACK"}, {"start": 293, "text": "share it with someone else who would", "label": "ATTACK"}], "sentText": "a company is developing software that it hosts for the public that relies on oauth2 to some 3rd party for authentication. but unavoidably the oauth secret for this application will be exposed to all employes of the company. presumably, some bad employee could use it for nefarious purposes or share it with someone else who would. "}, {"sentId": 44, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "read your sources", "em2Text": "executing arbitrary code on your vm", "label": "None"}, {"em1Text": "executing arbitrary code on your vm", "em2Text": "read your sources", "label": "PARENT"}], "entityMentions": [{"start": 67, "text": "read your sources", "label": "ATTACK"}, {"start": 89, "text": "executing arbitrary code on your vm", "label": "ATTACK"}], "sentText": "edit: and for those who think anyone on the internet being able to read your sources and executing arbitrary code on your vm is not that bad, i recommend reading the \"breaking out\" section in this blog post [link] "}, {"sentId": 51, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "session hijacking", "em2Text": "replay", "label": "AND"}, {"em1Text": "session hijacking", "em2Text": "man-in-the-middle attacks", "label": "None"}, {"em1Text": "replay", "em2Text": "session hijacking", "label": "None"}, {"em1Text": "replay", "em2Text": "man-in-the-middle attacks", "label": "OR"}, {"em1Text": "man-in-the-middle attacks", "em2Text": "session hijacking", "label": "None"}, {"em1Text": "man-in-the-middle attacks", "em2Text": "replay", "label": "None"}], "entityMentions": [{"start": 52, "text": "session hijacking", "label": "ATTACK"}, {"start": 89, "text": "replay", "label": "ATTACK"}, {"start": 99, "text": "man-in-the-middle attacks", "label": "ATTACK"}], "sentText": "the reason is to harden the web application against session hijacking (eg by [link]) and replay or man-in-the-middle attacks.  "}, {"sentId": 50, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "reset palin's password", "em2Text": "her  birthdate", "label": "PARENT"}, {"em1Text": "reset palin's password", "em2Text": "zip code", "label": "None"}, {"em1Text": "reset palin's password", "em2Text": "where she met her spouse -- the  security question on her yahoo  account", "label": "None"}, {"em1Text": "her  birthdate", "em2Text": "reset palin's password", "label": "None"}, {"em1Text": "her  birthdate", "em2Text": "zip code", "label": "AND"}, {"em1Text": "her  birthdate", "em2Text": "where she met her spouse -- the  security question on her yahoo  account", "label": "None"}, {"em1Text": "zip code", "em2Text": "reset palin's password", "label": "None"}, {"em1Text": "zip code", "em2Text": "her  birthdate", "label": "None"}, {"em1Text": "zip code", "em2Text": "where she met her spouse -- the  security question on her yahoo  account", "label": "AND"}, {"em1Text": "where she met her spouse -- the  security question on her yahoo  account", "em2Text": "reset palin's password", "label": "None"}, {"em1Text": "where she met her spouse -- the  security question on her yahoo  account", "em2Text": "her  birthdate", "label": "None"}, {"em1Text": "where she met her spouse -- the  security question on her yahoo  account", "em2Text": "zip code", "label": "None"}], "entityMentions": [{"start": 105, "text": "reset palin's password", "label": "ATTACK"}, {"start": 134, "text": "her  birthdate", "label": "ATTACK"}, {"start": 150, "text": "zip code", "label": "ATTACK"}, {"start": 182, "text": "where she met her spouse -- the  security question on her yahoo  account", "label": "ATTACK"}], "sentText": "  from [link] magazine:    ...the palin hack didn't require any  real skill. instead, the hacker simply  reset palin's password using her  birthdate, zip code and information  about where she met her spouse -- the  security question on her yahoo  account, which was answered (wasilla  high) by a simple google search. "}, {"sentId": 56, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "apply an [link] the iframe", "em2Text": "the widget has loaded", "label": "PARENT"}, {"em1Text": "apply an [link] the iframe", "em2Text": "resize the iframe to be the size of the page", "label": "None"}, {"em1Text": "apply an [link] the iframe", "em2Text": "have this now invisible iframe follow the cursor", "label": "None"}, {"em1Text": "apply an [link] the iframe", "em2Text": "the iframe receives the click event", "label": "None"}, {"em1Text": "the widget has loaded", "em2Text": "apply an [link] the iframe", "label": "None"}, {"em1Text": "the widget has loaded", "em2Text": "resize the iframe to be the size of the page", "label": "None"}, {"em1Text": "the widget has loaded", "em2Text": "have this now invisible iframe follow the cursor", "label": "None"}, {"em1Text": "the widget has loaded", "em2Text": "the iframe receives the click event", "label": "None"}, {"em1Text": "resize the iframe to be the size of the page", "em2Text": "apply an [link] the iframe", "label": "PARENT"}, {"em1Text": "resize the iframe to be the size of the page", "em2Text": "the widget has loaded", "label": "None"}, {"em1Text": "resize the iframe to be the size of the page", "em2Text": "have this now invisible iframe follow the cursor", "label": "OR"}, {"em1Text": "resize the iframe to be the size of the page", "em2Text": "the iframe receives the click event", "label": "None"}, {"em1Text": "have this now invisible iframe follow the cursor", "em2Text": "apply an [link] the iframe", "label": "None"}, {"em1Text": "have this now invisible iframe follow the cursor", "em2Text": "the widget has loaded", "label": "None"}, {"em1Text": "have this now invisible iframe follow the cursor", "em2Text": "resize the iframe to be the size of the page", "label": "None"}, {"em1Text": "have this now invisible iframe follow the cursor", "em2Text": "the iframe receives the click event", "label": "None"}, {"em1Text": "the iframe receives the click event", "em2Text": "apply an [link] the iframe", "label": "None"}, {"em1Text": "the iframe receives the click event", "em2Text": "the widget has loaded", "label": "None"}, {"em1Text": "the iframe receives the click event", "em2Text": "resize the iframe to be the size of the page", "label": "None"}, {"em1Text": "the iframe receives the click event", "em2Text": "have this now invisible iframe follow the cursor", "label": "PARENT"}], "entityMentions": [{"start": 25, "text": "apply an [link] the iframe", "label": "ATTACK"}, {"start": 58, "text": "the widget has loaded", "label": "ATTACK"}, {"start": 164, "text": "resize the iframe to be the size of the page", "label": "ATTACK"}, {"start": 212, "text": "have this now invisible iframe follow the cursor", "label": "ATTACK"}, {"start": 322, "text": "the iframe receives the click event", "label": "ATTACK"}], "sentText": "the attacker is going to apply an [link] the iframe after the widget has loaded.  this mask will make the iframe invisible.   at this point the attacker can either resize the iframe to be the size of the page or have this now invisible iframe follow the cursor.  either way whenever the user clicks anywhere on the page,  the iframe receives the click event and its game over.  "}, {"sentId": 6, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "a malicious user can invoke one method", "em2Text": "he could invoke any", "label": "None"}, {"em1Text": "he could invoke any", "em2Text": "a malicious user can invoke one method", "label": "PARENT"}], "entityMentions": [{"start": 113, "text": "a malicious user can invoke one method", "label": "ATTACK"}, {"start": 153, "text": "he could invoke any", "label": "ATTACK"}], "sentText": "should role checks be done at the top of the stack, the bottom of the stack or at every level?  it seems that if a malicious user can invoke one method, he could invoke any, so for  effective security, you'd need a check on every method (and that's a lot of extra code to write). "}, {"sentId": 110, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "craft malicious input", "em2Text": "do something egregious when the object is unpickled", "label": "None"}, {"em1Text": "craft malicious input", "em2Text": "sql injection attempts", "label": "PARENT"}, {"em1Text": "craft malicious input", "em2Text": "changing credentials", "label": "None"}, {"em1Text": "craft malicious input", "em2Text": "brute force password cracking", "label": "None"}, {"em1Text": "do something egregious when the object is unpickled", "em2Text": "craft malicious input", "label": "PARENT"}, {"em1Text": "do something egregious when the object is unpickled", "em2Text": "sql injection attempts", "label": "None"}, {"em1Text": "do something egregious when the object is unpickled", "em2Text": "changing credentials", "label": "None"}, {"em1Text": "do something egregious when the object is unpickled", "em2Text": "brute force password cracking", "label": "None"}, {"em1Text": "sql injection attempts", "em2Text": "craft malicious input", "label": "None"}, {"em1Text": "sql injection attempts", "em2Text": "do something egregious when the object is unpickled", "label": "None"}, {"em1Text": "sql injection attempts", "em2Text": "changing credentials", "label": "OR"}, {"em1Text": "sql injection attempts", "em2Text": "brute force password cracking", "label": "None"}, {"em1Text": "changing credentials", "em2Text": "craft malicious input", "label": "None"}, {"em1Text": "changing credentials", "em2Text": "do something egregious when the object is unpickled", "label": "None"}, {"em1Text": "changing credentials", "em2Text": "sql injection attempts", "label": "None"}, {"em1Text": "changing credentials", "em2Text": "brute force password cracking", "label": "OR"}, {"em1Text": "brute force password cracking", "em2Text": "craft malicious input", "label": "None"}, {"em1Text": "brute force password cracking", "em2Text": "do something egregious when the object is unpickled", "label": "None"}, {"em1Text": "brute force password cracking", "em2Text": "sql injection attempts", "label": "None"}, {"em1Text": "brute force password cracking", "em2Text": "changing credentials", "label": "None"}], "entityMentions": [{"start": 29, "text": "craft malicious input", "label": "ATTACK"}, {"start": 62, "text": "do something egregious when the object is unpickled", "label": "ATTACK"}, {"start": 236, "text": "sql injection attempts", "label": "ATTACK"}, {"start": 263, "text": "changing credentials", "label": "ATTACK"}, {"start": 285, "text": "brute force password cracking", "label": "ATTACK"}], "sentText": "is it possible for a user to craft malicious input that could do something egregious when the object is unpickled? yes - depending on what you plan to do with the information in the object later, a user can do all sorts of things. from sql injection attempts, to changing credentials, brute force password cracking, or anything that should be considered when you're validating user input. but you are probably checking for all this. "}, {"sentId": 80, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "create malicious xaml pages", "em2Text": "embed html or call remote webpages with malicious content", "label": "PARENT"}, {"em1Text": "embed html or call remote webpages with malicious content", "em2Text": "create malicious xaml pages", "label": "None"}], "entityMentions": [{"start": 77, "text": "create malicious xaml pages", "label": "ATTACK"}, {"start": 203, "text": "embed html or call remote webpages with malicious content", "label": "ATTACK"}], "sentText": "now the question arises, due to my lack of xaml knowledge, is it possible to create malicious xaml pages that when downloaded and used could have other embedded iframes or other elements that could have embed html or call remote webpages with malicious content? i believe this could be the case. "}, {"sentId": 16, "articleId": "4", "threatType": "D", "relationMentions": [{"em1Text": "add my bot to a thousand big groups", "em2Text": "result in denial of service for all other users", "label": "None"}, {"em1Text": "result in denial of service for all other users", "em2Text": "add my bot to a thousand big groups", "label": "PARENT"}], "entityMentions": [{"start": 90, "text": "add my bot to a thousand big groups", "label": "ATTACK"}, {"start": 144, "text": "result in denial of service for all other users", "label": "ATTACK"}], "sentText": "i can filter out the messages i get in my webhook callback. however, a malicious user can add my bot to a thousand big groups and will possibly result in denial of service for all other users. even if telegram have implemented some rate limiting such user actions may still result in denial of service for all other users. "}, {"sentId": 77, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "hacker see this happening and get those keys", "em2Text": "hackers will be able to build a hacked version", "label": "PARENT"}, {"em1Text": "hacker see this happening and get those keys", "em2Text": "all the levels pre-downloaded inside", "label": "None"}, {"em1Text": "hackers will be able to build a hacked version", "em2Text": "hacker see this happening and get those keys", "label": "None"}, {"em1Text": "hackers will be able to build a hacked version", "em2Text": "all the levels pre-downloaded inside", "label": "PARENT"}, {"em1Text": "all the levels pre-downloaded inside", "em2Text": "hacker see this happening and get those keys", "label": "None"}, {"em1Text": "all the levels pre-downloaded inside", "em2Text": "hackers will be able to build a hacked version", "label": "None"}], "entityMentions": [{"start": 24, "text": "hacker see this happening and get those keys", "label": "ATTACK"}, {"start": 212, "text": "hackers will be able to build a hacked version", "label": "ATTACK"}, {"start": 264, "text": "all the levels pre-downloaded inside", "label": "ATTACK"}], "sentText": "is that safe or can the hacker see this happening and get those keys? do i need to protect those keys at all? i am afraid that people will be able to get the files from s3 with out purchasing the levels. or that hackers will be able to build a hacked version with all the levels pre-downloaded inside. "}, {"sentId": 47, "articleId": "4", "threatType": "E", "relationMentions": [{"em1Text": "create a licensing system built on the .net framework cryptography classes", "em2Text": "it could be bypassed system-wide for every .net application on the system using the framework", "label": "AND"}, {"em1Text": "create a licensing system built on the .net framework cryptography classes", "em2Text": "log and change the input of functios that i call just by hooking into the methods.", "label": "None"}, {"em1Text": "create a licensing system built on the .net framework cryptography classes", "em2Text": "has admin access to your computer", "label": "None"}, {"em1Text": "it could be bypassed system-wide for every .net application on the system using the framework", "em2Text": "create a licensing system built on the .net framework cryptography classes", "label": "None"}, {"em1Text": "it could be bypassed system-wide for every .net application on the system using the framework", "em2Text": "log and change the input of functios that i call just by hooking into the methods.", "label": "None"}, {"em1Text": "it could be bypassed system-wide for every .net application on the system using the framework", "em2Text": "has admin access to your computer", "label": "AND"}, {"em1Text": "log and change the input of functios that i call just by hooking into the methods.", "em2Text": "create a licensing system built on the .net framework cryptography classes", "label": "None"}, {"em1Text": "log and change the input of functios that i call just by hooking into the methods.", "em2Text": "it could be bypassed system-wide for every .net application on the system using the framework", "label": "None"}, {"em1Text": "log and change the input of functios that i call just by hooking into the methods.", "em2Text": "has admin access to your computer", "label": "PARENT"}, {"em1Text": "has admin access to your computer", "em2Text": "create a licensing system built on the .net framework cryptography classes", "label": "None"}, {"em1Text": "has admin access to your computer", "em2Text": "it could be bypassed system-wide for every .net application on the system using the framework", "label": "None"}, {"em1Text": "has admin access to your computer", "em2Text": "log and change the input of functios that i call just by hooking into the methods.", "label": "None"}], "entityMentions": [{"start": 20, "text": "create a licensing system built on the .net framework cryptography classes", "label": "ATTACK"}, {"start": 96, "text": "it could be bypassed system-wide for every .net application on the system using the framework", "label": "ATTACK"}, {"start": 211, "text": "log and change the input of functios that i call just by hooking into the methods.", "label": "ATTACK"}, {"start": 309, "text": "has admin access to your computer", "label": "ATTACK"}], "sentText": "for example, if i'd create a licensing system built on the .net framework cryptography classes, it could be bypassed system-wide for every .net application on the system using the framework. also, everybody can log and change the input of functios that i call just by hooking into the methods. if an attacker has admin access to your computer (which is required for the attack you described), then you've pretty much lost. anything you could do could be circumvented by the attacker. "}, {"sentId": 89, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "anyone who access the web", "em2Text": "modify javascript code", "label": "None"}, {"em1Text": "anyone who access the web", "em2Text": "user can add the code lines as following", "label": "None"}, {"em1Text": "modify javascript code", "em2Text": "anyone who access the web", "label": "PARENT"}, {"em1Text": "modify javascript code", "em2Text": "user can add the code lines as following", "label": "None"}, {"em1Text": "user can add the code lines as following", "em2Text": "anyone who access the web", "label": "None"}, {"em1Text": "user can add the code lines as following", "em2Text": "modify javascript code", "label": "None"}], "entityMentions": [{"start": 75, "text": "anyone who access the web", "label": "ATTACK"}, {"start": 112, "text": "modify javascript code", "label": "ATTACK"}, {"start": 214, "text": "user can add the code lines as following", "label": "ATTACK"}], "sentText": "the function call socket.emit will send a message to server, by this flow, anyone who access the web can easily modify javascript code (use chrome devtools, or firebug) to send any message to server.  for example, user can add the code lines as following: "}, {"sentId": 39, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "uploaded svg images on a website", "em2Text": "cross-site-script into there", "label": "None"}, {"em1Text": "cross-site-script into there", "em2Text": "uploaded svg images on a website", "label": "PARENT"}], "entityMentions": [{"start": 23, "text": "uploaded svg images on a website", "label": "ATTACK"}, {"start": 178, "text": "cross-site-script into there", "label": "ATTACK"}], "sentText": "i want to display user uploaded svg images on a website, but they're quite open to exploits: they serve the uploaded files from a separate hostname, specifically [code]. you can cross-site-script into there all you like but it doesn't get you anything: it lives in a different origin to [code] and can't touch its cookies or interact with its script. "}, {"sentId": 34, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "a strange error popped up in our app's logs:[code]", "em2Text": "when i go to the url that failed to load, these are the only contents:[code]", "label": "PARENT"}, {"em1Text": "a strange error popped up in our app's logs:[code]", "em2Text": "the user's user agent string is:[code]", "label": "None"}, {"em1Text": "when i go to the url that failed to load, these are the only contents:[code]", "em2Text": "a strange error popped up in our app's logs:[code]", "label": "None"}, {"em1Text": "when i go to the url that failed to load, these are the only contents:[code]", "em2Text": "the user's user agent string is:[code]", "label": "AND"}, {"em1Text": "the user's user agent string is:[code]", "em2Text": "a strange error popped up in our app's logs:[code]", "label": "None"}, {"em1Text": "the user's user agent string is:[code]", "em2Text": "when i go to the url that failed to load, these are the only contents:[code]", "label": "None"}], "entityMentions": [{"start": 71, "text": "a strange error popped up in our app's logs:[code]", "label": "ATTACK"}, {"start": 175, "text": "when i go to the url that failed to load, these are the only contents:[code]", "label": "ATTACK"}, {"start": 252, "text": "the user's user agent string is:[code]", "label": "ATTACK"}], "sentText": "i manage a secured php/mysql web app with extensive jquery use. today, a strange error popped up in our app's logs:[code] we are not using amazon's cloudfront cdn in our app. when i go to the url that failed to load, these are the only contents:[code] the user's user agent string is:[code] "}, {"sentId": 94, "articleId": "6", "threatType": "E", "relationMentions": [{"em1Text": "running a brakeman scan", "em2Text": "[code] opens up the application to mass assignment vulnerabilities", "label": "None"}, {"em1Text": "running a brakeman scan", "em2Text": "params.permit! vulnerability", "label": "None"}, {"em1Text": "[code] opens up the application to mass assignment vulnerabilities", "em2Text": "running a brakeman scan", "label": "PARENT"}, {"em1Text": "[code] opens up the application to mass assignment vulnerabilities", "em2Text": "params.permit! vulnerability", "label": "None"}, {"em1Text": "params.permit! vulnerability", "em2Text": "running a brakeman scan", "label": "None"}, {"em1Text": "params.permit! vulnerability", "em2Text": "[code] opens up the application to mass assignment vulnerabilities", "label": "PARENT"}], "entityMentions": [{"start": 98, "text": "running a brakeman scan", "label": "ATTACK"}, {"start": 129, "text": "[code] opens up the application to mass assignment vulnerabilities", "label": "ATTACK"}, {"start": 263, "text": "params.permit! vulnerability", "label": "ATTACK"}], "sentText": "i'm working on a legacy rails application and the controllers have many instances of [code]. when running a brakeman scan on it, [code] opens up the application to mass assignment vulnerabilities. my question is- what is the most effective way to get around this params.permit! vulnerability and replace it? "}, {"sentId": 74, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "knows the problem domain (an ssn)", "em2Text": "focus on that domain", "label": "None"}, {"em1Text": "focus on that domain", "em2Text": "knows the problem domain (an ssn)", "label": "PARENT"}], "entityMentions": [{"start": 139, "text": "knows the problem domain (an ssn)", "label": "ATTACK"}, {"start": 188, "text": "focus on that domain", "label": "ATTACK"}], "sentText": "so naturally, i thought of just sha hashing it since we're just using it for identification.  the problem with that is that if an attacker knows the problem domain (an ssn), then they can focus on that domain.  so it's much easier to calculate the billion ssns rather than a virtually unlimited number of passwords.  i know i should use a site salt and a per-patient salt, but is there anything else i can do to prevent an attacker from revealing the ssn?  instead of sha, i was planning on using bcrypt, since ruby has a good library and it handles scalable complexity and salting automagically. "}, {"sentId": 6, "articleId": "3", "threatType": "T", "relationMentions": [{"em1Text": "modify the serialized data", "em2Text": "using a crafted input", "label": "None"}, {"em1Text": "modify the serialized data", "em2Text": "invoke any such [code] method that is on your classpath", "label": "None"}, {"em1Text": "modify the serialized data", "em2Text": "code injection", "label": "None"}, {"em1Text": "modify the serialized data", "em2Text": "allocate several gigabytes of memory", "label": "None"}, {"em1Text": "modify the serialized data", "em2Text": "have your system down with an [code] in no time", "label": "None"}, {"em1Text": "using a crafted input", "em2Text": "modify the serialized data", "label": "None"}, {"em1Text": "using a crafted input", "em2Text": "invoke any such [code] method that is on your classpath", "label": "None"}, {"em1Text": "using a crafted input", "em2Text": "code injection", "label": "None"}, {"em1Text": "using a crafted input", "em2Text": "allocate several gigabytes of memory", "label": "None"}, {"em1Text": "using a crafted input", "em2Text": "have your system down with an [code] in no time", "label": "None"}, {"em1Text": "invoke any such [code] method that is on your classpath", "em2Text": "modify the serialized data", "label": "None"}, {"em1Text": "invoke any such [code] method that is on your classpath", "em2Text": "using a crafted input", "label": "PARENT"}, {"em1Text": "invoke any such [code] method that is on your classpath", "em2Text": "code injection", "label": "None"}, {"em1Text": "invoke any such [code] method that is on your classpath", "em2Text": "allocate several gigabytes of memory", "label": "None"}, {"em1Text": "invoke any such [code] method that is on your classpath", "em2Text": "have your system down with an [code] in no time", "label": "None"}, {"em1Text": "code injection", "em2Text": "modify the serialized data", "label": "None"}, {"em1Text": "code injection", "em2Text": "using a crafted input", "label": "None"}, {"em1Text": "code injection", "em2Text": "invoke any such [code] method that is on your classpath", "label": "None"}, {"em1Text": "code injection", "em2Text": "allocate several gigabytes of memory", "label": "None"}, {"em1Text": "code injection", "em2Text": "have your system down with an [code] in no time", "label": "None"}, {"em1Text": "allocate several gigabytes of memory", "em2Text": "modify the serialized data", "label": "None"}, {"em1Text": "allocate several gigabytes of memory", "em2Text": "using a crafted input", "label": "None"}, {"em1Text": "allocate several gigabytes of memory", "em2Text": "invoke any such [code] method that is on your classpath", "label": "None"}, {"em1Text": "allocate several gigabytes of memory", "em2Text": "code injection", "label": "None"}, {"em1Text": "allocate several gigabytes of memory", "em2Text": "have your system down with an [code] in no time", "label": "None"}, {"em1Text": "have your system down with an [code] in no time", "em2Text": "modify the serialized data", "label": "None"}, {"em1Text": "have your system down with an [code] in no time", "em2Text": "using a crafted input", "label": "None"}, {"em1Text": "have your system down with an [code] in no time", "em2Text": "invoke any such [code] method that is on your classpath", "label": "None"}, {"em1Text": "have your system down with an [code] in no time", "em2Text": "code injection", "label": "None"}, {"em1Text": "have your system down with an [code] in no time", "em2Text": "allocate several gigabytes of memory", "label": "PARENT"}], "entityMentions": [{"start": 39, "text": "modify the serialized data", "label": "ATTACK"}, {"start": 343, "text": "using a crafted input", "label": "ATTACK"}, {"start": 373, "text": "invoke any such [code] method that is on your classpath", "label": "ATTACK"}, {"start": 451, "text": "code injection", "label": "ATTACK"}, {"start": 811, "text": "allocate several gigabytes of memory", "label": "ATTACK"}, {"start": 907, "text": "have your system down with an [code] in no time", "label": "ATTACK"}], "sentText": "(threat model: the attacker may freely modify the serialized data, but that's all he can do) deserialization itself can already be unsafe. a serializable class may define a [code] method (see also the [link]), which is called when an object of this class is going to be deserialized from the stream. the attacker cannot provide this code, but using a crafted input she can invoke any such [code] method that is on your classpath, with any input.  <h3>code injection</h3> it is possible to make a [code] implementation that opens the door to arbitrary bytecode injection. simply read a byte array from the stream and pass it to [code] and [code] (see the javadoc for [link] and [link]). i don't know what the use of such an implementation would be, but it is possible. this makes it very easy for an attacker to allocate several gigabytes of memory with just a few dozen bytes of serialized data, which will have your system down with an [code] in no time. by controlling the input to the deserialization process an attacker can trigger the invocation of any [code] deserialization-method. it is theoretically possible for such a method to allow bytecode injection. in practice it is certainly possible to easily exhaust memory or cpu resources this way, resulting in denial-of-service attacks. auditing your system against such vulnerabilities is very difficult: you have to check every implementation of [code], including those in third-party libraries and the runtime library. "}, {"sentId": 21, "articleId": "1", "threatType": "I", "relationMentions": [{"em1Text": "brute force attacks", "em2Text": "password stored unencrypted", "label": "PARENT"}, {"em1Text": "password stored unencrypted", "em2Text": "brute force attacks", "label": "None"}], "entityMentions": [{"start": 38, "text": "brute force attacks", "label": "ATTACK"}, {"start": 88, "text": "password stored unencrypted", "label": "ATTACK"}], "sentText": "wouldn't this just make it easier for brute force attacks? (bad)does this imply that my password stored unencrypted? (bad) if someone with (hopefully) some good it security professionals working for them are imposing a max password length to avoid password stored unencrypted, should i think about doing similar? what are the pros/cons of this? "}, {"sentId": 76, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 122, "text": "xss insertions", "label": "ATTACK"}], "sentText": "i'm wondering what security issues i should be aware of while doing this. i've already taken measures to avoid any simple xss insertions, because my xml library will escape any special characters, but i imagine there are more sophisticated attacks. "}, {"sentId": 152, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 110, "text": "sql injection", "label": "ATTACK"}], "sentText": "i want to give end users the ability to save html to my backend store.  since this feature could easily cause sql injection, and loads of other issues, does anyone know of a server side library that will clean the input so only the \"safe\" parts of html can be used? "}, {"sentId": 56, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "sets a time limited cookie", "em2Text": "attacker guessing a session id guid based on a guid they have previously", "label": "None"}, {"em1Text": "attacker guessing a session id guid based on a guid they have previously", "em2Text": "sets a time limited cookie", "label": "PARENT"}], "entityMentions": [{"start": 46, "text": "sets a time limited cookie", "label": "ATTACK"}, {"start": 379, "text": "attacker guessing a session id guid based on a guid they have previously", "label": "ATTACK"}], "sentText": "my web application operates only over ssl and sets a time limited cookie for each user after they successfully login with a username and password. the biggest weaknesses in the system are one compromising an existing user's cookie. and two guessing a session id guid.  i know of mechanisms for the first weakness but i'm wondering how much i need to worry about the chance of an attacker guessing a session id guid based on a guid they have previously obtained by logging into an account they have set up? the web server in this case is windows 2003 and the guids are being generated with .net 3.5. "}, {"sentId": 3, "articleId": "2", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 268, "text": "injections into the database", "label": "ATTACK"}], "sentText": "when you're making serious web apps that'll handle large amounts of data, what precautions should i take against my data inputs to fully sanitise it? i know there's the obvious trim, escaping, xss cleaning, etc - but what other techniques should i incorporate to stop injections into the database? "}, {"sentId": 64, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "reverse-engineer the obfuscation algorithm", "em2Text": "capture what's sent over the wire", "label": "OR"}, {"em1Text": "capture what's sent over the wire", "em2Text": "reverse-engineer the obfuscation algorithm", "label": "None"}], "entityMentions": [{"start": 122, "text": "reverse-engineer the obfuscation algorithm", "label": "ATTACK"}, {"start": 201, "text": "capture what's sent over the wire", "label": "ATTACK"}], "sentText": "you can never trust the client. even if you obfuscate, someone could still figure it out. for example, an adversary could reverse-engineer the obfuscation algorithm, look at the device memory, or even capture what's sent over the wire. "}, {"sentId": 56, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "user has full controll of the execution environment", "em2Text": "anything you can think of - can be tampered with", "label": "None"}, {"em1Text": "anything you can think of - can be tampered with", "em2Text": "user has full controll of the execution environment", "label": "PARENT"}], "entityMentions": [{"start": 56, "text": "user has full controll of the execution environment", "label": "ATTACK"}, {"start": 154, "text": "anything you can think of - can be tampered with", "label": "ATTACK"}], "sentText": "you cannot authorize anything in angularjs, because the user has full controll of the execution environment (namely, the browser). each check, case, if - anything you can think of - can be tampered with. there are javascript libraries that use asymmetric keys to perform local encryption to store local data somewhat safely, but they are not what you are looking for, really. "}, {"sentId": 35, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "storing api keys in my app", "em2Text": "open it and get the key", "label": "None"}, {"em1Text": "open it and get the key", "em2Text": "storing api keys in my app", "label": "PARENT"}], "entityMentions": [{"start": 14, "text": "storing api keys in my app", "label": "ATTACK"}, {"start": 687, "text": "open it and get the key", "label": "ATTACK"}], "sentText": "currently i'm storing api keys in my app. which yes is a bad practice. now to the best of my knowledge i can use progaurd or dexgaurd to obfuscate. i can also use keystore to securely store my api keys. now for this part here' my question:- obfuscation changes the name of variables and classes. my api key will still be in that app when someone decompiles the apk file. sure it might take more time, but how much more is it? for example 20 minutes? i feel like the bottom line is that they can use this key if they put some time and effort. am i getting this wrong? how is that even possible? a server is going to send the api key to the app. if the hacker finds this url they can just open it and get the key. if i use a key to access the url then i'm entering a never ending loop of keys. how would i do this?someone said that i can encrypt my keys and then decrypt them in the app once it's received. but can't people decompile my decryption function and figure out my key? "}, {"sentId": 53, "articleId": "2", "threatType": "S", "relationMentions": [{"em1Text": "malicious user steals the [code] of an other user", "em2Text": "impersonate that user", "label": "None"}, {"em1Text": "impersonate that user", "em2Text": "malicious user steals the [code] of an other user", "label": "PARENT"}], "entityMentions": [{"start": 34, "text": "malicious user steals the [code] of an other user", "label": "ATTACK"}, {"start": 137, "text": "impersonate that user", "label": "ATTACK"}], "sentText": "a security issue may arise when a malicious user steals the [code] of an other user. without some kind of check, he will then be free to impersonate that user. we need to find a way to uniquely identify the client (not the user). "}, {"sentId": 93, "articleId": "1", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 71, "text": "mysql db was dumped and stolen", "label": "ATTACK"}], "sentText": "so long story short, our company recently had an intrusion wherein our mysql db was dumped and stolen. the execs are really nervous now and in addition to upping other security measures, they are intent on encrypting all customer information (email address, home address, names, and the like) in the db. "}, {"sentId": 65, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 99, "text": "brute force login attacks", "label": "ATTACK"}], "sentText": "as a response to the recent [link] and [link], what is the best way to secure your website against brute force login attacks? "}, {"sentId": 63, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 94, "text": "a brute force password guessing attack", "label": "ATTACK"}], "sentText": "does anyone know of a django app which can be used to extend django auth and lock accounts if a brute force password guessing attack is mounted? "}, {"sentId": 1, "articleId": "3", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 242, "text": "the wysiwyg editor will output html to be rendered into the document", "label": "ATTACK"}], "sentText": "technical background info: we are running using django 1.3 and have not chosen a specific editor yet. we are leaning towards a javascript one such as tinymce, but can be persuaded to use anything that allows security and ease of use. because the wysiwyg editor will output html to be rendered into the document, we cannot simply escape it. "}, {"sentId": 24, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "getting subscription_json from client", "em2Text": "converting it to string", "label": "AND"}, {"em1Text": "getting subscription_json from client", "em2Text": "setting it to model object using gson library", "label": "None"}, {"em1Text": "getting subscription_json from client", "em2Text": "json injection", "label": "None"}, {"em1Text": "converting it to string", "em2Text": "getting subscription_json from client", "label": "None"}, {"em1Text": "converting it to string", "em2Text": "setting it to model object using gson library", "label": "AND"}, {"em1Text": "converting it to string", "em2Text": "json injection", "label": "None"}, {"em1Text": "setting it to model object using gson library", "em2Text": "getting subscription_json from client", "label": "None"}, {"em1Text": "setting it to model object using gson library", "em2Text": "converting it to string", "label": "None"}, {"em1Text": "setting it to model object using gson library", "em2Text": "json injection", "label": "None"}, {"em1Text": "json injection", "em2Text": "getting subscription_json from client", "label": "None"}, {"em1Text": "json injection", "em2Text": "converting it to string", "label": "None"}, {"em1Text": "json injection", "em2Text": "setting it to model object using gson library", "label": "PARENT"}], "entityMentions": [{"start": 5, "text": "getting subscription_json from client", "label": "ATTACK"}, {"start": 54, "text": "converting it to string", "label": "ATTACK"}, {"start": 87, "text": "setting it to model object using gson library", "label": "ATTACK"}, {"start": 191, "text": "json injection", "label": "ATTACK"}], "sentText": "i am getting subscription_json from client which i am converting it to string and then setting it to model object using gson library. on running the code on fortify security, it is giving me json injection error on below code with following message : "}, {"sentId": 47, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "xss", "em2Text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "label": "PARENT"}, {"em1Text": "xss", "em2Text": "dom-based xss", "label": "None"}, {"em1Text": "xss", "em2Text": "malicious script is generated dynamically on the client", "label": "None"}, {"em1Text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "em2Text": "xss", "label": "None"}, {"em1Text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "em2Text": "dom-based xss", "label": "OR"}, {"em1Text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "em2Text": "malicious script is generated dynamically on the client", "label": "None"}, {"em1Text": "dom-based xss", "em2Text": "xss", "label": "None"}, {"em1Text": "dom-based xss", "em2Text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "label": "None"}, {"em1Text": "dom-based xss", "em2Text": "malicious script is generated dynamically on the client", "label": "PARENT"}, {"em1Text": "malicious script is generated dynamically on the client", "em2Text": "xss", "label": "None"}, {"em1Text": "malicious script is generated dynamically on the client", "em2Text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "label": "None"}, {"em1Text": "malicious script is generated dynamically on the client", "em2Text": "dom-based xss", "label": "None"}], "entityMentions": [{"start": 112, "text": "xss", "label": "ATTACK"}, {"start": 399, "text": "server dynamically outputs htmlencoded values directly into the client-side javascript", "label": "ATTACK"}, {"start": 641, "text": "dom-based xss", "label": "ATTACK"}, {"start": 668, "text": "malicious script is generated dynamically on the client", "label": "ATTACK"}], "sentText": "i am not concerned about other kinds of attacks. just want to know whether html encode can prevent all kinds of xss attacks. is there some way to do an xss attack even if html encode is used? putting aside the subject of allowing some tags (not really the point of the question), htmlencode simply does not cover all xss attacks. for instance, consider server-generated client-side javascript - the server dynamically outputs htmlencoded values directly into the client-side javascript, htmlencode will not stop injected script from executing. there are a few additional vectors to be considered... including the third flavor of xss, called dom-based xss (wherein the malicious script is generated dynamically on the client, e.g. based on # values). if you're using ms asp.net, you can use their anti-xss library, which provides all of the necessary context-encoding methods. "}, {"sentId": 66, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "part of the code", "em2Text": "send a null byte to bypass it's security", "label": "None"}, {"em1Text": "send a null byte to bypass it's security", "em2Text": "part of the code", "label": "PARENT"}], "entityMentions": [{"start": 0, "text": "part of the code", "label": "ATTACK"}, {"start": 103, "text": "send a null byte to bypass it's security", "label": "ATTACK"}], "sentText": "part of the code : but none of these methods worked. is that code really secure? and how could someone send a null byte to bypass it's security. i want to demonstrate to my friend that his code is not secure. "}, {"sentId": 39, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "cracking my account and downloading them", "em2Text": "give any results to the attacker", "label": "None"}, {"em1Text": "give any results to the attacker", "em2Text": "cracking my account and downloading them", "label": "PARENT"}], "entityMentions": [{"start": 84, "text": "cracking my account and downloading them", "label": "ATTACK"}, {"start": 185, "text": "give any results to the attacker", "label": "ATTACK"}], "sentText": "still, can the data that is being worked with there be accessed somehow (other than cracking my account and downloading them :)), since obviously opening such files in browser will not give any results to the attacker?  "}, {"sentId": 103, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "command injection", "em2Text": "a variable can contain malicious code", "label": "None"}, {"em1Text": "a variable can contain malicious code", "em2Text": "command injection", "label": "None"}], "entityMentions": [{"start": 100, "text": "command injection", "label": "ATTACK"}, {"start": 267, "text": "a variable can contain malicious code", "label": "ATTACK"}], "sentText": "i was wondering, nowadays with the most recent versions of sh, bash, ksh etc. is it possible to get command injection by executing this (very simple) script? despite of the fact that one can already execute code if they have a shell of course, i am just wondering if a variable can contain malicious code like for example in php:  "}, {"sentId": 52, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "extract the public key from the host application", "em2Text": "inject it into an assembly of your own", "label": "None"}, {"em1Text": "extract the public key from the host application", "em2Text": "run mallicious code", "label": "None"}, {"em1Text": "inject it into an assembly of your own", "em2Text": "extract the public key from the host application", "label": "PARENT"}, {"em1Text": "inject it into an assembly of your own", "em2Text": "run mallicious code", "label": "None"}, {"em1Text": "run mallicious code", "em2Text": "extract the public key from the host application", "label": "None"}, {"em1Text": "run mallicious code", "em2Text": "inject it into an assembly of your own", "label": "PARENT"}], "entityMentions": [{"start": 244, "text": "extract the public key from the host application", "label": "ATTACK"}, {"start": 297, "text": "inject it into an assembly of your own", "label": "ATTACK"}, {"start": 340, "text": "run mallicious code", "label": "ATTACK"}], "sentText": "can't this be spoofed? i am not sure if the setpublickey() method has any effect on a built assembly, but even the msdn documentation shows how you can use this on a dynamically generated assembly (reflection emit) so that would mean you could extract the public key from the host application and inject it into an assembly of your own and run mallicious code if the above was the safe-guard, or am i missing something? "}, {"sentId": 121, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 332, "text": "sql injections", "label": "ATTACK"}], "sentText": "\"postgresql is insecure because of multiselects\" - i'd assume `multiselects` are what i'd call `subselects`, but i might be wrong. current mysql versions support subselects, but according to [1] some libraries might not support or might have disabled them. could that be the reason for the claim or am i overlooking something here?\"sql injections are the easiest to exploit with postgresql\" - imho sql injections are an application / library problem and are simply valid sql queries, so there is no real difference between databases, right?!\"i love postgresql for getting root permissions as it has so many security holes\" - first i'd assume postgresql's security track record is about as good as mysql's (couldn't really find much on this)? secondly running postgresql as root is simply a stupid idea. or is there anything valid in this? "}, {"sentId": 33, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "uses addslashes() exclusively still vulnerable to sql injection", "em2Text": "addslashes is generally not good enough when dealing with multibyte encoded strings.", "label": "PARENT"}, {"em1Text": "addslashes is generally not good enough when dealing with multibyte encoded strings.", "em2Text": "uses addslashes() exclusively still vulnerable to sql injection", "label": "None"}], "entityMentions": [{"start": 92, "text": "uses addslashes() exclusively still vulnerable to sql injection", "label": "ATTACK"}, {"start": 174, "text": "addslashes is generally not good enough when dealing with multibyte encoded strings.", "label": "ATTACK"}], "sentText": "ignoring for the moment the superior alternative of parameterized queries, is a webapp that uses addslashes() exclusively still vulnerable to sql injection, and if yes, how? addslashes is generally not good enough when dealing with multibyte encoded strings.so we need a db-specific functions like mysql_real_escape_string() "}, {"sentId": 102, "articleId": "6", "threatType": "E", "relationMentions": [{"em1Text": "the session identifier were known by an attacker ", "em2Text": "had access to  the user's workstation", "label": "AND"}, {"em1Text": "the session identifier were known by an attacker ", "em2Text": "the logged out session could be accessed", "label": "None"}, {"em1Text": "had access to  the user's workstation", "em2Text": "the session identifier were known by an attacker ", "label": "None"}, {"em1Text": "had access to  the user's workstation", "em2Text": "the logged out session could be accessed", "label": "None"}, {"em1Text": "the logged out session could be accessed", "em2Text": "the session identifier were known by an attacker ", "label": "PARENT"}, {"em1Text": "the logged out session could be accessed", "em2Text": "had access to  the user's workstation", "label": "None"}], "entityMentions": [{"start": 5, "text": "the session identifier were known by an attacker ", "label": "ATTACK"}, {"start": 58, "text": "had access to  the user's workstation", "label": "ATTACK"}, {"start": 97, "text": "the logged out session could be accessed", "label": "ATTACK"}], "sentText": "  if the session identifier were known by an attacker who had access to  the user's workstation, the logged out session could be accessed using  the session cookie after the user had terminated their session.  "}, {"sentId": 42, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "web-server goes down for any reason", "em2Text": "a network cable being disconnected somewhere", "label": "OR"}, {"em1Text": "web-server goes down for any reason", "em2Text": "the user hits logout", "label": "None"}, {"em1Text": "web-server goes down for any reason", "em2Text": "another user could come along when the connection is restored", "label": "None"}, {"em1Text": "web-server goes down for any reason", "em2Text": "server comes back", "label": "None"}, {"em1Text": "web-server goes down for any reason", "em2Text": "continue using the previous users account", "label": "None"}, {"em1Text": "a network cable being disconnected somewhere", "em2Text": "web-server goes down for any reason", "label": "None"}, {"em1Text": "a network cable being disconnected somewhere", "em2Text": "the user hits logout", "label": "None"}, {"em1Text": "a network cable being disconnected somewhere", "em2Text": "another user could come along when the connection is restored", "label": "None"}, {"em1Text": "a network cable being disconnected somewhere", "em2Text": "server comes back", "label": "None"}, {"em1Text": "a network cable being disconnected somewhere", "em2Text": "continue using the previous users account", "label": "None"}, {"em1Text": "the user hits logout", "em2Text": "web-server goes down for any reason", "label": "None"}, {"em1Text": "the user hits logout", "em2Text": "a network cable being disconnected somewhere", "label": "PARENT"}, {"em1Text": "the user hits logout", "em2Text": "another user could come along when the connection is restored", "label": "None"}, {"em1Text": "the user hits logout", "em2Text": "server comes back", "label": "None"}, {"em1Text": "the user hits logout", "em2Text": "continue using the previous users account", "label": "None"}, {"em1Text": "another user could come along when the connection is restored", "em2Text": "web-server goes down for any reason", "label": "None"}, {"em1Text": "another user could come along when the connection is restored", "em2Text": "a network cable being disconnected somewhere", "label": "None"}, {"em1Text": "another user could come along when the connection is restored", "em2Text": "the user hits logout", "label": "PARENT"}, {"em1Text": "another user could come along when the connection is restored", "em2Text": "server comes back", "label": "None"}, {"em1Text": "another user could come along when the connection is restored", "em2Text": "continue using the previous users account", "label": "None"}, {"em1Text": "server comes back", "em2Text": "web-server goes down for any reason", "label": "None"}, {"em1Text": "server comes back", "em2Text": "a network cable being disconnected somewhere", "label": "None"}, {"em1Text": "server comes back", "em2Text": "the user hits logout", "label": "None"}, {"em1Text": "server comes back", "em2Text": "another user could come along when the connection is restored", "label": "OR"}, {"em1Text": "server comes back", "em2Text": "continue using the previous users account", "label": "None"}, {"em1Text": "continue using the previous users account", "em2Text": "web-server goes down for any reason", "label": "None"}, {"em1Text": "continue using the previous users account", "em2Text": "a network cable being disconnected somewhere", "label": "None"}, {"em1Text": "continue using the previous users account", "em2Text": "the user hits logout", "label": "None"}, {"em1Text": "continue using the previous users account", "em2Text": "another user could come along when the connection is restored", "label": "None"}, {"em1Text": "continue using the previous users account", "em2Text": "server comes back", "label": "PARENT"}], "entityMentions": [{"start": 28, "text": "web-server goes down for any reason", "label": "ATTACK"}, {"start": 92, "text": "a network cable being disconnected somewhere", "label": "ATTACK"}, {"start": 144, "text": "the user hits logout", "label": "ATTACK"}, {"start": 274, "text": "another user could come along when the connection is restored", "label": "ATTACK"}, {"start": 339, "text": "server comes back", "label": "ATTACK"}, {"start": 367, "text": "continue using the previous users account", "label": "ATTACK"}], "sentText": "my concern is that when the web-server goes down for any reason (or becomes inaccessible eg a network cable being disconnected somewhere). when the user hits logout, there is actually no way of removing the cookie. meaning that the user may walk away from the pc, meanwhile another user could come along when the connection is restored or server comes back, and just continue using the previous users account. "}, {"sentId": 51, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "direct posting of data to your site", "em2Text": "csrf", "label": "None"}, {"em1Text": "csrf", "em2Text": "direct posting of data to your site", "label": "PARENT"}], "entityMentions": [{"start": 475, "text": "direct posting of data to your site", "label": "ATTACK"}, {"start": 94, "text": "csrf", "label": "ATTACK"}], "sentText": "i'm writing a django restful api to back an ios application, and i keep running into django's csrf protections whenever i write methods to deal with post requests.my understanding is that cookies managed by ios are not shared by applications, meaning that my session cookies are safe, and no other application can ride on them. is this true? if so, can i just mark all my api functions as csrf-exempt? that's not the purpose of csrf protection. csrf protection is to prevent direct posting of data to your site. in other words, the client must actually post through an approved path, i.e. view the form page, fill it out, submit the data.an api pretty much precludes csrf, because its entire purpose is generally to allow 3rd-party entities to access and manipulate data on your site (the &quot;cross-site&quot; in csrf). so, yes, i think as a rule any api view should be csrf exempt. however, you should still follow best practices and protect every api-endpoint that actually makes a change with some form of authentication, such as oauth. "}, {"sentId": 1, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "csrf attacks", "em2Text": "attacker steals a token", "label": "PARENT"}, {"em1Text": "attacker steals a token", "em2Text": "csrf attacks", "label": "None"}], "entityMentions": [{"start": 67, "text": "csrf attacks", "label": "ATTACK"}, {"start": 302, "text": "attacker steals a token", "label": "ATTACK"}], "sentText": "as far as i understand there are two approaches in protecting from csrf attacks: 1) token per session, and 2) token per request 2) in the second case new csrf token is being generated on each request and after that an old one becomes invalid.it makes harder to exploit the vunerability because even if attacker steals a token (via xss) it expires when the user goes to the next page.but on the other hand this approach makes webapp less usable. here is a good quotation from [link]: "}, {"sentId": 28, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "decompile your apk and classes", "em2Text": "get the encryption key", "label": "None"}, {"em1Text": "get the encryption key", "em2Text": "decompile your apk and classes", "label": "PARENT"}], "entityMentions": [{"start": 396, "text": "decompile your apk and classes", "label": "ATTACK"}, {"start": 431, "text": "get the encryption key", "label": "ATTACK"}], "sentText": "i am going to use oauth to fetch mails and contacts from google. i don't want to ask the user each time to log in to obtain an access token and secret. from what i understood, i need to store them with my application either in a database or [code]. but i am a bit worried about security aspects with that. i read that you can encrypt and decrypt the tokens but it is easy for an attacker to just decompile your apk and classes and get the encryption key.what's the best method to securely store these tokens in android? "}, {"sentId": 24, "articleId": "3", "threatType": "T", "relationMentions": [{"em1Text": "brute-force/dictionary attacks", "em2Text": "attack a single password from a stolen password database", "label": "PARENT"}, {"em1Text": "brute-force/dictionary attacks", "em2Text": "try a lot of passwords", "label": "None"}, {"em1Text": "attack a single password from a stolen password database", "em2Text": "brute-force/dictionary attacks", "label": "None"}, {"em1Text": "attack a single password from a stolen password database", "em2Text": "try a lot of passwords", "label": "PARENT"}, {"em1Text": "try a lot of passwords", "em2Text": "brute-force/dictionary attacks", "label": "None"}, {"em1Text": "try a lot of passwords", "em2Text": "attack a single password from a stolen password database", "label": "None"}], "entityMentions": [{"start": 109, "text": "brute-force/dictionary attacks", "label": "ATTACK"}, {"start": 195, "text": "attack a single password from a stolen password database", "label": "ATTACK"}, {"start": 265, "text": "try a lot of passwords", "label": "ATTACK"}], "sentText": "alright, prepending/appending the salt doesn't really make a difference for rainbow tables.hardening against brute-force/dictionary attacks this is what my question is about. if someone wants to attack a single password from a stolen password database, he needs to try a lot of passwords (e.g. dictionary words or [a-za-z0-9] permutations). "}, {"sentId": 29, "articleId": "3", "threatType": "I", "relationMentions": [{"em1Text": "timing attack", "em2Text": "positioning the password", "label": "None"}, {"em1Text": "timing attack", "em2Text": "try a series passwords positioned", "label": "None"}, {"em1Text": "timing attack", "em2Text": "know that the first character matched", "label": "None"}, {"em1Text": "timing attack", "em2Text": "repeat that for each character in the password", "label": "PARENT"}, {"em1Text": "positioning the password", "em2Text": "timing attack", "label": "None"}, {"em1Text": "positioning the password", "em2Text": "try a series passwords positioned", "label": "None"}, {"em1Text": "positioning the password", "em2Text": "know that the first character matched", "label": "None"}, {"em1Text": "positioning the password", "em2Text": "repeat that for each character in the password", "label": "PARENT"}, {"em1Text": "try a series passwords positioned", "em2Text": "timing attack", "label": "None"}, {"em1Text": "try a series passwords positioned", "em2Text": "positioning the password", "label": "None"}, {"em1Text": "try a series passwords positioned", "em2Text": "know that the first character matched", "label": "None"}, {"em1Text": "try a series passwords positioned", "em2Text": "repeat that for each character in the password", "label": "None"}, {"em1Text": "know that the first character matched", "em2Text": "timing attack", "label": "None"}, {"em1Text": "know that the first character matched", "em2Text": "positioning the password", "label": "None"}, {"em1Text": "know that the first character matched", "em2Text": "try a series passwords positioned", "label": "PARENT"}, {"em1Text": "know that the first character matched", "em2Text": "repeat that for each character in the password", "label": "None"}, {"em1Text": "repeat that for each character in the password", "em2Text": "timing attack", "label": "None"}, {"em1Text": "repeat that for each character in the password", "em2Text": "positioning the password", "label": "None"}, {"em1Text": "repeat that for each character in the password", "em2Text": "try a series passwords positioned", "label": "None"}, {"em1Text": "repeat that for each character in the password", "em2Text": "know that the first character matched", "label": "None"}], "entityMentions": [{"start": 158, "text": "timing attack", "label": "ATTACK"}, {"start": 565, "text": "positioning the password", "label": "ATTACK"}, {"start": 685, "text": "try a series passwords positioned", "label": "ATTACK"}, {"start": 788, "text": "know that the first character matched", "label": "ATTACK"}, {"start": 916, "text": "repeat that for each character in the password", "label": "ATTACK"}], "sentText": "it seems that [link], the login utility on unix systems only calculated a hash when a valid username existed; this opened a security flaw which allowed for a timing attack, as the user could tell when a username was found by the amount of time it required to generate hashed key for comparison.  would the additional hash computation make sense for this scenario? if i employ rate-limiting on auth calls, does this decrease the possibility of a timing attack like this?  the original timing attack, the [link] attack, had nothing to do with hashing -- it worked by positioning the password so that it crossed page boundaries leading to a virtual memory cache miss.  the attacker could try a series passwords positioned so that only the first character was in the first page, and it would know that the first character matched when verification took long enough for a cache miss to have happened.  the attacker could repeat that for each character in the password. unless the attacker has control over fine-grained positioning of inputs in memory, no, timing attacks on passwords are not an issue, but any secret checking algo that is super-linear w.r.t. the length of the secret (>= o(length of secret)) might leak information about the password length. note, the term \"timing attack\" is also used in other contexts, and those can affect web applications.  for example when a system clock is used to construct a [link] between two processes that should not be able to conspire -- javascript loaded in two different origins could establish a low bandwidth channel by using an interval to check the time and looping to consume processor or not to communicate a bit. "}, {"sentId": 59, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "prevent a user from leaking information using a malicious function in the [code] clause", "em2Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "label": "None"}, {"em1Text": "prevent a user from leaking information using a malicious function in the [code] clause", "em2Text": "see the secret data by selecting that table", "label": "None"}, {"em1Text": "prevent a user from leaking information using a malicious function in the [code] clause", "em2Text": "malicious predicate functions", "label": "None"}, {"em1Text": "prevent a user from leaking information using a malicious function in the [code] clause", "em2Text": "a privileged user to run user-supplied code they did not intend", "label": "None"}, {"em1Text": "prevent a user from leaking information using a malicious function in the [code] clause", "em2Text": "generating a predicate that refers to the malicious function", "label": "None"}, {"em1Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "em2Text": "prevent a user from leaking information using a malicious function in the [code] clause", "label": "None"}, {"em1Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "em2Text": "see the secret data by selecting that table", "label": "None"}, {"em1Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "em2Text": "malicious predicate functions", "label": "None"}, {"em1Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "em2Text": "a privileged user to run user-supplied code they did not intend", "label": "None"}, {"em1Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "em2Text": "generating a predicate that refers to the malicious function", "label": "None"}, {"em1Text": "see the secret data by selecting that table", "em2Text": "prevent a user from leaking information using a malicious function in the [code] clause", "label": "None"}, {"em1Text": "see the secret data by selecting that table", "em2Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "label": "PARENT"}, {"em1Text": "see the secret data by selecting that table", "em2Text": "malicious predicate functions", "label": "None"}, {"em1Text": "see the secret data by selecting that table", "em2Text": "a privileged user to run user-supplied code they did not intend", "label": "None"}, {"em1Text": "see the secret data by selecting that table", "em2Text": "generating a predicate that refers to the malicious function", "label": "None"}, {"em1Text": "malicious predicate functions", "em2Text": "prevent a user from leaking information using a malicious function in the [code] clause", "label": "None"}, {"em1Text": "malicious predicate functions", "em2Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "label": "None"}, {"em1Text": "malicious predicate functions", "em2Text": "see the secret data by selecting that table", "label": "None"}, {"em1Text": "malicious predicate functions", "em2Text": "a privileged user to run user-supplied code they did not intend", "label": "None"}, {"em1Text": "malicious predicate functions", "em2Text": "generating a predicate that refers to the malicious function", "label": "None"}, {"em1Text": "a privileged user to run user-supplied code they did not intend", "em2Text": "prevent a user from leaking information using a malicious function in the [code] clause", "label": "None"}, {"em1Text": "a privileged user to run user-supplied code they did not intend", "em2Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "label": "None"}, {"em1Text": "a privileged user to run user-supplied code they did not intend", "em2Text": "see the secret data by selecting that table", "label": "None"}, {"em1Text": "a privileged user to run user-supplied code they did not intend", "em2Text": "malicious predicate functions", "label": "None"}, {"em1Text": "a privileged user to run user-supplied code they did not intend", "em2Text": "generating a predicate that refers to the malicious function", "label": "PARENT"}, {"em1Text": "generating a predicate that refers to the malicious function", "em2Text": "prevent a user from leaking information using a malicious function in the [code] clause", "label": "None"}, {"em1Text": "generating a predicate that refers to the malicious function", "em2Text": "[code] inserts each value it sees into another table owned by the malicious user's control", "label": "None"}, {"em1Text": "generating a predicate that refers to the malicious function", "em2Text": "see the secret data by selecting that table", "label": "None"}, {"em1Text": "generating a predicate that refers to the malicious function", "em2Text": "malicious predicate functions", "label": "None"}, {"em1Text": "generating a predicate that refers to the malicious function", "em2Text": "a privileged user to run user-supplied code they did not intend", "label": "None"}], "entityMentions": [{"start": 203, "text": "prevent a user from leaking information using a malicious function in the [code] clause", "label": "ATTACK"}, {"start": 300, "text": "[code] inserts each value it sees into another table owned by the malicious user's control", "label": "ATTACK"}, {"start": 409, "text": "see the secret data by selecting that table", "label": "ATTACK"}, {"start": 672, "text": "malicious predicate functions", "label": "ATTACK"}, {"start": 794, "text": "a privileged user to run user-supplied code they did not intend", "label": "ATTACK"}, {"start": 861, "text": "generating a predicate that refers to the malicious function", "label": "ATTACK"}], "sentText": "i've been reading the docs for oracle vpd (virtual private database, a.k.a. fine-grained security, the basis of label-based security), and there's something i'm having a hard time grasping. how does vpd prevent a user from leaking information using a malicious function in the [code] clause? ? where [code] inserts each value it sees into another table owned by the malicious user's control, so they can then see the secret data by selecting that table. i've read the documentation and i'm not seeing where it specifies any ordering guarantee on execution of vpd predicates vs user-supplied predicates. is there such a guarantee, or any other mechanism to protect against malicious predicate functions? (i'm also curious about whether a malicious predicate function in a vpd policy could cause a privileged user to run user-supplied code they did not intend by generating a predicate that refers to the malicious function, but that's somewhat separate.) "}, {"sentId": 78, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 20, "text": "users might upload code that attempts to 'hack' the system", "label": "ATTACK"}], "sentText": "the problem is that users might upload code that attempts to 'hack' the system. i understand that in c and c++ it's easy to disable a certain set of system calls (patch a few .dll's), but i'm not so sure about other languages. "}, {"sentId": 69, "articleId": "1", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 23, "text": "xss", "label": "ATTACK"}], "sentText": "is this technically an xss attack or something else? [link] commit, if it were pulled, would have prevented this xss vulnerability. "}, {"sentId": 32, "articleId": "3", "threatType": "S", "relationMentions": [{"em1Text": "xss vulnerability", "em2Text": "grab another user's authenticity token ", "label": "None"}, {"em1Text": "xss vulnerability", "em2Text": "make use of it for csrf attacks", "label": "None"}, {"em1Text": "xss vulnerability", "em2Text": "grab another user's session cookie", "label": "None"}, {"em1Text": "xss vulnerability", "em2Text": "login as that user directly", "label": "None"}, {"em1Text": "xss vulnerability", "em2Text": "make calls to our rest api from script", "label": "None"}, {"em1Text": "grab another user's authenticity token ", "em2Text": "xss vulnerability", "label": "PARENT"}, {"em1Text": "grab another user's authenticity token ", "em2Text": "make use of it for csrf attacks", "label": "AND"}, {"em1Text": "grab another user's authenticity token ", "em2Text": "grab another user's session cookie", "label": "None"}, {"em1Text": "grab another user's authenticity token ", "em2Text": "login as that user directly", "label": "None"}, {"em1Text": "grab another user's authenticity token ", "em2Text": "make calls to our rest api from script", "label": "None"}, {"em1Text": "make use of it for csrf attacks", "em2Text": "xss vulnerability", "label": "None"}, {"em1Text": "make use of it for csrf attacks", "em2Text": "grab another user's authenticity token ", "label": "None"}, {"em1Text": "make use of it for csrf attacks", "em2Text": "grab another user's session cookie", "label": "None"}, {"em1Text": "make use of it for csrf attacks", "em2Text": "login as that user directly", "label": "None"}, {"em1Text": "make use of it for csrf attacks", "em2Text": "make calls to our rest api from script", "label": "None"}, {"em1Text": "grab another user's session cookie", "em2Text": "xss vulnerability", "label": "PARENT"}, {"em1Text": "grab another user's session cookie", "em2Text": "grab another user's authenticity token ", "label": "None"}, {"em1Text": "grab another user's session cookie", "em2Text": "make use of it for csrf attacks", "label": "None"}, {"em1Text": "grab another user's session cookie", "em2Text": "login as that user directly", "label": "AND"}, {"em1Text": "grab another user's session cookie", "em2Text": "make calls to our rest api from script", "label": "None"}, {"em1Text": "login as that user directly", "em2Text": "xss vulnerability", "label": "None"}, {"em1Text": "login as that user directly", "em2Text": "grab another user's authenticity token ", "label": "None"}, {"em1Text": "login as that user directly", "em2Text": "make use of it for csrf attacks", "label": "None"}, {"em1Text": "login as that user directly", "em2Text": "grab another user's session cookie", "label": "None"}, {"em1Text": "login as that user directly", "em2Text": "make calls to our rest api from script", "label": "None"}, {"em1Text": "make calls to our rest api from script", "em2Text": "xss vulnerability", "label": "PARENT"}, {"em1Text": "make calls to our rest api from script", "em2Text": "grab another user's authenticity token ", "label": "None"}, {"em1Text": "make calls to our rest api from script", "em2Text": "make use of it for csrf attacks", "label": "None"}, {"em1Text": "make calls to our rest api from script", "em2Text": "grab another user's session cookie", "label": "None"}, {"em1Text": "make calls to our rest api from script", "em2Text": "login as that user directly", "label": "None"}], "entityMentions": [{"start": 50, "text": "xss vulnerability", "label": "ATTACK"}, {"start": 91, "text": "grab another user's authenticity token ", "label": "ATTACK"}, {"start": 134, "text": "make use of it for csrf attacks", "label": "ATTACK"}, {"start": 299, "text": "grab another user's session cookie", "label": "ATTACK"}, {"start": 338, "text": "login as that user directly", "label": "ATTACK"}, {"start": 380, "text": "make calls to our rest api from script", "label": "ATTACK"}], "sentText": "the auditor's statement was that if we also had a xss vulnerability that an attacker could grab another user's authenticity token and make use of it for csrf attacks until the user's session expired.  but is seems to me that if we had an xss vulnerability like that an attacker could just as easily grab another user's session cookie and login as that user directly. or even just make calls to our rest api from script as the user being attacked. being able to mount a csrf attack doesn't seem any worse in such a situation... the problem would be the xss vulnerability. "}, {"sentId": 16, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 227, "text": "these be used maliciously to get to access other files in my s3 bucket", "label": "ATTACK"}], "sentText": "i have an image in my aws s3 bucket. is it safe to include this image in my website by placing the aws url in an [code] tag? the url includes parameters such as \"amz-signature\", \"amz-credential\", and \"amz-security-token. could these be used maliciously to get to access other files in my s3 bucket? "}, {"sentId": 37, "articleId": "2", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 29, "text": "session fixation attacks", "label": "ATTACK"}], "sentText": "i'm wondering how to prevent session fixation attacks in asp.net (see [link]) have been doing more digging on this. the best way to prevent session fixation attacks in any web application is to issue a new session identifier when a user logs in. "}, {"sentId": 125, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 69, "text": "injected xss attacks", "label": "ATTACK"}], "sentText": "i'm trying to protect a classic asp web application from http header injected xss attacks and am having trouble finding a solution that stops scripts found in the user agent string.  "}, {"sentId": 11, "articleId": "3", "threatType": "T", "relationMentions": [{"em1Text": "sql injection attack", "em2Text": "retrieve the credentials", "label": "None"}, {"em1Text": "retrieve the credentials", "em2Text": "sql injection attack", "label": "PARENT"}], "entityMentions": [{"start": 315, "text": "sql injection attack", "label": "ATTACK"}, {"start": 342, "text": "retrieve the credentials", "label": "ATTACK"}], "sentText": "i'm working on a python/django app which, among other things, syncs data to a variety of other services, including samba shares, ssh(scp) servers, google apps, and others. as such, it needs to store the credentials to access these services. storing them as unencrypted fields would be, i presume, a bad idea, as an sql injection attack could retrieve the credentials. so i would need to encrypt the creds before storage - are there any reliable libraries to achieve this? "}, {"sentId": 14, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "malicious users visiting the dosomething.ashx page", "em2Text": "making false requests", "label": "AND"}, {"em1Text": "making false requests", "em2Text": "malicious users visiting the dosomething.ashx page", "label": "None"}], "entityMentions": [{"start": 74, "text": "malicious users visiting the dosomething.ashx page", "label": "ATTACK"}, {"start": 129, "text": "making false requests", "label": "ATTACK"}], "sentText": "how can i  guarantee that the request came from the local server, to stop malicious users visiting the dosomething.ashx page and making false requests? "}, {"sentId": 94, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "construct a css file", "em2Text": "inject code into my site", "label": "None"}, {"em1Text": "construct a css file", "em2Text": "gain access to things like my domain's cookies", "label": "None"}, {"em1Text": "construct a css file", "em2Text": "xss attack", "label": "None"}, {"em1Text": "inject code into my site", "em2Text": "construct a css file", "label": "PARENT"}, {"em1Text": "inject code into my site", "em2Text": "gain access to things like my domain's cookies", "label": "OR"}, {"em1Text": "inject code into my site", "em2Text": "xss attack", "label": "None"}, {"em1Text": "gain access to things like my domain's cookies", "em2Text": "construct a css file", "label": "None"}, {"em1Text": "gain access to things like my domain's cookies", "em2Text": "inject code into my site", "label": "None"}, {"em1Text": "gain access to things like my domain's cookies", "em2Text": "xss attack", "label": "None"}, {"em1Text": "xss attack", "em2Text": "construct a css file", "label": "None"}, {"em1Text": "xss attack", "em2Text": "inject code into my site", "label": "None"}, {"em1Text": "xss attack", "em2Text": "gain access to things like my domain's cookies", "label": "PARENT"}], "entityMentions": [{"start": 31, "text": "construct a css file", "label": "ATTACK"}, {"start": 72, "text": "inject code into my site", "label": "ATTACK"}, {"start": 110, "text": "gain access to things like my domain's cookies", "label": "ATTACK"}, {"start": 378, "text": "xss attack", "label": "ATTACK"}], "sentText": "is there any way someone could construct a css file that would let them inject code into my site or otherwise gain access to things like my domain's cookies?  is this really safe, or do i need to come up with a different solution? no it is unsafe.  [code] and [code] are known ways to cause arbitrary script execution on certain browsers via css.  [link] suffered a very public xss attack that was due to javascript embedded in user-supplied css. "}, {"sentId": 18, "articleId": "6", "threatType": "D", "relationMentions": [], "entityMentions": [{"start": 41, "text": "ddos attacks from a certain ip (or pool of ips)", "label": "ATTACK"}], "sentText": "i want to include the capability to stop ddos attacks from a certain ip (or pool of ips). this as to be at the nginx level, rather than any deeper in the code. do i need a web application firewall? if so, how do i integrate it. "}, {"sentId": 79, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 221, "text": "avoid html and javascript injection  attacks", "label": "ATTACK"}], "sentText": "  it is important to always be paranoid  about security when accepting any user  input, and this is also true when  binding objects to form input. you  should be careful to always html  encode any user-entered values to  avoid html and javascript injection  attacks "}, {"sentId": 28, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "post data is sent over curl/ssl", "em2Text": "intercepted or stolen while in traffic", "label": "None"}, {"em1Text": "post data is sent over curl/ssl", "em2Text": "implement this with php ", "label": "AND"}, {"em1Text": "intercepted or stolen while in traffic", "em2Text": "post data is sent over curl/ssl", "label": "PARENT"}, {"em1Text": "intercepted or stolen while in traffic", "em2Text": "implement this with php ", "label": "None"}, {"em1Text": "implement this with php ", "em2Text": "post data is sent over curl/ssl", "label": "None"}, {"em1Text": "implement this with php ", "em2Text": "intercepted or stolen while in traffic", "label": "None"}], "entityMentions": [{"start": 26, "text": "post data is sent over curl/ssl", "label": "ATTACK"}, {"start": 69, "text": "intercepted or stolen while in traffic", "label": "ATTACK"}, {"start": 214, "text": "implement this with php ", "label": "ATTACK"}], "sentText": "my question is, since the post data is sent over curl/ssl, can it be intercepted or stolen while in traffic? can the hacker view the session id in plain text(the most important component here)?  you do not want to implement this with php because this is easily achieved with webservers alone. your server a handling ssl ([link]) can act as an [link] and as a [link] to server b. it's a common setup to divide responsibilites between servers. research these topics please. "}, {"sentId": 103, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "return all the passwords in the table", "em2Text": "sql injection", "label": "None"}, {"em1Text": "sql injection", "em2Text": "return all the passwords in the table", "label": "PARENT"}], "entityMentions": [{"start": 20, "text": "return all the passwords in the table", "label": "ATTACK"}, {"start": 133, "text": "sql injection", "label": "ATTACK"}], "sentText": "the following query return all the passwords in the table tbl_user but i can not understand why this is happening. this is a classic sql injection. "}, {"sentId": 30, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "has physical access to a machine", "em2Text": "look at the filesystem", "label": "AND"}, {"em1Text": "has physical access to a machine", "em2Text": "retrieve a valid session cookie", "label": "None"}, {"em1Text": "has physical access to a machine", "em2Text": "hijack a session", "label": "None"}, {"em1Text": "look at the filesystem", "em2Text": "has physical access to a machine", "label": "None"}, {"em1Text": "look at the filesystem", "em2Text": "retrieve a valid session cookie", "label": "None"}, {"em1Text": "look at the filesystem", "em2Text": "hijack a session", "label": "None"}, {"em1Text": "retrieve a valid session cookie", "em2Text": "has physical access to a machine", "label": "PARENT"}, {"em1Text": "retrieve a valid session cookie", "em2Text": "look at the filesystem", "label": "None"}, {"em1Text": "retrieve a valid session cookie", "em2Text": "hijack a session", "label": "None"}, {"em1Text": "hijack a session", "em2Text": "has physical access to a machine", "label": "None"}, {"em1Text": "hijack a session", "em2Text": "look at the filesystem", "label": "None"}, {"em1Text": "hijack a session", "em2Text": "retrieve a valid session cookie", "label": "PARENT"}], "entityMentions": [{"start": 20, "text": "has physical access to a machine", "label": "ATTACK"}, {"start": 69, "text": "look at the filesystem", "label": "ATTACK"}, {"start": 95, "text": "retrieve a valid session cookie", "label": "ATTACK"}, {"start": 143, "text": "hijack a session", "label": "ATTACK"}], "sentText": "if a malicious user has physical access to a machine, they can still look at the filesystem to retrieve a valid session cookie and use that to hijack a session? "}, {"sentId": 84, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 70, "text": "[code] scope in java can be tampered/altered by external proxy tools", "label": "ATTACK"}], "sentText": "the security team is saying that the above code is vulnerable because [code] scope in java can be tampered/altered by external proxy tools. and since coldfusion is build on java, coldfusion's [code]can also be tampered by external proxy tools. is this a right assumption? is java and coldfusion [code] scope same? "}, {"sentId": 56, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "script source accessible through backup", "em2Text": "local file inclusion", "label": "None"}, {"em1Text": "script source accessible through backup", "em2Text": "directory browsing", "label": "None"}, {"em1Text": "script source accessible through backup", "em2Text": "source disclosure via alternate server", "label": "None"}, {"em1Text": "script source accessible through backup", "em2Text": "sql injection", "label": "None"}, {"em1Text": "script source accessible through backup", "em2Text": "source code disclosure", "label": "None"}, {"em1Text": "local file inclusion", "em2Text": "script source accessible through backup", "label": "None"}, {"em1Text": "local file inclusion", "em2Text": "directory browsing", "label": "None"}, {"em1Text": "local file inclusion", "em2Text": "source disclosure via alternate server", "label": "None"}, {"em1Text": "local file inclusion", "em2Text": "sql injection", "label": "None"}, {"em1Text": "local file inclusion", "em2Text": "source code disclosure", "label": "None"}, {"em1Text": "directory browsing", "em2Text": "script source accessible through backup", "label": "None"}, {"em1Text": "directory browsing", "em2Text": "local file inclusion", "label": "None"}, {"em1Text": "directory browsing", "em2Text": "source disclosure via alternate server", "label": "None"}, {"em1Text": "directory browsing", "em2Text": "sql injection", "label": "None"}, {"em1Text": "directory browsing", "em2Text": "source code disclosure", "label": "None"}, {"em1Text": "source disclosure via alternate server", "em2Text": "script source accessible through backup", "label": "None"}, {"em1Text": "source disclosure via alternate server", "em2Text": "local file inclusion", "label": "None"}, {"em1Text": "source disclosure via alternate server", "em2Text": "directory browsing", "label": "None"}, {"em1Text": "source disclosure via alternate server", "em2Text": "sql injection", "label": "None"}, {"em1Text": "source disclosure via alternate server", "em2Text": "source code disclosure", "label": "None"}, {"em1Text": "sql injection", "em2Text": "script source accessible through backup", "label": "None"}, {"em1Text": "sql injection", "em2Text": "local file inclusion", "label": "None"}, {"em1Text": "sql injection", "em2Text": "directory browsing", "label": "None"}, {"em1Text": "sql injection", "em2Text": "source disclosure via alternate server", "label": "None"}, {"em1Text": "sql injection", "em2Text": "source code disclosure", "label": "None"}, {"em1Text": "source code disclosure", "em2Text": "script source accessible through backup", "label": "None"}, {"em1Text": "source code disclosure", "em2Text": "local file inclusion", "label": "None"}, {"em1Text": "source code disclosure", "em2Text": "directory browsing", "label": "None"}, {"em1Text": "source code disclosure", "em2Text": "source disclosure via alternate server", "label": "None"}, {"em1Text": "source code disclosure", "em2Text": "sql injection", "label": "PARENT"}], "entityMentions": [{"start": 239, "text": "script source accessible through backup", "label": "ATTACK"}, {"start": 279, "text": "local file inclusion", "label": "ATTACK"}, {"start": 300, "text": "directory browsing", "label": "ATTACK"}, {"start": 320, "text": "source disclosure via alternate server", "label": "ATTACK"}, {"start": 359, "text": "sql injection", "label": "ATTACK"}, {"start": 0, "text": "source code disclosure", "label": "ATTACK"}], "sentText": "source code disclosure can happen on a well-configured server and is not as rare as you might think. as the others have said, if your server-configuration is sound, then there won't be a problem with people requesting php files directly.  script source accessible through backup local file inclusion directory browsing  source disclosure via alternate server sql injection pretty much every serious dbms has a function that allows it to read files on the system. if you don't protect your database inputs (please just use parameterised queries) you may be vulnerable to source code disclosure through this mechanism. mind you, in this scenario, source-code disclosure is your last concern. "}, {"sentId": 157, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "the middle man gets request from victim", "em2Text": "he fires https request himself", "label": "AND"}, {"em1Text": "the middle man gets request from victim", "em2Text": "returns content to the user", "label": "None"}, {"em1Text": "the middle man gets request from victim", "em2Text": "mitm attacks", "label": "None"}, {"em1Text": "he fires https request himself", "em2Text": "the middle man gets request from victim", "label": "None"}, {"em1Text": "he fires https request himself", "em2Text": "returns content to the user", "label": "AND"}, {"em1Text": "he fires https request himself", "em2Text": "mitm attacks", "label": "None"}, {"em1Text": "returns content to the user", "em2Text": "the middle man gets request from victim", "label": "None"}, {"em1Text": "returns content to the user", "em2Text": "he fires https request himself", "label": "None"}, {"em1Text": "returns content to the user", "em2Text": "mitm attacks", "label": "None"}, {"em1Text": "mitm attacks", "em2Text": "the middle man gets request from victim", "label": "PARENT"}, {"em1Text": "mitm attacks", "em2Text": "he fires https request himself", "label": "None"}, {"em1Text": "mitm attacks", "em2Text": "returns content to the user", "label": "None"}], "entityMentions": [{"start": 38, "text": "the middle man gets request from victim", "label": "ATTACK"}, {"start": 102, "text": "he fires https request himself", "label": "ATTACK"}, {"start": 158, "text": "returns content to the user", "label": "ATTACK"}, {"start": 302, "text": "mitm attacks", "label": "ATTACK"}], "sentText": "let's imagine the following scenario: the middle man gets request from victim: http ://site.com. then he fires https request himself to https ://site.com and returns content to the user, stripping the hsts header. all further user input is visible to the attacker. does hsts header really help against mitm attacks? "}, {"sentId": 79, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "csrf attacks", "em2Text": "sql injection", "label": "None"}, {"em1Text": "sql injection", "em2Text": "csrf attacks", "label": "None"}], "entityMentions": [{"start": 34, "text": "csrf attacks", "label": "ATTACK"}, {"start": 99, "text": "sql injection", "label": "ATTACK"}], "sentText": "and i know laravel is secured for csrf attacks. is there any thing that should i know ? what about sql injection. is laravel secure or not? <h3>the short answer</h3>laravel 5.1 is well secured what regards to sql injection, csrf and xss per default.<h3>more details</h3>in my opinion, what you should be aware of:1- it is not only laravel alone that is responsible for your web application security, but the environment surrounding it.<br />\u807d\u807d\u807d - web server should be configured correctly and secure.<br />\u807d\u807d\u807d - it is an advantage to ssl (certificate) among your domain.<br />\u807d\u807d\u807d - do only use sftp over ssh for file transfer and do only use ssh for console connection.<br />\u807d\u807d\u807d - use trusted provider and physically secured server environment.<br />\u807d\u807d\u807d - backup your files and your database regularly and move the data out side your provider server location.<br />\u807d\u807d\u807d - make different username and password for ssh console, database or other services.<br />\u807d\u807d\u807d - for ssh access and database access, do not use admin or root username often, keep it only for emergency use, in stead create a sub admin/root account and use that in stead.2- above all of that, when you further develop on your laravel, you might risk performing bad programming which breaks the default security rules of laravel.<h3>conclusion</h3>therefore, it is suggested not counting on default security. you need to do your own penetration test when your project is done to ensure every thing is working and secured as planned. and follow some of the simple security rules then you would perfectly be on the safe side.i suggest you to look at this link regarding [link] and as @imtiazpabel comments [link].finally this link is good to check:[link][link][link] "}, {"sentId": 45, "articleId": "2", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 8, "text": "heap overflow attacks", "label": "ATTACK"}], "sentText": "how are heap overflow attacks executed?in the case of stack overflow attacks, the attacker replaces the function return address with his address of choice.how is this done in the case of a heap overflow attack? also, is it possible to run code from the heap? this article has a nice overview on heap overflow attacks:[link] "}, {"sentId": 2, "articleId": "1", "threatType": "D", "relationMentions": [{"em1Text": "another process can dump memory", "em2Text": "no way you can get rid of the data", "label": "PARENT"}, {"em1Text": "no way you can get rid of the data", "em2Text": "another process can dump memory", "label": "None"}], "entityMentions": [{"start": 69, "text": "another process can dump memory", "label": "ATTACK"}, {"start": 110, "text": "no way you can get rid of the data", "label": "ATTACK"}], "sentText": "strings are immutable. that means once you've created the [code], if another process can dump memory, there's no way you can get rid of the data before [link] kicks in. "}, {"sentId": 93, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "listbucket", "em2Text": "list the keys in a bucket", "label": "None"}, {"em1Text": "list the keys in a bucket", "em2Text": "listbucket", "label": "PARENT"}], "entityMentions": [{"start": 142, "text": "listbucket", "label": "ATTACK"}, {"start": 243, "text": "list the keys in a bucket", "label": "ATTACK"}], "sentText": "i am using getobject and putobject requests on amazon s3 and in creating a policy for access to the bucket i discovered that if i don't allow listbucket i get an 'access denied' error. the problem with this is that listbucket means a user can list the keys in a bucket and this presentsa security threat. is it possible to allow getobject and putobject without allowing listbucket?or is there a workaround for this? "}, {"sentId": 85, "articleId": "2", "threatType": "D", "relationMentions": [{"em1Text": "whips up an ackermann function and a script", "em2Text": "submit it a couple of thousand times to your server.", "label": "None"}, {"em1Text": "submit it a couple of thousand times to your server.", "em2Text": "whips up an ackermann function and a script", "label": "PARENT"}], "entityMentions": [{"start": 84, "text": "whips up an ackermann function and a script", "label": "ATTACK"}, {"start": 131, "text": "submit it a couple of thousand times to your server.", "label": "ATTACK"}], "sentText": "another thing you need to be aware of is denial-of-service attacks. imagine someone whips up an ackermann function and a script to submit it a couple of thousand times to your server... to prevent this, you should timebox the execution time of any code being submitted. this is essential, because this type of \"attack\" often happens unintentionally - someone managed to produce an infinite loop. "}, {"sentId": 61, "articleId": "1", "threatType": "I", "relationMentions": [{"em1Text": "someone will compromise the shared secret on the client", "em2Text": "post it on the internet", "label": "PARENT"}, {"em1Text": "post it on the internet", "em2Text": "someone will compromise the shared secret on the client", "label": "None"}], "entityMentions": [{"start": 52, "text": "someone will compromise the shared secret on the client", "label": "ATTACK"}, {"start": 154, "text": "post it on the internet", "label": "ATTACK"}], "sentText": "i am warned that should the app become popular that someone will compromise the shared secret on the client. just because they can and they will probably post it on the internet. so really it all comes down to the server side. unfortunately, i have no way to identify and block an attacker. this i would dearly love.  "}, {"sentId": 10, "articleId": "6", "threatType": "E", "relationMentions": [], "entityMentions": [{"start": 31, "text": "hacker can find the way to change some of my [code] statements", "label": "ATTACK"}], "sentText": "but what about security? meybe hacker can find the way to change some of my [code] statements, and whole my securite will brake. "}, {"sentId": 55, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "dos attacks", "em2Text": "rapid-fire login attempts", "label": "PARENT"}, {"em1Text": "dos attacks", "em2Text": "the attack can span multiple ips and user accounts for the sake of bypassing your throttling attempts", "label": "None"}, {"em1Text": "rapid-fire login attempts", "em2Text": "dos attacks", "label": "None"}, {"em1Text": "rapid-fire login attempts", "em2Text": "the attack can span multiple ips and user accounts for the sake of bypassing your throttling attempts", "label": "PARENT"}, {"em1Text": "the attack can span multiple ips and user accounts for the sake of bypassing your throttling attempts", "em2Text": "dos attacks", "label": "None"}, {"em1Text": "the attack can span multiple ips and user accounts for the sake of bypassing your throttling attempts", "em2Text": "rapid-fire login attempts", "label": "None"}], "entityMentions": [{"start": 105, "text": "dos attacks", "label": "ATTACK"}, {"start": 50, "text": "rapid-fire login attempts", "label": "ATTACK"}, {"start": 261, "text": "the attack can span multiple ips and user accounts for the sake of bypassing your throttling attempts", "label": "ATTACK"}], "sentText": "i was just reading this post [link] on preventing rapid-fire login attempts.   you cannot simply prevent dos attacks by chaining throttling down to a single ip or username.  you can't even really prevent rapid-fire login attempts using this method.why? because the attack can span multiple ips and user accounts for the sake of bypassing your throttling attempts.i have seen posted elsewhere that ideally you should be tracking all failed login attempts across the site and associating them to a timestamp, perhaps:[code]a quick note on the ip_address field: you can store the data and retrieve the data, respectively, with inet_aton() and inet_ntoa() which essentially equate to converting an ip address to and from an unsigned integer.[code]decide on certain delay thresholds based on the overall number of failed logins in a given amount of time (15 minutes in this example).   "}, {"sentId": 9, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "generates a random number between 0-1000", "em2Text": "their md5 hashes are known", "label": "AND"}, {"em1Text": "generates a random number between 0-1000", "em2Text": "verify the account without it really belonging to them", "label": "None"}, {"em1Text": "their md5 hashes are known", "em2Text": "generates a random number between 0-1000", "label": "None"}, {"em1Text": "their md5 hashes are known", "em2Text": "verify the account without it really belonging to them", "label": "None"}, {"em1Text": "verify the account without it really belonging to them", "em2Text": "generates a random number between 0-1000", "label": "None"}, {"em1Text": "verify the account without it really belonging to them", "em2Text": "their md5 hashes are known", "label": "PARENT"}], "entityMentions": [{"start": 43, "text": "generates a random number between 0-1000", "label": "ATTACK"}, {"start": 124, "text": "their md5 hashes are known", "label": "ATTACK"}, {"start": 201, "text": "verify the account without it really belonging to them", "label": "ATTACK"}], "sentText": "is using the method below a bad choice? it generates a random number between 0-1000. since there are only 1000 options, and their md5 hashes are known, it should take an attacker just a 1000 trials to verify the account without it really belonging to them "}, {"sentId": 81, "articleId": "2", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 43, "text": "the possibility that someone has already precomputed a dictionary/brute force attack for your password hashes", "label": "ATTACK"}], "sentText": "the whole point of using salts is to avoid the possibility that someone has already precomputed a dictionary/brute force attack for your password hashes . thus, it only needs to be long enough to exclude the possibility that such a table already exists for a specific salt. "}, {"sentId": 134, "articleId": "4", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 4, "text": "sandbox would be executing scripts that could be potentially dangerous", "label": "ATTACK"}], "sentText": "the sandbox would be executing scripts that could be potentially dangerous.  the sandbox would be a mix of my own javascript, running alongside untrusted javascript code from other sources. "}, {"sentId": 50, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "attacker can change the value", "em2Text": "generate his/her own sha-1 hash", "label": "AND"}, {"em1Text": "attacker can change the value", "em2Text": "add the random string", "label": "None"}, {"em1Text": "attacker can change the value", "em2Text": "the attacker can build up a list of hash values that correspond to the hidden value", "label": "None"}, {"em1Text": "generate his/her own sha-1 hash", "em2Text": "attacker can change the value", "label": "None"}, {"em1Text": "generate his/her own sha-1 hash", "em2Text": "add the random string", "label": "AND"}, {"em1Text": "generate his/her own sha-1 hash", "em2Text": "the attacker can build up a list of hash values that correspond to the hidden value", "label": "None"}, {"em1Text": "add the random string", "em2Text": "attacker can change the value", "label": "None"}, {"em1Text": "add the random string", "em2Text": "generate his/her own sha-1 hash", "label": "None"}, {"em1Text": "add the random string", "em2Text": "the attacker can build up a list of hash values that correspond to the hidden value", "label": "None"}, {"em1Text": "the attacker can build up a list of hash values that correspond to the hidden value", "em2Text": "attacker can change the value", "label": "None"}, {"em1Text": "the attacker can build up a list of hash values that correspond to the hidden value", "em2Text": "generate his/her own sha-1 hash", "label": "None"}, {"em1Text": "the attacker can build up a list of hash values that correspond to the hidden value", "em2Text": "add the random string", "label": "None"}], "entityMentions": [{"start": 84, "text": "attacker can change the value", "label": "ATTACK"}, {"start": 118, "text": "generate his/her own sha-1 hash", "label": "ATTACK"}, {"start": 154, "text": "add the random string", "label": "ATTACK"}, {"start": 530, "text": "the attacker can build up a list of hash values that correspond to the hidden value", "label": "ATTACK"}], "sentText": "it would be better to store the hash on the server-side. it is conceivable that the attacker can change the value and generate his/her own sha-1 hash and add the random string (they can easily figure this out from accessing the page repeatedly). if the hash is on the server-side (maybe in some sort of cache), you can recalculate the hash and check it to make sure that the value wasn't tampered with in any way. i read the question wrong regarding the random string (constant salt). but i guess the original point still stands. the attacker can build up a list of hash values that correspond to the hidden value. "}, {"sentId": 85, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "parse the json return value with eval", "em2Text": "[code] can run any javascript", "label": "None"}, {"em1Text": "[code] can run any javascript", "em2Text": "parse the json return value with eval", "label": "PARENT"}], "entityMentions": [{"start": 180, "text": "parse the json return value with eval", "label": "ATTACK"}, {"start": 619, "text": "[code] can run any javascript", "label": "ATTACK"}], "sentText": "question: i'm using eval to parse a json return value from one of my webmethods.<br /><br />i prefer not to add jquery-json because the transfer volume is already quite large.so i parse the json return value with eval.<br />now rumors go that this is insecure. why ? <br />nobody can modify the json return value unless they hack my server, in which case i would have a much larger problem anyway.<br />and if they do it locally, javascript only executes in their browser.so i fail to see where the problem is. <br /><br />can anybody shed some light on this, using this concrete example? the fundamental issue is that [code] can run any javascript, not just deserialize json-formatted data. that's the risk when using it to process json from an untrusted or semi-trusted source. the frequent trick of wrapping the json in parentheses is not sufficient to ensure that arbitrary javascript isn't executed. consider this \"json\" which really isn't: "}, {"sentId": 88, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "hacker get an access", "em2Text": "stole the user's cookie", "label": "None"}, {"em1Text": "stole the user's cookie", "em2Text": "hacker get an access", "label": "PARENT"}], "entityMentions": [{"start": 26, "text": "hacker get an access", "label": "ATTACK"}, {"start": 57, "text": "stole the user's cookie", "label": "ATTACK"}], "sentText": "solutions (how to prevent hacker get an access if he/she stole the user's cookie): "}, {"sentId": 132, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 169, "text": "cross site scripting attacks", "label": "ATTACK"}], "sentText": "however once glimpse is registered in web.config \"modules\" section, the request validation doesn't happen (even when glimpse is turned off), leaving the website open to cross site scripting attacks (xss).  "}, {"sentId": 20, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "sql injection attack", "em2Text": "your parameterized query passes a username to a stored procedure", "label": "PARENT"}, {"em1Text": "sql injection attack", "em2Text": "within the stored procedure the parameter is concatenated to a sql command", "label": "None"}, {"em1Text": "your parameterized query passes a username to a stored procedure", "em2Text": "sql injection attack", "label": "None"}, {"em1Text": "your parameterized query passes a username to a stored procedure", "em2Text": "within the stored procedure the parameter is concatenated to a sql command", "label": "AND"}, {"em1Text": "within the stored procedure the parameter is concatenated to a sql command", "em2Text": "sql injection attack", "label": "None"}, {"em1Text": "within the stored procedure the parameter is concatenated to a sql command", "em2Text": "your parameterized query passes a username to a stored procedure", "label": "None"}], "entityMentions": [{"start": 24, "text": "sql injection attack", "label": "ATTACK"}, {"start": 222, "text": "your parameterized query passes a username to a stored procedure", "label": "ATTACK"}, {"start": 292, "text": "within the stored procedure the parameter is concatenated to a sql command", "label": "ATTACK"}], "sentText": "no, you can't avoid all sql injection attacks by using parameters. dynamic sql is the real issue, and this can occur in stored procedures as well as in your application code. e.g., this is prone to a sql injection attack: your parameterized query passes a username to a stored procedure, and within the stored procedure the parameter is concatenated to a sql command and then executed. for an example of many kinds of sql injection attacks, see this [link]. you will see that simply escaping single quotes is just scratching the surface, and that there are many ways around that. "}, {"sentId": 41, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "database where compromised", "em2Text": "going to defeat [code] by enabling the [link]", "label": "None"}, {"em1Text": "going to defeat [code] by enabling the [link]", "em2Text": "database where compromised", "label": "PARENT"}], "entityMentions": [{"start": 11, "text": "database where compromised", "label": "ATTACK"}, {"start": 54, "text": "going to defeat [code] by enabling the [link]", "label": "ATTACK"}], "sentText": "but if the database where compromised the attacker is going to defeat [code] by enabling the [link]. "}, {"sentId": 86, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "reverse engineer these from my binary", "em2Text": "use them in their app", "label": "None"}, {"em1Text": "reverse engineer these from my binary", "em2Text": "reverse engineer my server's endpoint that i use to send text messages", "label": "None"}, {"em1Text": "use them in their app", "em2Text": "reverse engineer these from my binary", "label": "PARENT"}, {"em1Text": "use them in their app", "em2Text": "reverse engineer my server's endpoint that i use to send text messages", "label": "None"}, {"em1Text": "reverse engineer my server's endpoint that i use to send text messages", "em2Text": "reverse engineer these from my binary", "label": "None"}, {"em1Text": "reverse engineer my server's endpoint that i use to send text messages", "em2Text": "use them in their app", "label": "None"}], "entityMentions": [{"start": 158, "text": "reverse engineer these from my binary", "label": "ATTACK"}, {"start": 200, "text": "use them in their app", "label": "ATTACK"}, {"start": 300, "text": "reverse engineer my server's endpoint that i use to send text messages", "label": "ATTACK"}], "sentText": "after reading a little bit it seems like a bad idea to store the private keys for whatever 3rd party i'll use in the app (twilio, nexmo, etc). somebody could reverse engineer these from my binary and use them in their app. however, having these on the server doesn't help either, somebody could just reverse engineer my server's endpoint that i use to send text messages and use that instead. "}, {"sentId": 26, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "do serious damage to the server", "em2Text": "deleting the database", "label": "PARENT"}, {"em1Text": "do serious damage to the server", "em2Text": "messing with the application code", "label": "None"}, {"em1Text": "do serious damage to the server", "em2Text": "has root access to your data and server", "label": "None"}, {"em1Text": "deleting the database", "em2Text": "do serious damage to the server", "label": "None"}, {"em1Text": "deleting the database", "em2Text": "messing with the application code", "label": "OR"}, {"em1Text": "deleting the database", "em2Text": "has root access to your data and server", "label": "PARENT"}, {"em1Text": "messing with the application code", "em2Text": "do serious damage to the server", "label": "None"}, {"em1Text": "messing with the application code", "em2Text": "deleting the database", "label": "None"}, {"em1Text": "messing with the application code", "em2Text": "has root access to your data and server", "label": "None"}, {"em1Text": "has root access to your data and server", "em2Text": "do serious damage to the server", "label": "None"}, {"em1Text": "has root access to your data and server", "em2Text": "deleting the database", "label": "None"}, {"em1Text": "has root access to your data and server", "em2Text": "messing with the application code", "label": "None"}], "entityMentions": [{"start": 590, "text": "do serious damage to the server", "label": "ATTACK"}, {"start": 633, "text": "deleting the database", "label": "ATTACK"}, {"start": 659, "text": "messing with the application code", "label": "ATTACK"}, {"start": 1174, "text": "has root access to your data and server", "label": "ATTACK"}], "sentText": "listening to scott hanselman's interview with the stack overflow team ([link] and [link]), he was adamant that the sql server and application server should be on separate machines.  is this just to make sure that if one server is compromised, both systems aren't accessible?  do the security concerns outweigh the complexity of two servers (extra cost, dedicated network connection between the two, more maintenance, etc.), especially for a small application, where neither piece is using too much cpu or memory?  even with two servers, with one server compromised, an attacker could still do serious damage to the server, either by deleting the database, or messing with the application code.   security. your web server lives in a dmz, accessible to the public internet and taking untrusted input from anonymous users. if your web server gets compromised, and you've followed least privilege rules in connecting to your db, the maximum exposure is what your app can do through the database api. if you have a business tier in between, you have one more step between your attacker and your data. if, on the other hand, your database is on the same server, the attacker now has root access to your data and server.scalability. keeping your web server stateless allows you to scale your web servers horizontally pretty much effortlessly. it is very difficult to horizontally scale a database server.performance. 2 boxes = 2 times the cpu, 2 times the ram, and 2 times the spindles for disk access.  "}, {"sentId": 79, "articleId": "2", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 104, "text": "upload a php script with for example jpeg mime type", "label": "ATTACK"}], "sentText": "checking for mime type in php is pretty easy but as far as i know mime can be spoofed. the attacker can upload a php script with for example jpeg mime type. one thing that comes to mind is to check the file extension of the uploaded file and make sure it matches the mime type. all of this is assuming the upload directory is browser accessible. "}, {"sentId": 7, "articleId": "3", "threatType": "I", "relationMentions": [{"em1Text": "brute force attack", "em2Text": "guesses the input values", "label": "PARENT"}, {"em1Text": "brute force attack", "em2Text": "get the $userinput information correct", "label": "None"}, {"em1Text": "brute force attack", "em2Text": "get in", "label": "None"}, {"em1Text": "guesses the input values", "em2Text": "brute force attack", "label": "None"}, {"em1Text": "guesses the input values", "em2Text": "get the $userinput information correct", "label": "None"}, {"em1Text": "guesses the input values", "em2Text": "get in", "label": "None"}, {"em1Text": "get the $userinput information correct", "em2Text": "brute force attack", "label": "None"}, {"em1Text": "get the $userinput information correct", "em2Text": "guesses the input values", "label": "None"}, {"em1Text": "get the $userinput information correct", "em2Text": "get in", "label": "None"}, {"em1Text": "get in", "em2Text": "brute force attack", "label": "None"}, {"em1Text": "get in", "em2Text": "guesses the input values", "label": "None"}, {"em1Text": "get in", "em2Text": "get the $userinput information correct", "label": "PARENT"}], "entityMentions": [{"start": 47, "text": "brute force attack", "label": "ATTACK"}, {"start": 70, "text": "guesses the input values", "label": "ATTACK"}, {"start": 177, "text": "get the $userinput information correct", "label": "ATTACK"}, {"start": 219, "text": "get in", "label": "ATTACK"}], "sentText": "that's how it works right? but iv'e read about brute force attack. it guesses the input values right? with the procedure above. doesn't it shows that the attacker only needs to get the $userinput information correct to get in? he doesn't need to guess the long $encrypted string correct? "}, {"sentId": 49, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "use query string [code]", "em2Text": "injected code show the alert", "label": "None"}, {"em1Text": "use query string [code]", "em2Text": "[code]", "label": "OR"}, {"em1Text": "use query string [code]", "em2Text": "[code]", "label": "None"}, {"em1Text": "injected code show the alert", "em2Text": "use query string [code]", "label": "PARENT"}, {"em1Text": "injected code show the alert", "em2Text": "[code]", "label": "None"}, {"em1Text": "injected code show the alert", "em2Text": "[code]", "label": "None"}, {"em1Text": "[code]", "em2Text": "use query string [code]", "label": "None"}, {"em1Text": "[code]", "em2Text": "injected code show the alert", "label": "None"}, {"em1Text": "[code]", "em2Text": "[code]", "label": "OR"}, {"em1Text": "[code]", "em2Text": "use query string [code]", "label": "None"}, {"em1Text": "[code]", "em2Text": "injected code show the alert", "label": "None"}, {"em1Text": "[code]", "em2Text": "[code]", "label": "None"}], "entityMentions": [{"start": 676, "text": "use query string [code]", "label": "ATTACK"}, {"start": 731, "text": "injected code show the alert", "label": "ATTACK"}, {"start": 0, "text": "[code]", "label": "ATTACK"}, {"start": 0, "text": "[code]", "label": "ATTACK"}], "sentText": "[code] [code] because angle brackets [code] are [link] they seem to get automatically encoded by the browser on the way in, before they can get anywhere near the js runtime. this leads me to believe that simply rendering the querystring directly on the client using [code] is always safe, and not a possible xss vector. (i realize that there are many other ways in which an app can be vulnerable of course, but let's stick to the precise case described here.) not relevant to the question, but an interesting aside. if i decode the uri first then browser behavior is different: [code]. the [link] in both chrome and safari blocks the page, while firefox shows the alert. if i use query string [code] on ie6 on windows xp i get the injected code show the alert, this happens also using [code] or [code] in the page, so i would say your second assumption is right if [link] is still a reasonable browser: it is a feature of modern browsers "}, {"sentId": 73, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "a wordpress page i manage started redirecting to ad/malware pages", "em2Text": "the snippet was embedded in wp_options in an entry with the key 'yuzo_related_post_options'", "label": "PARENT"}, {"em1Text": "a wordpress page i manage started redirecting to ad/malware pages", "em2Text": "embedded in the json option 'yuzo_related_post_css_and_style' of the option_value", "label": "None"}, {"em1Text": "the snippet was embedded in wp_options in an entry with the key 'yuzo_related_post_options'", "em2Text": "a wordpress page i manage started redirecting to ad/malware pages", "label": "None"}, {"em1Text": "the snippet was embedded in wp_options in an entry with the key 'yuzo_related_post_options'", "em2Text": "embedded in the json option 'yuzo_related_post_css_and_style' of the option_value", "label": "AND"}, {"em1Text": "embedded in the json option 'yuzo_related_post_css_and_style' of the option_value", "em2Text": "a wordpress page i manage started redirecting to ad/malware pages", "label": "None"}, {"em1Text": "embedded in the json option 'yuzo_related_post_css_and_style' of the option_value", "em2Text": "the snippet was embedded in wp_options in an entry with the key 'yuzo_related_post_options'", "label": "None"}], "entityMentions": [{"start": 18, "text": "a wordpress page i manage started redirecting to ad/malware pages", "label": "ATTACK"}, {"start": 85, "text": "the snippet was embedded in wp_options in an entry with the key 'yuzo_related_post_options'", "label": "ATTACK"}, {"start": 197, "text": "embedded in the json option 'yuzo_related_post_css_and_style' of the option_value", "label": "ATTACK"}], "sentText": "about an hour ago a wordpress page i manage started redirecting to ad/malware pages. the snippet was embedded in wp_options in an entry with the key 'yuzo_related_post_options' - more specifically embedded in the json option 'yuzo_related_post_css_and_style' of the option_value. that option gets echoed without sanitizing. "}, {"sentId": 23, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "got access to your hashed passwords (and is trying to reverse the hash to plain text)", "em2Text": "dumped your database", "label": "None"}, {"em1Text": "got access to your hashed passwords (and is trying to reverse the hash to plain text)", "em2Text": "got access to your random salts", "label": "None"}, {"em1Text": "dumped your database", "em2Text": "got access to your hashed passwords (and is trying to reverse the hash to plain text)", "label": "PARENT"}, {"em1Text": "dumped your database", "em2Text": "got access to your random salts", "label": "None"}, {"em1Text": "got access to your random salts", "em2Text": "got access to your hashed passwords (and is trying to reverse the hash to plain text)", "label": "None"}, {"em1Text": "got access to your random salts", "em2Text": "dumped your database", "label": "PARENT"}], "entityMentions": [{"start": 85, "text": "got access to your hashed passwords (and is trying to reverse the hash to plain text)", "label": "ATTACK"}, {"start": 193, "text": "dumped your database", "label": "ATTACK"}, {"start": 220, "text": "got access to your random salts", "label": "ATTACK"}], "sentText": "you need to store the random salt along with your hashgiven that an attacker somehow got access to your hashed passwords (and is trying to reverse the hash to plain text), it means he probably dumped your database, then got access to your random salts also "}, {"sentId": 58, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "sees in his dictionary that [code]", "em2Text": "easily find out the password", "label": "None"}, {"em1Text": "sees in his dictionary that [code]", "em2Text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "label": "None"}, {"em1Text": "sees in his dictionary that [code]", "em2Text": "sql injection", "label": "None"}, {"em1Text": "easily find out the password", "em2Text": "sees in his dictionary that [code]", "label": "None"}, {"em1Text": "easily find out the password", "em2Text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "label": "PARENT"}, {"em1Text": "easily find out the password", "em2Text": "sql injection", "label": "None"}, {"em1Text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "em2Text": "sees in his dictionary that [code]", "label": "AND"}, {"em1Text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "em2Text": "easily find out the password", "label": "None"}, {"em1Text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "em2Text": "sql injection", "label": "None"}, {"em1Text": "sql injection", "em2Text": "sees in his dictionary that [code]", "label": "None"}, {"em1Text": "sql injection", "em2Text": "easily find out the password", "label": "PARENT"}, {"em1Text": "sql injection", "em2Text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "label": "None"}], "entityMentions": [{"start": 188, "text": "sees in his dictionary that [code]", "label": "ATTACK"}, {"start": 141, "text": "easily find out the password", "label": "ATTACK"}, {"start": 0, "text": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service", "label": "ATTACK"}, {"start": 267, "text": "sql injection", "label": "ATTACK"}], "sentText": "using a dictionary (a list of common words and password) or one of the various sites that offer you that service, the attacker (mallory) can easily find out the password is secret when he sees in his dictionary that [code]. if an attacker gets in your database using sql injection, at least the hashes he/she retrieves won't be useful since he/she won't have access to your application configuration. if your server gets rooted, it's pretty much game-over no matter what you do. "}, {"sentId": 42, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "user b steals user a's sid", "em2Text": "creates a cookie on his computer", "label": "AND"}, {"em1Text": "user b steals user a's sid", "em2Text": "hijacked user a's session", "label": "None"}, {"em1Text": "creates a cookie on his computer", "em2Text": "user b steals user a's sid", "label": "None"}, {"em1Text": "creates a cookie on his computer", "em2Text": "hijacked user a's session", "label": "None"}, {"em1Text": "hijacked user a's session", "em2Text": "user b steals user a's sid", "label": "PARENT"}, {"em1Text": "hijacked user a's session", "em2Text": "creates a cookie on his computer", "label": "None"}], "entityMentions": [{"start": 403, "text": "user b steals user a's sid", "label": "ATTACK"}, {"start": 435, "text": "creates a cookie on his computer", "label": "ATTACK"}, {"start": 520, "text": "hijacked user a's session", "label": "ATTACK"}], "sentText": "after user a logs in on example.com, he is given some random session id, for simplicity's sake, let it be 'abc123'. this session id is stored as a cookie on the client side and is validated with a server-side session to ensure the user who logged in remains logged in as he moves from one webpage to another. this cookie of course would not need to exist if http were not stateless. for that reason, if user b steals user a's sid, and creates a cookie on his computer with the value 'abc123', he would have successfully hijacked user a's session, but there is simply no way for the server to legitimately recognize that user b's request is any different from user a's requests, and therefore the server has no reason to reject any request. even if we were to list the sessions that were already active on the server and try to see if someone is accessing a session that is already active, how can we determine that it is another user who is accessing the session illegitimately and not the same user who is already logged in with a session id, but simply trying to make another request with it (ie navigate to a different webpage). we can't. checking the user agent? can be spoofed - but good as a defense in depth measure nevertheless. ip address? can change for legitimate reasons - but instead of not checking for the ip address at all, i suggest checking something like the first two octets of the ip, as even a user on a data plan network who constantly has a changing ip for perfectly legitimate reasons would only usually have the last two octets of their ip change. "}, {"sentId": 43, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "sql injection", "em2Text": "[code]", "label": "PARENT"}, {"em1Text": "[code]", "em2Text": "sql injection", "label": "None"}], "entityMentions": [{"start": 74, "text": "sql injection", "label": "ATTACK"}, {"start": 166, "text": "[code]", "label": "ATTACK"}], "sentText": "as the title suggests, i would like to know if this code is vulnerable to sql injection? and if so, is there a better, more secure, way of achieving the same thing?  [code] [code] essentially, you want to put the parameters in the cursor command, because it will make sure to make the data database safe. with your first command, it would be relatively easy to make a special [code] or [code] that put something into your sql code that wasn't safe. see the [link], and the referenced [link] . specifically, the python pages quote:   usually your sql operations will need to use values from python  variables. you shouldn\u9225\u6a9b assemble your query using python\u9225\u6a9a string  operations because doing so is insecure; it makes your program  vulnerable to an sql injection attack (see [link] for  humorous example of what can go wrong).    instead, use the db-api\u9225\u6a9a parameter substitution. put ? as a  placeholder wherever you want to use a value, and then provide a tuple  of values as the second argument to the cursor\u9225\u6a9a execute() method.  (other database modules may use a different placeholder, such as %s or  :1.) [code] "}, {"sentId": 57, "articleId": "6", "threatType": "E", "relationMentions": [{"em1Text": "sending his/her updated collection of the most malicious viruses in existance to the server/other clients", "em2Text": "compromise the user-experience for other players by, for example, hacking", "label": "OR"}, {"em1Text": "compromise the user-experience for other players by, for example, hacking", "em2Text": "sending his/her updated collection of the most malicious viruses in existance to the server/other clients", "label": "None"}], "entityMentions": [{"start": 282, "text": "sending his/her updated collection of the most malicious viruses in existance to the server/other clients", "label": "ATTACK"}, {"start": 402, "text": "compromise the user-experience for other players by, for example, hacking", "label": "ATTACK"}], "sentText": "pointers and insight on security measures that i should take into consideration when developing software, mainly games, such as the one described below. by security i mean checking and double checking that a user doesn't act in a way not intended. this could mean behaviour such as sending his/her updated collection of the most malicious viruses in existance to the server/other clients, or otherwise compromise the user-experience for other players by, for example, hacking. "}, {"sentId": 69, "articleId": "6", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 8, "text": "someone be able to simply change the referrer header to a malicious website", "label": "ATTACK"}], "sentText": "wouldnt someone be able to simply change the referrer header to a malicious website? does rails have any sort of prevention measures for this? "}, {"sentId": 13, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "a bad guy to get a core dump", "em2Text": "somehow otherwise observe the heap", "label": "OR"}, {"em1Text": "somehow otherwise observe the heap", "em2Text": "a bad guy to get a core dump", "label": "None"}], "entityMentions": [{"start": 280, "text": "a bad guy to get a core dump", "label": "ATTACK"}, {"start": 312, "text": "somehow otherwise observe the heap", "label": "ATTACK"}], "sentText": "my concern is that we should never store a user password in a java.lang.string because they're immutable.  i can't zero out that string as soon as i'm done authenticating.  that object will sit in memory until the garbage collector runs.  that leaves open a much wider window for a bad guy to get a core dump or somehow otherwise observe the heap. "}, {"sentId": 75, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "compromises the repository", "em2Text": "replace the artifact", "label": "AND"}, {"em1Text": "compromises the repository", "em2Text": "replace the hashes", "label": "None"}, {"em1Text": "replace the artifact", "em2Text": "compromises the repository", "label": "None"}, {"em1Text": "replace the artifact", "em2Text": "replace the hashes", "label": "None"}, {"em1Text": "replace the hashes", "em2Text": "compromises the repository", "label": "None"}, {"em1Text": "replace the hashes", "em2Text": "replace the artifact", "label": "PARENT"}], "entityMentions": [{"start": 324, "text": "compromises the repository", "label": "ATTACK"}, {"start": 359, "text": "replace the artifact", "label": "ATTACK"}, {"start": 389, "text": "replace the hashes", "label": "ATTACK"}], "sentText": "i was just pointed to a very interesting [link] ([link]) about a security problem calledcross build injection (xbi). to be clear: i am not talking about simply providing md5 or sha1 hashes for the artifacts. that is already done, but those hashes are stored in the same location as the artifacts. so once a malicious hacker compromises the repository and can replace the artifact they can replace the hashes as well.so what is acutally needed is some kind of pki, that allows the developers to sign their artifacts and maven to verify these signatures. since the signature is done using the private key of the developer it cannot be tampered with when only the repository is compromised.does anyone know the state of this in maven? "}, {"sentId": 70, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "images only some people are allowed to see", "em2Text": "putting them into a publicly accessible directory", "label": "AND"}, {"em1Text": "images only some people are allowed to see", "em2Text": "there is a change other people can see that image", "label": "None"}, {"em1Text": "putting them into a publicly accessible directory", "em2Text": "images only some people are allowed to see", "label": "None"}, {"em1Text": "putting them into a publicly accessible directory", "em2Text": "there is a change other people can see that image", "label": "None"}, {"em1Text": "there is a change other people can see that image", "em2Text": "images only some people are allowed to see", "label": "None"}, {"em1Text": "there is a change other people can see that image", "em2Text": "putting them into a publicly accessible directory", "label": "PARENT"}], "entityMentions": [{"start": 26, "text": "images only some people are allowed to see", "label": "ATTACK"}, {"start": 81, "text": "putting them into a publicly accessible directory", "label": "ATTACK"}, {"start": 132, "text": "there is a change other people can see that image", "label": "ATTACK"}], "sentText": "sort of. yes, if you have images only some people are allowed to see, and you're putting them into a publicly accessible directory, there is a change other people can see that image, which appears to be undesirable. i also don't think (might be wrong) that it will gain 10 seconds on a page load, as you'll have to copy the images, which is a rather intensive operation, more than using file_get_contents or readfile( ). "}, {"sentId": 150, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "crlf injection", "em2Text": "header response splitting vulnerability", "label": "PARENT"}, {"em1Text": "header response splitting vulnerability", "em2Text": "crlf injection", "label": "None"}], "entityMentions": [{"start": 46, "text": "crlf injection", "label": "ATTACK"}, {"start": 88, "text": "header response splitting vulnerability", "label": "ATTACK"}], "sentText": "in old versions of php you had to worry about crlf injection which is \\r\\n.  this is a \"header response splitting vulnerability.\"  if you strip out these characters then you shouldn't have to worry.   in the latest build of of php the header() function is safe,  and will automatically take care of \\r\\n for you.  "}, {"sentId": 124, "articleId": "4", "threatType": "E", "relationMentions": [], "entityMentions": [{"start": 211, "text": "submit their own code to the cluster without any restrictions", "label": "ATTACK"}], "sentText": "i have a standalone spark cluster running on a remote server and i'm new to spark. it appears that there's no authentication scheme protecting the cluster master's (7077) port by default. anyone can just simply submit their own code to the cluster without any restrictions. "}, {"sentId": 91, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "manipulate the amf parameters", "em2Text": "insert javascript", "label": "None"}, {"em1Text": "insert javascript", "em2Text": "manipulate the amf parameters", "label": "PARENT"}], "entityMentions": [{"start": 260, "text": "manipulate the amf parameters", "label": "ATTACK"}, {"start": 294, "text": "insert javascript", "label": "ATTACK"}], "sentText": "i just got hammered on a security audit by deloitte on behalf of sfdc. basically we use flex and communicate via amf. we use fluorinefx for this (as opposed to lcds and blaze). we are being told that because the amf response is not encoded andthat someone can manipulate the amf parameters and insert javascript that this is a xss vulnerability. i'm struggling to understand how the amf response back, which could echo the passed in js in an error message, can be executed by the browser or anything else for that matter. i'm quite experienced with xss with html and js but seeing it get tagged with amf was a bit of a surprise. i'm in touch with fluorinefx team and they are perplexed as well. "}, {"sentId": 90, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 40, "text": "a determined hacker with access to my source code", "label": "ATTACK"}], "sentText": "i understand that i probably won't stop a determined hacker with access to my source code, but storing them as plaintext feels wrong. "}, {"sentId": 130, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "set this property to an arbitrary value", "em2Text": "spoof this user name", "label": "PARENT"}, {"em1Text": "spoof this user name", "em2Text": "set this property to an arbitrary value", "label": "None"}], "entityMentions": [{"start": 64, "text": "set this property to an arbitrary value", "label": "ATTACK"}, {"start": 211, "text": "spoof this user name", "label": "ATTACK"}], "sentText": "but how secure is that? can a user executing the program easily set this property to an arbitrary value (using a command-line argument of the jvm, for example) for common runtime environments? can a user easily spoof this user name? "}, {"sentId": 70, "articleId": "6", "threatType": "E", "relationMentions": [{"em1Text": "a hacker could manipulate the token on the device", "em2Text": "this can be mined by a hacker", "label": "None"}, {"em1Text": "a hacker could manipulate the token on the device", "em2Text": "make the entire application vulnerable", "label": "None"}, {"em1Text": "this can be mined by a hacker", "em2Text": "a hacker could manipulate the token on the device", "label": "None"}, {"em1Text": "this can be mined by a hacker", "em2Text": "make the entire application vulnerable", "label": "None"}, {"em1Text": "make the entire application vulnerable", "em2Text": "a hacker could manipulate the token on the device", "label": "None"}, {"em1Text": "make the entire application vulnerable", "em2Text": "this can be mined by a hacker", "label": "PARENT"}], "entityMentions": [{"start": 259, "text": "a hacker could manipulate the token on the device", "label": "ATTACK"}, {"start": 428, "text": "this can be mined by a hacker", "label": "ATTACK"}, {"start": 463, "text": "make the entire application vulnerable", "label": "ATTACK"}], "sentText": "to give context why it is the way it is, the payload contains an expiration time and on the device when the token is about to expire i should prompt the user to re enter their credentials to get a new token. now this might seem like a security threat because a hacker could manipulate the token on the device, but the server checks the token to make sure it is authentic which is why i do not want the key on the device because this can be mined by a hacker, and make the entire application vulnerable. "}, {"sentId": 151, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "someone can simply figure out the url that my app uses", "em2Text": "pass their own url parameters", "label": "AND"}, {"em1Text": "someone can simply figure out the url that my app uses", "em2Text": "activating their accounts from outside the app", "label": "None"}, {"em1Text": "pass their own url parameters", "em2Text": "someone can simply figure out the url that my app uses", "label": "None"}, {"em1Text": "pass their own url parameters", "em2Text": "activating their accounts from outside the app", "label": "None"}, {"em1Text": "activating their accounts from outside the app", "em2Text": "someone can simply figure out the url that my app uses", "label": "None"}, {"em1Text": "activating their accounts from outside the app", "em2Text": "pass their own url parameters", "label": "None"}], "entityMentions": [{"start": 19, "text": "someone can simply figure out the url that my app uses", "label": "ATTACK"}, {"start": 78, "text": "pass their own url parameters", "label": "ATTACK"}, {"start": 468, "text": "activating their accounts from outside the app", "label": "ATTACK"}], "sentText": "my concern is that someone can simply figure out the url that my app uses and pass their own url parameters - and since the webapp has no idea whether legitimate data is being sent from my ios app vs. someone just typing in the properly crafted url from any web browser, the system will be vulnerable. of course, the user that the app uses to make database queries will have limited privileges, so the rest of the database won't be at risk. however, even having users activating their accounts from outside the app would be catastrophic. "}, {"sentId": 38, "articleId": "2", "threatType": "E", "relationMentions": [{"em1Text": "clear the whole database", "em2Text": "inserting a delete statement", "label": "PARENT"}, {"em1Text": "inserting a delete statement", "em2Text": "clear the whole database", "label": "None"}], "entityMentions": [{"start": 21, "text": "clear the whole database", "label": "ATTACK"}, {"start": 49, "text": "inserting a delete statement", "label": "ATTACK"}], "sentText": "i don't want them to clear the whole database by inserting a delete statement.my ideas would be: "}, {"sentId": 38, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 374, "text": "try every combination on the locally encrypted strong password very quickly", "label": "ATTACK"}], "sentText": "so i believe this achieves the strong server side password requirement. however i also need to protect as best i can against compromised client devices after the signup process (devices compromised before/during the signup process are a lost cause). obviously with a 4 digit encryption key, there are only 10,000 possible combinations, so an attacker will easily be able to try every combination on the locally encrypted strong password very quickly. what i want to know is do i have to choose a specific symmetric encryption scheme and/or generated password format so that the attacker will not be able to tell from local data alone which of the 10k decryption attempts was the correct one? i.e. he would still have to attempt each of the 10k passwords on the server-side login. "}, {"sentId": 4, "articleId": "3", "threatType": "I", "relationMentions": [{"em1Text": "steal the user's csrf token", "em2Text": "via js", "label": "PARENT"}, {"em1Text": "via js", "em2Text": "steal the user's csrf token", "label": "None"}], "entityMentions": [{"start": 30, "text": "steal the user's csrf token", "label": "ATTACK"}, {"start": 58, "text": "via js", "label": "ATTACK"}], "sentText": "what prevents the attacker to steal the user's csrf token via js? can't he just find the csrf element and get it's value with js? "}, {"sentId": 65, "articleId": "4", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 115, "text": "rainbow table attacks", "label": "ATTACK"}], "sentText": "however, if i understand the purpose of salt correctly, it is to reduce the chance that you will be compromised by rainbow table attacks. so, i understand that by storing it in the database it would be optimal to change it for each user, but what if the salt is nowhere near the database? if i store a single salt value in the code (which would on the web server be in a compiled dll), wouldn't that serve the same purpose if an attacker were to somehow gain access to the database? it would seem to me to be more secure. "}, {"sentId": 48, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "format string vulnerability", "em2Text": "use the [code] format parameter to read data", "label": "PARENT"}, {"em1Text": "format string vulnerability", "em2Text": "use the [code] format specifier to write to an arbitrary address", "label": "None"}, {"em1Text": "use the [code] format parameter to read data", "em2Text": "format string vulnerability", "label": "None"}, {"em1Text": "use the [code] format parameter to read data", "em2Text": "use the [code] format specifier to write to an arbitrary address", "label": "OR"}, {"em1Text": "use the [code] format specifier to write to an arbitrary address", "em2Text": "format string vulnerability", "label": "None"}, {"em1Text": "use the [code] format specifier to write to an arbitrary address", "em2Text": "use the [code] format parameter to read data", "label": "None"}], "entityMentions": [{"start": 29, "text": "format string vulnerability", "label": "ATTACK"}, {"start": 217, "text": "use the [code] format parameter to read data", "label": "ATTACK"}, {"start": 387, "text": "use the [code] format specifier to write to an arbitrary address", "label": "ATTACK"}], "sentText": "you may be able to exploit a format string vulnerability in many ways, directly or indirectly. let's use the following as an example (assuming no relevant os protections, which is very rare anyways): it's possible to use the [code] format parameter to read data. you can read the data of the original format string in [code], hence you can use it to read anything off the stack: you can use the [code] format specifier to write to an arbitrary address (almost). again, let's assume our vulnerable program above, and let's try changing the value of [code], which is located at [code], as seen above: "}, {"sentId": 35, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 49, "text": "anyone with the sense to check your source could steal your login inf", "label": "ATTACK"}], "sentText": "surely this form isn't going into the view where anyone with the sense to check your source could steal your login info? i would assume this needs to be done from the controller, but i don't know how to create do this from the controller. httpwebrequest and webclient look promising, but i don't know how to actually add a form to them. "}, {"sentId": 92, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "one-click session hijack", "em2Text": "captures all traffic", "label": "PARENT"}, {"em1Text": "one-click session hijack", "em2Text": "grabs the session cookie", "label": "None"}, {"em1Text": "one-click session hijack", "em2Text": "hackers just set their own cookie by typing this into the address bar: [code]", "label": "None"}, {"em1Text": "one-click session hijack", "em2Text": "xss", "label": "None"}, {"em1Text": "captures all traffic", "em2Text": "one-click session hijack", "label": "None"}, {"em1Text": "captures all traffic", "em2Text": "grabs the session cookie", "label": "AND"}, {"em1Text": "captures all traffic", "em2Text": "hackers just set their own cookie by typing this into the address bar: [code]", "label": "None"}, {"em1Text": "captures all traffic", "em2Text": "xss", "label": "OR"}, {"em1Text": "grabs the session cookie", "em2Text": "one-click session hijack", "label": "None"}, {"em1Text": "grabs the session cookie", "em2Text": "captures all traffic", "label": "None"}, {"em1Text": "grabs the session cookie", "em2Text": "hackers just set their own cookie by typing this into the address bar: [code]", "label": "PARENT"}, {"em1Text": "grabs the session cookie", "em2Text": "xss", "label": "None"}, {"em1Text": "hackers just set their own cookie by typing this into the address bar: [code]", "em2Text": "one-click session hijack", "label": "None"}, {"em1Text": "hackers just set their own cookie by typing this into the address bar: [code]", "em2Text": "captures all traffic", "label": "None"}, {"em1Text": "hackers just set their own cookie by typing this into the address bar: [code]", "em2Text": "grabs the session cookie", "label": "None"}, {"em1Text": "hackers just set their own cookie by typing this into the address bar: [code]", "em2Text": "xss", "label": "None"}, {"em1Text": "xss", "em2Text": "one-click session hijack", "label": "None"}, {"em1Text": "xss", "em2Text": "captures all traffic", "label": "None"}, {"em1Text": "xss", "em2Text": "grabs the session cookie", "label": "None"}, {"em1Text": "xss", "em2Text": "hackers just set their own cookie by typing this into the address bar: [code]", "label": "None"}], "entityMentions": [{"start": 53, "text": "one-click session hijack", "label": "ATTACK"}, {"start": 143, "text": "captures all traffic", "label": "ATTACK"}, {"start": 168, "text": "grabs the session cookie", "label": "ATTACK"}, {"start": 357, "text": "hackers just set their own cookie by typing this into the address bar: [code]", "label": "ATTACK"}, {"start": 654, "text": "xss", "label": "ATTACK"}], "sentText": "so with [link], everyone in a public wi-fi now has a one-click session hijack tool. the way it works - to my understanding - is that it simply captures all traffic and grabs the session cookie (so it doesn't steal passwords). firesheep is nothing new.  session hijacking has been around for as long as web applications have been using session ids.  usually hackers just set their own cookie by typing this into the address bar: [code]. this tool is for script kiddies that fear 1 line of javascript.  cookies can be hijacked if you don't use https for the entire life of the session and this is a part of [link].   but you can also hijack a session with xss. 3) scan your web application for xss. "}, {"sentId": 80, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 10, "text": "exec shell by exploiting format string vulnerability", "label": "ATTACK"}], "sentText": "i want to exec shell by exploiting format string vulnerability,so, i wanted to rewrite [code] function address from got by the address of my shellcode stored into environment variable. "}, {"sentId": 38, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 184, "text": "sql injection", "label": "ATTACK"}], "sentText": "when creating apps that put data to a database is mysql_real_escape_string and general checking (is_numeric etc) on input data enough? what about other types of attacks different from sql injection. "}, {"sentId": 83, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "injects an already signed dll or exe with a malcode", "em2Text": "changing the file's hash", "label": "None"}, {"em1Text": "changing the file's hash", "em2Text": "injects an already signed dll or exe with a malcode", "label": "PARENT"}], "entityMentions": [{"start": 32, "text": "injects an already signed dll or exe with a malcode", "label": "ATTACK"}, {"start": 97, "text": "changing the file's hash", "label": "ATTACK"}], "sentText": "what i'm asking is: if a hacker injects an already signed dll or exe with a malcode, effectively changing the file's hash, will it break the digital signature because the signature embeds some kind of digest? or will the signature be completely unaffected? "}, {"sentId": 107, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "a client completely rewritten (for the purposes of cheating) from cheating", "em2Text": "hacker can take your code", "label": "PARENT"}, {"em1Text": "a client completely rewritten (for the purposes of cheating) from cheating", "em2Text": "slow it down in the debugger editing it as he goes along", "label": "None"}, {"em1Text": "a client completely rewritten (for the purposes of cheating) from cheating", "em2Text": "he's left with is a primitive wrapper around your websocket", "label": "None"}, {"em1Text": "a client completely rewritten (for the purposes of cheating) from cheating", "em2Text": "hacker could pre engineer the optimum race route", "label": "None"}, {"em1Text": "a client completely rewritten (for the purposes of cheating) from cheating", "em2Text": "hacker adjusts this and adds a delay", "label": "None"}, {"em1Text": "a client completely rewritten (for the purposes of cheating) from cheating", "em2Text": "hacker adjusts this and plays less then perfect using random numbers", "label": "None"}, {"em1Text": "hacker can take your code", "em2Text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "None"}, {"em1Text": "hacker can take your code", "em2Text": "slow it down in the debugger editing it as he goes along", "label": "AND"}, {"em1Text": "hacker can take your code", "em2Text": "he's left with is a primitive wrapper around your websocket", "label": "None"}, {"em1Text": "hacker can take your code", "em2Text": "hacker could pre engineer the optimum race route", "label": "OR"}, {"em1Text": "hacker can take your code", "em2Text": "hacker adjusts this and adds a delay", "label": "None"}, {"em1Text": "hacker can take your code", "em2Text": "hacker adjusts this and plays less then perfect using random numbers", "label": "None"}, {"em1Text": "slow it down in the debugger editing it as he goes along", "em2Text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "None"}, {"em1Text": "slow it down in the debugger editing it as he goes along", "em2Text": "hacker can take your code", "label": "None"}, {"em1Text": "slow it down in the debugger editing it as he goes along", "em2Text": "he's left with is a primitive wrapper around your websocket", "label": "AND"}, {"em1Text": "slow it down in the debugger editing it as he goes along", "em2Text": "hacker could pre engineer the optimum race route", "label": "None"}, {"em1Text": "slow it down in the debugger editing it as he goes along", "em2Text": "hacker adjusts this and adds a delay", "label": "None"}, {"em1Text": "slow it down in the debugger editing it as he goes along", "em2Text": "hacker adjusts this and plays less then perfect using random numbers", "label": "None"}, {"em1Text": "he's left with is a primitive wrapper around your websocket", "em2Text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "None"}, {"em1Text": "he's left with is a primitive wrapper around your websocket", "em2Text": "hacker can take your code", "label": "None"}, {"em1Text": "he's left with is a primitive wrapper around your websocket", "em2Text": "slow it down in the debugger editing it as he goes along", "label": "None"}, {"em1Text": "he's left with is a primitive wrapper around your websocket", "em2Text": "hacker could pre engineer the optimum race route", "label": "None"}, {"em1Text": "he's left with is a primitive wrapper around your websocket", "em2Text": "hacker adjusts this and adds a delay", "label": "None"}, {"em1Text": "he's left with is a primitive wrapper around your websocket", "em2Text": "hacker adjusts this and plays less then perfect using random numbers", "label": "None"}, {"em1Text": "hacker could pre engineer the optimum race route", "em2Text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "None"}, {"em1Text": "hacker could pre engineer the optimum race route", "em2Text": "hacker can take your code", "label": "None"}, {"em1Text": "hacker could pre engineer the optimum race route", "em2Text": "slow it down in the debugger editing it as he goes along", "label": "None"}, {"em1Text": "hacker could pre engineer the optimum race route", "em2Text": "he's left with is a primitive wrapper around your websocket", "label": "None"}, {"em1Text": "hacker could pre engineer the optimum race route", "em2Text": "hacker adjusts this and adds a delay", "label": "OR"}, {"em1Text": "hacker could pre engineer the optimum race route", "em2Text": "hacker adjusts this and plays less then perfect using random numbers", "label": "None"}, {"em1Text": "hacker adjusts this and adds a delay", "em2Text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "None"}, {"em1Text": "hacker adjusts this and adds a delay", "em2Text": "hacker can take your code", "label": "None"}, {"em1Text": "hacker adjusts this and adds a delay", "em2Text": "slow it down in the debugger editing it as he goes along", "label": "None"}, {"em1Text": "hacker adjusts this and adds a delay", "em2Text": "he's left with is a primitive wrapper around your websocket", "label": "None"}, {"em1Text": "hacker adjusts this and adds a delay", "em2Text": "hacker could pre engineer the optimum race route", "label": "None"}, {"em1Text": "hacker adjusts this and adds a delay", "em2Text": "hacker adjusts this and plays less then perfect using random numbers", "label": "OR"}, {"em1Text": "hacker adjusts this and plays less then perfect using random numbers", "em2Text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "None"}, {"em1Text": "hacker adjusts this and plays less then perfect using random numbers", "em2Text": "hacker can take your code", "label": "None"}, {"em1Text": "hacker adjusts this and plays less then perfect using random numbers", "em2Text": "slow it down in the debugger editing it as he goes along", "label": "None"}, {"em1Text": "hacker adjusts this and plays less then perfect using random numbers", "em2Text": "he's left with is a primitive wrapper around your websocket", "label": "None"}, {"em1Text": "hacker adjusts this and plays less then perfect using random numbers", "em2Text": "hacker could pre engineer the optimum race route", "label": "None"}, {"em1Text": "hacker adjusts this and plays less then perfect using random numbers", "em2Text": "hacker adjusts this and adds a delay", "label": "None"}], "entityMentions": [{"start": 71, "text": "a client completely rewritten (for the purposes of cheating) from cheating", "label": "ATTACK"}, {"start": 408, "text": "hacker can take your code", "label": "ATTACK"}, {"start": 438, "text": "slow it down in the debugger editing it as he goes along", "label": "ATTACK"}, {"start": 505, "text": "he's left with is a primitive wrapper around your websocket", "label": "ATTACK"}, {"start": 1017, "text": "hacker could pre engineer the optimum race route", "label": "ATTACK"}, {"start": 1359, "text": "hacker adjusts this and adds a delay", "label": "ATTACK"}, {"start": 1456, "text": "hacker adjusts this and plays less then perfect using random numbers", "label": "ATTACK"}], "sentText": "always assume that the code is 100% hackable. think of ways to prevent a client completely rewritten (for the purposes of cheating) from cheating. these can be things such as methods for writing a secure game protocol, server-side detection, etc. your server is going to send all the visual data that the client needs to render the screen. you can not obscure this data away. no matter what you try a silled hacker can take your code and slow it down in the debugger editing it as he goes along until all he's left with is a primitive wrapper around your websocket. he let's you run the entire authentication but there is nothing you can do to stop him from stripping out any javascript you write from stopping him doing that. all you can achieve with that is limit the amount of hackers skilled enough of accessing your websocket.  so the hacker now has your websocket in a chrome sandbox. he sees the input. of course your race course is dynamically and uniquely generated. if you had a set amount of them then the hacker could pre engineer the optimum race route. the data you send to visualise this map can be rendered faster then human interaction with your game and the optimum moves to win your racing game can be calculated and send to your server.  if you were to try and ban players who reacted too fast to your map data and call them bots then the hacker adjusts this and adds a delay. if you try and ban players who play too perfectly then the hacker adjusts this and plays less then perfect using random numbers. if you place traps in your map that only algorithmic bots fall into then they can be avoided by learning about them, through trial and error or a machine learning algorithm. there is nothing you can do to be absolutely secure.  "}, {"sentId": 41, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "cross site request forgery", "em2Text": "send along the cookie with the session id", "label": "PARENT"}, {"em1Text": "cross site request forgery", "em2Text": "reading the session identifier", "label": "PARENT"}, {"em1Text": "send along the cookie with the session id", "em2Text": "cross site request forgery", "label": "None"}, {"em1Text": "send along the cookie with the session id", "em2Text": "reading the session identifier", "label": "AND"}, {"em1Text": "reading the session identifier", "em2Text": "cross site request forgery", "label": "None"}, {"em1Text": "reading the session identifier", "em2Text": "send along the cookie with the session id", "label": "None"}], "entityMentions": [{"start": 33, "text": "cross site request forgery", "label": "ATTACK"}, {"start": 126, "text": "send along the cookie with the session id", "label": "ATTACK"}, {"start": 332, "text": "reading the session identifier", "label": "ATTACK"}], "sentText": "yes, it is sufficient to prevent cross site request forgery.  the browser will make a request to mysite.com, and it will also send along the cookie with the session id. the thing to understand here is that evilsite.com cannot read the cookie, but it can still get its job done. browser same-origin policy prevents evilsite.com from reading the session identifier whether its in the cookie or embedded in html page. but because browser automatically sends the cookie to your server even if the resource was requested from the html code in another domain, you have xsrf.  "}, {"sentId": 15, "articleId": "2", "threatType": "E", "relationMentions": [{"em1Text": "used the eval function for the exploit", "em2Text": "run their php code on your site", "label": "None"}, {"em1Text": "run their php code on your site", "em2Text": "used the eval function for the exploit", "label": "PARENT"}], "entityMentions": [{"start": 60, "text": "used the eval function for the exploit", "label": "ATTACK"}, {"start": 120, "text": "run their php code on your site", "label": "ATTACK"}], "sentText": "has anyone heard about php shell offender script? it mainly used the eval function for the exploit. hackers are able to run their php code on your site. "}, {"sentId": 106, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "man in the middle attack", "em2Text": "inject changes to it", "label": "PARENT"}, {"em1Text": "inject changes to it", "em2Text": "man in the middle attack", "label": "None"}], "entityMentions": [{"start": 125, "text": "man in the middle attack", "label": "ATTACK"}, {"start": 761, "text": "inject changes to it", "label": "ATTACK"}], "sentText": "i read it's possible to put the form on http but post it to https, but i read someone saying that it can be exploited with a man in the middle attack. can someone confirm this? i have a 100 point bounty for someone who can confirm this (and help me with a practical answer how to securely solve this). my login form is on every page, do i need to make the whole website on https? please feel free to question anything i said here. they're only things i read but don't have experience with and didn't try it myself.   i read it's possible to put the form on http but post it to https, but i read someone saying that it can be exploited with a man in the middle attack. can someone confirm this? yes. the form is served up over http, so a man in the middle could inject changes to it (e.g. so it sends credentials to their own server before the form submits). "}, {"sentId": 84, "articleId": "2", "threatType": "D", "relationMentions": [{"em1Text": "forge an ajax request", "em2Text": "repeatedly submit the 'form_data' array with 100000000000 random elements", "label": "None"}, {"em1Text": "repeatedly submit the 'form_data' array with 100000000000 random elements", "em2Text": "forge an ajax request", "label": "PARENT"}], "entityMentions": [{"start": 34, "text": "forge an ajax request", "label": "ATTACK"}, {"start": 61, "text": "repeatedly submit the 'form_data' array with 100000000000 random elements", "label": "ATTACK"}], "sentText": "however, what if a hacker were to forge an ajax request, and repeatedly submit the 'form_data' array with 100000000000 random elements? the loop would have to iterate through each element, possibly causing a dos (or at least slow down service), correct? "}, {"sentId": 9, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "the authentication ticket is compromised", "em2Text": "has the user's password", "label": "None"}, {"em1Text": "has the user's password", "em2Text": "the authentication ticket is compromised", "label": "PARENT"}], "entityMentions": [{"start": 120, "text": "the authentication ticket is compromised", "label": "ATTACK"}, {"start": 179, "text": "has the user's password", "label": "ATTACK"}], "sentText": "you should not use this approach. the password should not be stored in an authentication ticket. the reason being is if the authentication ticket is compromised then the attacker has the user's password. this risk can be mitigated by encrypting the authentication ticket cookie, but i presume you were storing the cookie in plain-text. "}, {"sentId": 93, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "reverse engineer my android appliaction code", "em2Text": "could see exactly what i do", "label": "None"}, {"em1Text": "could see exactly what i do", "em2Text": "reverse engineer my android appliaction code", "label": "PARENT"}], "entityMentions": [{"start": 108, "text": "reverse engineer my android appliaction code", "label": "ATTACK"}, {"start": 180, "text": "could see exactly what i do", "label": "ATTACK"}], "sentText": "it seems to me that no matter which approach i will choose, someone who wants to hack it, will just need to reverse engineer my android appliaction code (which isn`t very hard) andcould see exactly what i do, wheather i encrypt the data, use hardcoded password or any other solution for that matter. "}, {"sentId": 67, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "implement rules for password selection", "em2Text": "reduce the size of the space of all allowable passwords", "label": "None"}, {"em1Text": "implement rules for password selection", "em2Text": "make passwords easier to guess", "label": "None"}, {"em1Text": "reduce the size of the space of all allowable passwords", "em2Text": "implement rules for password selection", "label": "PARENT"}, {"em1Text": "reduce the size of the space of all allowable passwords", "em2Text": "make passwords easier to guess", "label": "None"}, {"em1Text": "make passwords easier to guess", "em2Text": "implement rules for password selection", "label": "None"}, {"em1Text": "make passwords easier to guess", "em2Text": "reduce the size of the space of all allowable passwords", "label": "PARENT"}], "entityMentions": [{"start": 45, "text": "implement rules for password selection", "label": "ATTACK"}, {"start": 282, "text": "reduce the size of the space of all allowable passwords", "label": "ATTACK"}, {"start": 352, "text": "make passwords easier to guess", "label": "ATTACK"}], "sentText": "on more than one occasion i've been asked to implement rules for password selection for software i'm developing. typical suggestions include things like: something has always bugged me about putting any restrictions on passwords though - by restricting the available passwords, you reduce the size of the space of all allowable passwords. doesn't this make passwords easier to guess? "}, {"sentId": 130, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 104, "text": "if a package from pypi has not been altered by an external party", "label": "ATTACK"}], "sentText": "i am not trying to forward these news but i am trying to prevent myself and other teammates to identify if a package from pypi has not been altered by an external party. "}, {"sentId": 73, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "a malicious site to get around this", "em2Text": "using an iframe", "label": "PARENT"}, {"em1Text": "a malicious site to get around this", "em2Text": "modifying my http header", "label": "None"}, {"em1Text": "a malicious site to get around this", "em2Text": "making a request to the target site", "label": "None"}, {"em1Text": "using an iframe", "em2Text": "a malicious site to get around this", "label": "None"}, {"em1Text": "using an iframe", "em2Text": "modifying my http header", "label": "AND"}, {"em1Text": "using an iframe", "em2Text": "making a request to the target site", "label": "None"}, {"em1Text": "modifying my http header", "em2Text": "a malicious site to get around this", "label": "None"}, {"em1Text": "modifying my http header", "em2Text": "using an iframe", "label": "None"}, {"em1Text": "modifying my http header", "em2Text": "making a request to the target site", "label": "AND"}, {"em1Text": "making a request to the target site", "em2Text": "a malicious site to get around this", "label": "None"}, {"em1Text": "making a request to the target site", "em2Text": "using an iframe", "label": "None"}, {"em1Text": "making a request to the target site", "em2Text": "modifying my http header", "label": "None"}], "entityMentions": [{"start": 112, "text": "a malicious site to get around this", "label": "ATTACK"}, {"start": 151, "text": "using an iframe", "label": "ATTACK"}, {"start": 168, "text": "modifying my http header", "label": "ATTACK"}, {"start": 194, "text": "making a request to the target site", "label": "ATTACK"}], "sentText": "from what i understand [code] only gets your cookies for the current site you are on.  would it be possible for a malicious site to get around this by using an iframe, modifying my http header, making a request to the target site or some other method? "}, {"sentId": 100, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "the password would likely be intercepted", "em2Text": "the hash could be extracted by a man-in-the-middle attack", "label": "PARENT"}, {"em1Text": "the password would likely be intercepted", "em2Text": "use that hash to get access to the user's information", "label": "None"}, {"em1Text": "the password would likely be intercepted", "em2Text": "intercept the plain-text password, ", "label": "None"}, {"em1Text": "the password would likely be intercepted", "em2Text": "use that to gain access to the user's account.", "label": "None"}, {"em1Text": "the hash could be extracted by a man-in-the-middle attack", "em2Text": "the password would likely be intercepted", "label": "None"}, {"em1Text": "the hash could be extracted by a man-in-the-middle attack", "em2Text": "use that hash to get access to the user's information", "label": "None"}, {"em1Text": "the hash could be extracted by a man-in-the-middle attack", "em2Text": "intercept the plain-text password, ", "label": "None"}, {"em1Text": "the hash could be extracted by a man-in-the-middle attack", "em2Text": "use that to gain access to the user's account.", "label": "None"}, {"em1Text": "use that hash to get access to the user's information", "em2Text": "the password would likely be intercepted", "label": "None"}, {"em1Text": "use that hash to get access to the user's information", "em2Text": "the hash could be extracted by a man-in-the-middle attack", "label": "PARENT"}, {"em1Text": "use that hash to get access to the user's information", "em2Text": "intercept the plain-text password, ", "label": "None"}, {"em1Text": "use that hash to get access to the user's information", "em2Text": "use that to gain access to the user's account.", "label": "None"}, {"em1Text": "intercept the plain-text password, ", "em2Text": "the password would likely be intercepted", "label": "None"}, {"em1Text": "intercept the plain-text password, ", "em2Text": "the hash could be extracted by a man-in-the-middle attack", "label": "None"}, {"em1Text": "intercept the plain-text password, ", "em2Text": "use that hash to get access to the user's information", "label": "None"}, {"em1Text": "intercept the plain-text password, ", "em2Text": "use that to gain access to the user's account.", "label": "AND"}, {"em1Text": "use that to gain access to the user's account.", "em2Text": "the password would likely be intercepted", "label": "None"}, {"em1Text": "use that to gain access to the user's account.", "em2Text": "the hash could be extracted by a man-in-the-middle attack", "label": "None"}, {"em1Text": "use that to gain access to the user's account.", "em2Text": "use that hash to get access to the user's information", "label": "None"}, {"em1Text": "use that to gain access to the user's account.", "em2Text": "intercept the plain-text password, ", "label": "None"}], "entityMentions": [{"start": 26, "text": "the password would likely be intercepted", "label": "ATTACK"}, {"start": 76, "text": "the hash could be extracted by a man-in-the-middle attack", "label": "ATTACK"}, {"start": 163, "text": "use that hash to get access to the user's information", "label": "ATTACK"}, {"start": 243, "text": "intercept the plain-text password, ", "label": "ATTACK"}, {"start": 282, "text": "use that to gain access to the user's account.", "label": "ATTACK"}], "sentText": "my problem is that i feel the password would likely be intercepted. in (1), the hash could be extracted by a man-in-the-middle attack. the attacker can now simply use that hash to get access to the user's information. in (2), the attacker can intercept the plain-text password, and use that to gain access to the user's account. "}, {"sentId": 9, "articleId": "1", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 140, "text": "injection attack security", "label": "ATTACK"}], "sentText": "what are the best workarounds for using a sql [code] clause with instances of [code], which is not supported for multiple values due to sql injection attack security issues: one [code] placeholder represents one value, rather than a list of values. "}, {"sentId": 28, "articleId": "6", "threatType": "E", "relationMentions": [{"em1Text": "stealing the api key", "em2Text": "decompiling the swf", "label": "AND"}, {"em1Text": "stealing the api key", "em2Text": "create a dummy flash application", "label": "None"}, {"em1Text": "stealing the api key", "em2Text": "send random data", "label": "None"}, {"em1Text": "stealing the api key", "em2Text": "altering the api itself", "label": "None"}, {"em1Text": "decompiling the swf", "em2Text": "stealing the api key", "label": "None"}, {"em1Text": "decompiling the swf", "em2Text": "create a dummy flash application", "label": "None"}, {"em1Text": "decompiling the swf", "em2Text": "send random data", "label": "None"}, {"em1Text": "decompiling the swf", "em2Text": "altering the api itself", "label": "None"}, {"em1Text": "create a dummy flash application", "em2Text": "stealing the api key", "label": "PARENT"}, {"em1Text": "create a dummy flash application", "em2Text": "decompiling the swf", "label": "None"}, {"em1Text": "create a dummy flash application", "em2Text": "send random data", "label": "AND"}, {"em1Text": "create a dummy flash application", "em2Text": "altering the api itself", "label": "None"}, {"em1Text": "send random data", "em2Text": "stealing the api key", "label": "PARENT"}, {"em1Text": "send random data", "em2Text": "decompiling the swf", "label": "None"}, {"em1Text": "send random data", "em2Text": "create a dummy flash application", "label": "None"}, {"em1Text": "send random data", "em2Text": "altering the api itself", "label": "None"}, {"em1Text": "altering the api itself", "em2Text": "stealing the api key", "label": "None"}, {"em1Text": "altering the api itself", "em2Text": "decompiling the swf", "label": "None"}, {"em1Text": "altering the api itself", "em2Text": "create a dummy flash application", "label": "None"}, {"em1Text": "altering the api itself", "em2Text": "send random data", "label": "None"}], "entityMentions": [{"start": 21, "text": "stealing the api key", "label": "ATTACK"}, {"start": 118, "text": "decompiling the swf", "label": "ATTACK"}, {"start": 184, "text": "create a dummy flash application", "label": "ATTACK"}, {"start": 221, "text": "send random data", "label": "ATTACK"}, {"start": 254, "text": "altering the api itself", "label": "ATTACK"}], "sentText": "the big one - people stealing the api key via man-in-the-middle attack.highscore injection, false achievement unlocks.decompiling the swf and stealing the api key.using the api key to create a dummy flash application and send random data like highscores.altering the api itself so you don't need to be logged in, etc. "}, {"sentId": 8, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "hijack dns server ", "em2Text": "inject maliciously modified library", "label": "AND"}, {"em1Text": "hijack dns server ", "em2Text": "opening the door for different security attacks", "label": "None"}, {"em1Text": "inject maliciously modified library", "em2Text": "hijack dns server ", "label": "None"}, {"em1Text": "inject maliciously modified library", "em2Text": "opening the door for different security attacks", "label": "None"}, {"em1Text": "opening the door for different security attacks", "em2Text": "hijack dns server ", "label": "PARENT"}, {"em1Text": "opening the door for different security attacks", "em2Text": "inject maliciously modified library", "label": "None"}], "entityMentions": [{"start": 59, "text": "hijack dns server ", "label": "ATTACK"}, {"start": 86, "text": "inject maliciously modified library", "label": "ATTACK"}, {"start": 123, "text": "opening the door for different security attacks", "label": "ATTACK"}], "sentText": "for example, they mention the scenario where someone might hijack dns server and then inject maliciously modified library, opening the door for different security attacks. now, if hacker can inject malicious code through google cdn, then he can probably do the same if jquery is served from the site itself, right? "}, {"sentId": 13, "articleId": "1", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 29, "text": "kernel or cross-process memory disclosure", "label": "ATTACK"}], "sentText": "in order to mitigate against kernel or cross-process memory disclosure (the [link] attack), [link], [code] introduced to [code] to perform indirect calls through a so-called retpoline. "}, {"sentId": 97, "articleId": "2", "threatType": "T", "relationMentions": [{"em1Text": "compromising the hash", "em2Text": "replacing a malicious binary with a matching key", "label": "None"}, {"em1Text": "replacing a malicious binary with a matching key", "em2Text": "compromising the hash", "label": "PARENT"}], "entityMentions": [{"start": 92, "text": "compromising the hash", "label": "ATTACK"}, {"start": 118, "text": "replacing a malicious binary with a matching key", "label": "ATTACK"}], "sentText": "the only thing i can see is that with hashing, a compromised server could mean someone also compromising the hash and replacing a malicious binary with a matching key; but with a public-private scheme, as long as the private key remains private, there is no way to forge a malicious file. "}, {"sentId": 99, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 79, "text": "rainbow tables that, from a hash valu", "label": "ATTACK"}], "sentText": "no, you're mistaken. brute force attacks are one thing, but the real danger is rainbow tables that, from a hash value, gives you the plaintext password. "}, {"sentId": 57, "articleId": "1", "threatType": "I", "relationMentions": [{"em1Text": "knowing the structure of your filesystem", "em2Text": "execute directory traversal attacks", "label": "None"}, {"em1Text": "execute directory traversal attacks", "em2Text": "knowing the structure of your filesystem", "label": "PARENT"}], "entityMentions": [{"start": 0, "text": "knowing the structure of your filesystem", "label": "ATTACK"}, {"start": 64, "text": "execute directory traversal attacks", "label": "ATTACK"}], "sentText": "knowing the structure of your filesystem might allow hackers to execute directory traversal attacks if your site is vulnerable to them. "}, {"sentId": 96, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "got access to your computer", "em2Text": "see the jwt that is stored in the browser and use it", "label": "None"}, {"em1Text": "got access to your computer", "em2Text": "\"man in the middle\" attack", "label": "None"}, {"em1Text": "got access to your computer", "em2Text": "intercept the network traffic between client and server", "label": "None"}, {"em1Text": "got access to your computer", "em2Text": "get at the cookie/jwt", "label": "None"}, {"em1Text": "see the jwt that is stored in the browser and use it", "em2Text": "got access to your computer", "label": "PARENT"}, {"em1Text": "see the jwt that is stored in the browser and use it", "em2Text": "\"man in the middle\" attack", "label": "OR"}, {"em1Text": "see the jwt that is stored in the browser and use it", "em2Text": "intercept the network traffic between client and server", "label": "None"}, {"em1Text": "see the jwt that is stored in the browser and use it", "em2Text": "get at the cookie/jwt", "label": "None"}, {"em1Text": "\"man in the middle\" attack", "em2Text": "got access to your computer", "label": "None"}, {"em1Text": "\"man in the middle\" attack", "em2Text": "see the jwt that is stored in the browser and use it", "label": "None"}, {"em1Text": "\"man in the middle\" attack", "em2Text": "intercept the network traffic between client and server", "label": "PARENT"}, {"em1Text": "\"man in the middle\" attack", "em2Text": "get at the cookie/jwt", "label": "None"}, {"em1Text": "intercept the network traffic between client and server", "em2Text": "got access to your computer", "label": "None"}, {"em1Text": "intercept the network traffic between client and server", "em2Text": "see the jwt that is stored in the browser and use it", "label": "None"}, {"em1Text": "intercept the network traffic between client and server", "em2Text": "\"man in the middle\" attack", "label": "None"}, {"em1Text": "intercept the network traffic between client and server", "em2Text": "get at the cookie/jwt", "label": "AND"}, {"em1Text": "get at the cookie/jwt", "em2Text": "got access to your computer", "label": "None"}, {"em1Text": "get at the cookie/jwt", "em2Text": "see the jwt that is stored in the browser and use it", "label": "None"}, {"em1Text": "get at the cookie/jwt", "em2Text": "\"man in the middle\" attack", "label": "None"}, {"em1Text": "get at the cookie/jwt", "em2Text": "intercept the network traffic between client and server", "label": "None"}], "entityMentions": [{"start": 21, "text": "got access to your computer", "label": "ATTACK"}, {"start": 61, "text": "see the jwt that is stored in the browser and use it", "label": "ATTACK"}, {"start": 228, "text": "\"man in the middle\" attack", "label": "ATTACK"}, {"start": 258, "text": "intercept the network traffic between client and server", "label": "ATTACK"}, {"start": 318, "text": "get at the cookie/jwt", "label": "ATTACK"}], "sentText": "however, if a hacker got access to your computer, they could see the jwt that is stored in the browser and use it. this same threat exists w/cookies, so it's not really a flaw of the jwt. another approach for hackers would be a \"man in the middle\" attack to intercept the network traffic between client and server and get at the cookie/jwt. the cookie/jwt should always be sent over https to prevent this. "}, {"sentId": 42, "articleId": "2", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 235, "text": "rdbms would be extremely vulnerable to sql injection", "label": "ATTACK"}], "sentText": "for the sake of getting something up and running right now i am passing the express query string object directly to a mongoose find function. what i am curious about is how dangerous would this practice be in a live app. i know that a rdbms would be extremely vulnerable to sql injection. aside from the good advice of \"sanitize your inputs\" how evil is this code: "}, {"sentId": 2, "articleId": "3", "threatType": "I", "relationMentions": [{"em1Text": "hack the database", "em2Text": "somehow get access to the encrypted passwords", "label": "OR"}, {"em1Text": "somehow get access to the encrypted passwords", "em2Text": "hack the database", "label": "None"}], "entityMentions": [{"start": 60, "text": "hack the database", "label": "ATTACK"}, {"start": 81, "text": "somehow get access to the encrypted passwords", "label": "ATTACK"}], "sentText": "to me, this is a gaping security hole.  if somebody were to hack the database or somehow get access to the encrypted passwords, they wouldn't even need to crack them.  just set your own cookies and go.  am i correct, or just being paranoid? "}, {"sentId": 156, "articleId": "6", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 64, "text": "making false requests as other user", "label": "ATTACK"}], "sentText": "my question is which scenario is more safe, for example against making false requests as other user. for scenario 1, does the security component allow manipulating input values through firebug or some other software? "}, {"sentId": 96, "articleId": "4", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 120, "text": "steal the json data", "label": "ATTACK"}], "sentText": "it is well known that [link] (js,not json) which is prefixes with [code] &amp; [code] in order to prevent script tag to steal the json data when old browsers are [link] "}, {"sentId": 16, "articleId": "2", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 25, "text": "cookie has been hijacked", "label": "ATTACK"}], "sentText": "this is important if the cookie has been hijacked. it will be invalidated if the user detects the hijacking, and furthermore because the token is unrelated to the password the hijacker won't be able to derive and then change the user's account password and \"own\" the account (assuming you require the existing password before changing passwords, the hijacker doesn't own the email account so they can't use \"forgot my password\" etc). "}, {"sentId": 106, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 687, "text": "executed the post-install hook of a malicious version of ua-parser", "label": "ATTACK"}], "sentText": "in light of recent malware in existing npm packages, i would like to have a mechanism that lets me do some basic checks before installing new packages or updating existing ones. my main issue are both the packages i install directly, and also the ones i install indirectly.in general i want to get a list of package-version that npm would install before installing it. more specifically i want the age of the packages that would be installed, so i can generate a warning if any of them is less than a day old.if i could do that directly with npm, that would be neat, but i'm afraid i need to do some scripting around it.specific use case:if i executed [code] on 2021-10-22 it would have executed the post-install hook of a malicious version of ua-parser and my computer would have been compromised, which is something i would like to avoid.when i enter [code], it only tells me which version of react-native-gesture-handler it would have installed, but it would not tell me that it would install a version of ua-parser that was released on that day.additional notes:i know that [code] exists, but it shows only the direct packages.i know that [code] exists, but it only shows packages after installing (and thus after install-hooks have already done their harm)both only show packages version and not their agei do not know how i would get a list of packages that would come with a install-hook before installing thempointers to alternative ways to deal with malicious npm packages are welcome.so far my best solution would be to do &quot;--ignore-scripts&quot; but that would come with it's own set of problems "}, {"sentId": 52, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 23, "text": "a hacker modified form data", "label": "ATTACK"}], "sentText": "before reaching server a hacker modified form data(first name &amp; last name) leaving token info unchanged. "}, {"sentId": 3, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "sql injection", "em2Text": "user can input something like [code]", "label": "PARENT"}, {"em1Text": "sql injection", "em2Text": "the query becomes:[code]", "label": "PARENT"}, {"em1Text": "user can input something like [code]", "em2Text": "sql injection", "label": "None"}, {"em1Text": "user can input something like [code]", "em2Text": "the query becomes:[code]", "label": "AND"}, {"em1Text": "the query becomes:[code]", "em2Text": "sql injection", "label": "None"}, {"em1Text": "the query becomes:[code]", "em2Text": "user can input something like [code]", "label": "None"}], "entityMentions": [{"start": 111, "text": "sql injection", "label": "ATTACK"}, {"start": 19, "text": "user can input something like [code]", "label": "ATTACK"}, {"start": 61, "text": "the query becomes:[code]", "label": "ATTACK"}], "sentText": "that's because the user can input something like [code], and the query becomes:[code] the correct way to avoid sql injection attacks, no matter which database you use, is to separate the data from sql, so that data stays data and will never be interpreted as commands by the sql parser. it is possible to create sql statement with correctly formatted data parts, but if you don't fully understand the details, you should always use prepared statements and parameterized queries.  "}, {"sentId": 24, "articleId": "1", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 29, "text": "buffer overflow attack", "label": "ATTACK"}], "sentText": "this code is vulnerable to a buffer overflow attack, and i'm trying to figure out why. i'm thinking it has to do with [code] being declared a [code] instead of an [code], but i'm not really sure. "}, {"sentId": 26, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "prevent attacks from the form side", "em2Text": "from the database side", "label": "None"}, {"em1Text": "from the database side", "em2Text": "prevent attacks from the form side", "label": "None"}], "entityMentions": [{"start": 32, "text": "prevent attacks from the form side", "label": "ATTACK"}, {"start": 76, "text": "from the database side", "label": "ATTACK"}], "sentText": "i feel i am doing what i can to prevent attacks from the form side, but not from the database side. i know you can change the type of password storage to encrypt upon entry to the database, but what i don't understand is how i would then query this encrypted string. "}, {"sentId": 12, "articleId": "6", "threatType": "E", "relationMentions": [], "entityMentions": [{"start": 382, "text": "accessing the underlying system in malicious ways", "label": "ATTACK"}], "sentText": "i recently learned about java's security model. most people think java is secure because it is immune to buffer overflows, etc, but there is this entire java security model centered around checking whether code has permission to take certain actions. they're really solving a challenging problem: how to let arbitrary untrusted code (say in a web browser) run but be prevented from accessing the underlying system in malicious ways while retaining the ability to interact with the system in some ways. "}, {"sentId": 7, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "including a [code] tag on your site", "em2Text": "src is to any site that is not controlled by you", "label": "AND"}, {"em1Text": "including a [code] tag on your site", "em2Text": "start farming user sessions/cookies/data", "label": "None"}, {"em1Text": "src is to any site that is not controlled by you", "em2Text": "including a [code] tag on your site", "label": "None"}, {"em1Text": "src is to any site that is not controlled by you", "em2Text": "start farming user sessions/cookies/data", "label": "None"}, {"em1Text": "start farming user sessions/cookies/data", "em2Text": "including a [code] tag on your site", "label": "None"}, {"em1Text": "start farming user sessions/cookies/data", "em2Text": "src is to any site that is not controlled by you", "label": "PARENT"}], "entityMentions": [{"start": 95, "text": "including a [code] tag on your site", "label": "ATTACK"}, {"start": 137, "text": "src is to any site that is not controlled by you", "label": "ATTACK"}, {"start": 222, "text": "start farming user sessions/cookies/data", "label": "ATTACK"}], "sentText": "from my understanding the only vector for jsonp is the exact same vector which is opened up by including a [code] tag on your site whose src is to any site that is not controlled by you: that they could turn malicious and start farming user sessions/cookies/data. if that is true, then it would seem that it is not the protocol (jsonp) that is the concern, but rather the source that the data is gathered from.  "}, {"sentId": 40, "articleId": "1", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 19, "text": "attacker can embed a  script tag pointing at a remote server", "label": "ATTACK"}], "sentText": "  script-tags: the attacker can embed a  script tag pointing at a remote server  and the browser will effectively  eval() the reply for you, however it  throws away the response and since  json is all response, you're safe. "}, {"sentId": 135, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "using inspect element", "em2Text": "editing the javascript and html", "label": "AND"}, {"em1Text": "using inspect element", "em2Text": "the attacker can mess with an [code] call", "label": "None"}, {"em1Text": "using inspect element", "em2Text": "send bad info to the server", "label": "None"}, {"em1Text": "editing the javascript and html", "em2Text": "using inspect element", "label": "None"}, {"em1Text": "editing the javascript and html", "em2Text": "the attacker can mess with an [code] call", "label": "None"}, {"em1Text": "editing the javascript and html", "em2Text": "send bad info to the server", "label": "None"}, {"em1Text": "the attacker can mess with an [code] call", "em2Text": "using inspect element", "label": "None"}, {"em1Text": "the attacker can mess with an [code] call", "em2Text": "editing the javascript and html", "label": "None"}, {"em1Text": "the attacker can mess with an [code] call", "em2Text": "send bad info to the server", "label": "AND"}, {"em1Text": "send bad info to the server", "em2Text": "using inspect element", "label": "None"}, {"em1Text": "send bad info to the server", "em2Text": "editing the javascript and html", "label": "None"}, {"em1Text": "send bad info to the server", "em2Text": "the attacker can mess with an [code] call", "label": "None"}], "entityMentions": [{"start": 140, "text": "using inspect element", "label": "ATTACK"}, {"start": 166, "text": "editing the javascript and html", "label": "ATTACK"}, {"start": 483, "text": "the attacker can mess with an [code] call", "label": "ATTACK"}, {"start": 529, "text": "send bad info to the server", "label": "ATTACK"}], "sentText": "i know this is a broad question, but i think i'm missing something here. is it possible for an attacker to cause damage to a site by simple using inspect element and editing the javascript and html? for example, it seems too easy for someone to change the maxlength of an input, and upload so much data that it could crash the server, i know that it is always good practice to check data at the server but it still seems too easy. or another more potentially dangerous example is if the attacker can mess with an [code] call and send bad info to the server. is it something i should be worrying more about or are the changes just temporary, on the attackers browser? "}, {"sentId": 29, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "new user completes the registration", "em2Text": "an email will be sent, containing a url", "label": "None"}, {"em1Text": "new user completes the registration", "em2Text": "once tapped from within an ios device", "label": "None"}, {"em1Text": "new user completes the registration", "em2Text": "a malicious app could sign up to the same url scheme", "label": "None"}, {"em1Text": "an email will be sent, containing a url", "em2Text": "new user completes the registration", "label": "PARENT"}, {"em1Text": "an email will be sent, containing a url", "em2Text": "once tapped from within an ios device", "label": "AND"}, {"em1Text": "an email will be sent, containing a url", "em2Text": "a malicious app could sign up to the same url scheme", "label": "None"}, {"em1Text": "once tapped from within an ios device", "em2Text": "new user completes the registration", "label": "None"}, {"em1Text": "once tapped from within an ios device", "em2Text": "an email will be sent, containing a url", "label": "None"}, {"em1Text": "once tapped from within an ios device", "em2Text": "a malicious app could sign up to the same url scheme", "label": "None"}, {"em1Text": "a malicious app could sign up to the same url scheme", "em2Text": "new user completes the registration", "label": "None"}, {"em1Text": "a malicious app could sign up to the same url scheme", "em2Text": "an email will be sent, containing a url", "label": "None"}, {"em1Text": "a malicious app could sign up to the same url scheme", "em2Text": "once tapped from within an ios device", "label": "PARENT"}], "entityMentions": [{"start": 30, "text": "new user completes the registration", "label": "ATTACK"}, {"start": 67, "text": "an email will be sent, containing a url", "label": "ATTACK"}, {"start": 112, "text": "once tapped from within an ios device", "label": "ATTACK"}, {"start": 356, "text": "a malicious app could sign up to the same url scheme", "label": "ATTACK"}], "sentText": "a web application that once a new user completes the registration, an email will be sent, containing a url that once tapped from within an ios device, the ios app will be launched. this scenario is a classic scenario to make users use the mobile app. while implementing it (using url scheme), we start wondering how secured is this method? theoretically - a malicious app could sign up to the same url scheme, and according to apple: "}, {"sentId": 32, "articleId": "2", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 80, "text": "sql injections", "label": "ATTACK"}], "sentText": "sql injection: yes! mysql_escape_string probably still keeps you susceptible to sql injections, depending on where you use php variables in your queries.   like exploits:  like \"$data%\" where $data could be \"%\" which would return all records ... which can very well be a security exploit... just imagine a lookup by last four digits of a credit card... oops! now the hackers can potentially receive every credit card number in your system! (btw: storing full credit cards is hardly ever recommended!)charset exploits:  no matter what the haters say, internet explorer is still, in 2011, vulnerable to character set exploits, and that's if you have designed your html page correctly, with the equivalent of [code]!  these attacks are very nasty as they give the hacker as much control as straight sql injections: e.g. full.   "}, {"sentId": 79, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 95, "text": "cross site issue", "label": "ATTACK"}], "sentText": "i'm doing a plugin to do some transformations to the interface. i keep getting [code] (typical cross site issue) "}, {"sentId": 131, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "mitm attack", "em2Text": "use their certificate", "label": "None"}, {"em1Text": "mitm attack", "em2Text": "read the data", "label": "PARENT"}, {"em1Text": "use their certificate", "em2Text": "mitm attack", "label": "None"}, {"em1Text": "use their certificate", "em2Text": "read the data", "label": "None"}, {"em1Text": "read the data", "em2Text": "mitm attack", "label": "None"}, {"em1Text": "read the data", "em2Text": "use their certificate", "label": "PARENT"}], "entityMentions": [{"start": 23, "text": "mitm attack", "label": "ATTACK"}, {"start": 71, "text": "use their certificate", "label": "ATTACK"}, {"start": 169, "text": "read the data", "label": "ATTACK"}], "sentText": "my qa team simply does mitm attack for every network call, they try to use their certificate and if for any network call i don't verify certificate then they can easily read the data. because of cache i'm unable to verify my certificate. "}, {"sentId": 7, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "hack the game", "em2Text": "increasing high score by using software such as cheat engine", "label": "PARENT"}, {"em1Text": "increasing high score by using software such as cheat engine", "em2Text": "hack the game", "label": "None"}], "entityMentions": [{"start": 98, "text": "hack the game", "label": "ATTACK"}, {"start": 115, "text": "increasing high score by using software such as cheat engine", "label": "ATTACK"}], "sentText": "i recently made a simple game where user can submit his/her high scores online.it is very easy to hack the game by increasing high score by using software such as cheat engine. high score is stored in an integer. should i store encrypted high score instead of an integer and decrypt it to show in the game? "}, {"sentId": 43, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "buffer overflow vulnerability", "em2Text": "getting input from another function", "label": "PARENT"}, {"em1Text": "buffer overflow vulnerability", "em2Text": "pass anything longer than 100 characters", "label": "None"}, {"em1Text": "getting input from another function", "em2Text": "buffer overflow vulnerability", "label": "None"}, {"em1Text": "getting input from another function", "em2Text": "pass anything longer than 100 characters", "label": "AND"}, {"em1Text": "pass anything longer than 100 characters", "em2Text": "buffer overflow vulnerability", "label": "None"}, {"em1Text": "pass anything longer than 100 characters", "em2Text": "getting input from another function", "label": "None"}], "entityMentions": [{"start": 33, "text": "buffer overflow vulnerability", "label": "ATTACK"}, {"start": 128, "text": "getting input from another function", "label": "ATTACK"}, {"start": 384, "text": "pass anything longer than 100 characters", "label": "ATTACK"}], "sentText": "assume that i have a code having buffer overflow vulnerability as following is there a way to exploit this vulnerability if its getting input from another function (not user input) and the length of str is always less than 100? but that doesn't mean you should leave it unfixed. while there is no physical vulnerability, there is a lot of potential for a vulnerability. now you don't pass anything longer than 100 characters. but what about a few months from now on? will you remember that you can only pass input shorter than 100 characters? i don't think so. "}, {"sentId": 100, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "man-in-the-middle attack", "em2Text": "generate certificates on the fly with its own ca", "label": "PARENT"}, {"em1Text": "generate certificates on the fly with its own ca", "em2Text": "man-in-the-middle attack", "label": "None"}], "entityMentions": [{"start": 99, "text": "man-in-the-middle attack", "label": "ATTACK"}, {"start": 155, "text": "generate certificates on the fly with its own ca", "label": "ATTACK"}], "sentText": "i'm looking for a transparent ssl/tls proxy tool to capture (and change?) generic ssl/tls traffic (man-in-the-middle attack). basically something that can generate certificates on the fly with its own ca. in a way, i'm looking for something like [link], but for non-http(s) traffic. any suggestions? "}, {"sentId": 85, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "someone knows the ip-address of one of our application servers ", "em2Text": "fake it to get access to the other application", "label": "AND"}, {"em1Text": "someone knows the ip-address of one of our application servers ", "em2Text": "an attacker that wants to fake my ip-address", "label": "None"}, {"em1Text": "someone knows the ip-address of one of our application servers ", "em2Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "label": "None"}, {"em1Text": "someone knows the ip-address of one of our application servers ", "em2Text": "this isp does not do packet inspection", "label": "None"}, {"em1Text": "fake it to get access to the other application", "em2Text": "someone knows the ip-address of one of our application servers ", "label": "None"}, {"em1Text": "fake it to get access to the other application", "em2Text": "an attacker that wants to fake my ip-address", "label": "None"}, {"em1Text": "fake it to get access to the other application", "em2Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "label": "None"}, {"em1Text": "fake it to get access to the other application", "em2Text": "this isp does not do packet inspection", "label": "None"}, {"em1Text": "an attacker that wants to fake my ip-address", "em2Text": "someone knows the ip-address of one of our application servers ", "label": "None"}, {"em1Text": "an attacker that wants to fake my ip-address", "em2Text": "fake it to get access to the other application", "label": "None"}, {"em1Text": "an attacker that wants to fake my ip-address", "em2Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "label": "PARENT"}, {"em1Text": "an attacker that wants to fake my ip-address", "em2Text": "this isp does not do packet inspection", "label": "None"}, {"em1Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "em2Text": "someone knows the ip-address of one of our application servers ", "label": "None"}, {"em1Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "em2Text": "fake it to get access to the other application", "label": "None"}, {"em1Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "em2Text": "an attacker that wants to fake my ip-address", "label": "None"}, {"em1Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "em2Text": "this isp does not do packet inspection", "label": "OR"}, {"em1Text": "this isp does not do packet inspection", "em2Text": "someone knows the ip-address of one of our application servers ", "label": "None"}, {"em1Text": "this isp does not do packet inspection", "em2Text": "fake it to get access to the other application", "label": "None"}, {"em1Text": "this isp does not do packet inspection", "em2Text": "an attacker that wants to fake my ip-address", "label": "None"}, {"em1Text": "this isp does not do packet inspection", "em2Text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "label": "None"}], "entityMentions": [{"start": 0, "text": "someone knows the ip-address of one of our application servers ", "label": "ATTACK"}, {"start": 76, "text": "fake it to get access to the other application", "label": "ATTACK"}, {"start": 283, "text": "an attacker that wants to fake my ip-address", "label": "ATTACK"}, {"start": 337, "text": "compromise the very same isp that is in charge of the ip-range my webserver operates in", "label": "ATTACK"}, {"start": 430, "text": "this isp does not do packet inspection", "label": "ATTACK"}], "sentText": "someone knows the ip-address of one of our application servers and wants to fake it to get access to the other application which he knows the listening socket and protocol of.so he alters the header of his ip packets to have the webserver ip as transmitter. so to put this straight: an attacker that wants to fake my ip-address needs to compromise the very same isp that is in charge of the ip-range my webserver operates in - or this isp does not do packet inspection. "}, {"sentId": 95, "articleId": "4", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 30, "text": "just go down to the assemble code", "label": "ATTACK"}], "sentText": "i know that an attacker could just go down to the assemble code, and at that point there is nothing at all i can do against this (the system has to be able to encrypt / decrypt the data), but is there like a shortcut for c# to get the encryppassword, since it is managed, or does something like this still require you to go down to the assemble code? "}, {"sentId": 19, "articleId": "1", "threatType": "I", "relationMentions": [{"em1Text": "env vars are not particularly secure", "em2Text": "they are visible via [code]", "label": "PARENT"}, {"em1Text": "env vars are not particularly secure", "em2Text": "they are available to any user that can run [code]", "label": "None"}, {"em1Text": "they are visible via [code]", "em2Text": "env vars are not particularly secure", "label": "None"}, {"em1Text": "they are visible via [code]", "em2Text": "they are available to any user that can run [code]", "label": "AND"}, {"em1Text": "they are available to any user that can run [code]", "em2Text": "env vars are not particularly secure", "label": "None"}, {"em1Text": "they are available to any user that can run [code]", "em2Text": "they are visible via [code]", "label": "None"}], "entityMentions": [{"start": 9, "text": "env vars are not particularly secure", "label": "ATTACK"}, {"start": 54, "text": "they are visible via [code]", "label": "ATTACK"}, {"start": 93, "text": "they are available to any user that can run [code]", "label": "ATTACK"}], "sentText": "however, env vars are not particularly secure either. they are visible via [code], and hence they are available to any user that can run [code] commands. (of course, any user that has access to [code] on the host also [link] anyway.) "}, {"sentId": 128, "articleId": "4", "threatType": "E", "relationMentions": [{"em1Text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "em2Text": "execute the code in the tmp folder", "label": "None"}, {"em1Text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "em2Text": "they get into your web root", "label": "None"}, {"em1Text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "em2Text": "execute any arbitrary code on your server", "label": "None"}, {"em1Text": "execute the code in the tmp folder", "em2Text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "label": "PARENT"}, {"em1Text": "execute the code in the tmp folder", "em2Text": "they get into your web root", "label": "None"}, {"em1Text": "execute the code in the tmp folder", "em2Text": "execute any arbitrary code on your server", "label": "None"}, {"em1Text": "they get into your web root", "em2Text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "label": "None"}, {"em1Text": "they get into your web root", "em2Text": "execute the code in the tmp folder", "label": "None"}, {"em1Text": "they get into your web root", "em2Text": "execute any arbitrary code on your server", "label": "None"}, {"em1Text": "execute any arbitrary code on your server", "em2Text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "label": "None"}, {"em1Text": "execute any arbitrary code on your server", "em2Text": "execute the code in the tmp folder", "label": "None"}, {"em1Text": "execute any arbitrary code on your server", "em2Text": "they get into your web root", "label": "PARENT"}], "entityMentions": [{"start": 24, "text": "temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp", "label": "ATTACK"}, {"start": 210, "text": "execute the code in the tmp folder", "label": "ATTACK"}, {"start": 308, "text": "they get into your web root", "label": "ATTACK"}, {"start": 366, "text": "execute any arbitrary code on your server", "label": "ATTACK"}], "sentText": "i have noticed that our temp directory has a number of what appear to be temporary files with names like phpa3f9.tmp  this appears to be an attack attempt, but i presume it relies on the attacker being able to execute the code in the tmp folder. those are php shells - mostly harmless where they are, but if they get into your web root, they'll allow an attacker to execute any arbitrary code on your server.  "}, {"sentId": 10, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "a spam bot will not support javascript", "em2Text": "submit what it sees", "label": "AND"}, {"em1Text": "a spam bot will not support javascript", "em2Text": "the bot does support javascript", "label": "OR"}, {"em1Text": "a spam bot will not support javascript", "em2Text": "it will submit the form instantly", "label": "None"}, {"em1Text": "a spam bot will not support javascript", "em2Text": "malicious scripted activity", "label": "None"}, {"em1Text": "submit what it sees", "em2Text": "a spam bot will not support javascript", "label": "None"}, {"em1Text": "submit what it sees", "em2Text": "the bot does support javascript", "label": "None"}, {"em1Text": "submit what it sees", "em2Text": "it will submit the form instantly", "label": "None"}, {"em1Text": "submit what it sees", "em2Text": "malicious scripted activity", "label": "None"}, {"em1Text": "the bot does support javascript", "em2Text": "a spam bot will not support javascript", "label": "None"}, {"em1Text": "the bot does support javascript", "em2Text": "submit what it sees", "label": "None"}, {"em1Text": "the bot does support javascript", "em2Text": "it will submit the form instantly", "label": "AND"}, {"em1Text": "the bot does support javascript", "em2Text": "malicious scripted activity", "label": "None"}, {"em1Text": "it will submit the form instantly", "em2Text": "a spam bot will not support javascript", "label": "None"}, {"em1Text": "it will submit the form instantly", "em2Text": "submit what it sees", "label": "None"}, {"em1Text": "it will submit the form instantly", "em2Text": "the bot does support javascript", "label": "None"}, {"em1Text": "it will submit the form instantly", "em2Text": "malicious scripted activity", "label": "None"}, {"em1Text": "malicious scripted activity", "em2Text": "a spam bot will not support javascript", "label": "PARENT"}, {"em1Text": "malicious scripted activity", "em2Text": "submit what it sees", "label": "None"}, {"em1Text": "malicious scripted activity", "em2Text": "the bot does support javascript", "label": "None"}, {"em1Text": "malicious scripted activity", "em2Text": "it will submit the form instantly", "label": "None"}], "entityMentions": [{"start": 203, "text": "a spam bot will not support javascript", "label": "ATTACK"}, {"start": 251, "text": "submit what it sees", "label": "ATTACK"}, {"start": 275, "text": "the bot does support javascript", "label": "ATTACK"}, {"start": 307, "text": "it will submit the form instantly", "label": "ATTACK"}, {"start": 119, "text": "malicious scripted activity", "label": "ATTACK"}], "sentText": "it looks like we'll be adding [link] support to stack overflow. this is necessary to prevent bots, spammers, and other malicious scripted activity. we only want human beings to post or edit things here! a spam bot will not support javascript and will submit what it sees. if the bot does support javascript it will submit the form instantly. the commenter has at least read some of the page before posting "}, {"sentId": 37, "articleId": "4", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 33, "text": "buffer overflow attacks", "label": "ATTACK"}], "sentText": "what are the ideas of preventing buffer overflow attacks? and i heard about stackguard,but until now is this problem completely solved by applying stackguard or combination of it with other techniques?   why do you think that it is so  difficult to provide adequate  defenses for buffer overflow attacks? "}, {"sentId": 87, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "[code]", "em2Text": "[code]", "label": "None"}, {"em1Text": "[code]", "em2Text": "sql injection", "label": "None"}, {"em1Text": "[code]", "em2Text": "[code]", "label": "None"}, {"em1Text": "[code]", "em2Text": "sql injection", "label": "None"}, {"em1Text": "sql injection", "em2Text": "[code]", "label": "None"}, {"em1Text": "sql injection", "em2Text": "[code]", "label": "None"}], "entityMentions": [{"start": 0, "text": "[code]", "label": "ATTACK"}, {"start": 0, "text": "[code]", "label": "ATTACK"}, {"start": 87, "text": "sql injection", "label": "ATTACK"}], "sentText": "[code] i know this works and i know this is the generally recommended way to do it.  a sql injection-vulnerable way to do the same thing would be something like this: [code] as far i can tell i understand sql injection, as explained in [link].  my question is simply: how is method a really different to method b?  why is the end result of method a not the same as method b?  i assume that the [code] method (part of python's db-api specification) takes care of correctly escaping and type-checking the input, but this is never explicitly stated anywhere.  is that all that parameterisation in this context is?  to me, when we say \"parameterisation\", all that means is \"string substitution\", like %-formatting.  is that incorrect? [code] if you use a [code] parameter, then the sql engine sees a query that looks like [code] which means that before it even sees the string \"wayne\", it can fully parse the query and understand, generally, what the query does. it sticks \"wayne\" into its own representation of the query, not the sql string that describes the query. thus, sql injection is impossible, since we've already passed the sql stage of the process. "}, {"sentId": 39, "articleId": "1", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 18, "text": "xss attacks", "label": "ATTACK"}], "sentText": "how can i prevent xss attacks in a jsp/servlet web application? "}, {"sentId": 29, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "xss", "em2Text": "inject script", "label": "None"}, {"em1Text": "xss", "em2Text": "reads your csrf cookie", "label": "None"}, {"em1Text": "xss", "em2Text": "make a request to one of your api endpoints using this csrf token ", "label": "PARENT"}, {"em1Text": "inject script", "em2Text": "xss", "label": "None"}, {"em1Text": "inject script", "em2Text": "reads your csrf cookie", "label": "None"}, {"em1Text": "inject script", "em2Text": "make a request to one of your api endpoints using this csrf token ", "label": "None"}, {"em1Text": "reads your csrf cookie", "em2Text": "xss", "label": "None"}, {"em1Text": "reads your csrf cookie", "em2Text": "inject script", "label": "PARENT"}, {"em1Text": "reads your csrf cookie", "em2Text": "make a request to one of your api endpoints using this csrf token ", "label": "None"}, {"em1Text": "make a request to one of your api endpoints using this csrf token ", "em2Text": "xss", "label": "None"}, {"em1Text": "make a request to one of your api endpoints using this csrf token ", "em2Text": "inject script", "label": "None"}, {"em1Text": "make a request to one of your api endpoints using this csrf token ", "em2Text": "reads your csrf cookie", "label": "PARENT"}], "entityMentions": [{"start": 29, "text": "xss", "label": "ATTACK"}, {"start": 504, "text": "inject script", "label": "ATTACK"}, {"start": 523, "text": "reads your csrf cookie", "label": "ATTACK"}, {"start": 579, "text": "make a request to one of your api endpoints using this csrf token ", "label": "ATTACK"}], "sentText": "localstorage is subjected to xss and generally it's not recommended to store any sensitive information in it.with cookies we can apply the flag \"httponly\" which mitigates the risk of xss. however if we are to read the jwt from cookies on backend, we then are subjected to csrf. i like the xsrf double submit cookies method which mentioned in the article that @pkid169 said, but there is one thing that article doesn't tell you. you are still not protected against xss because what the attacker can do is inject script that reads your csrf cookie (which is not httponly) and then make a request to one of your api endpoints using this csrf token with jwt cookie being sent automatically. so in reality you are still susceptible to xss, it's just that attacker can't steal you jwt token for later use, but he can still make requests on your users behalf using xss.  whether you store your jwt in a localstorage or you store your xsrf-token in not http-only cookie, both can be grabbed easily by xss. even your jwt in httponly cookie can be grabbed by an advanced xss attack.  so in addition of the double submit cookies method, you must always follow best practices against xss including escaping contents. this means removing any executable code that would cause the browser to do something you don\u9225\u6a9b want it to. typically this means removing // &lt;![cdata[ tags and html attributes that cause javascript to be evaluated. "}, {"sentId": 112, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "get user information", "em2Text": "combined into a url similar to the one below", "label": "None"}, {"em1Text": "get user information", "em2Text": "with the user information from above added to the url", "label": "PARENT"}, {"em1Text": "combined into a url similar to the one below", "em2Text": "get user information", "label": "None"}, {"em1Text": "combined into a url similar to the one below", "em2Text": "with the user information from above added to the url", "label": "AND"}, {"em1Text": "with the user information from above added to the url", "em2Text": "get user information", "label": "None"}, {"em1Text": "with the user information from above added to the url", "em2Text": "combined into a url similar to the one below", "label": "None"}], "entityMentions": [{"start": 100, "text": "get user information", "label": "ATTACK"}, {"start": 139, "text": "combined into a url similar to the one below", "label": "ATTACK"}, {"start": 189, "text": "with the user information from above added to the url", "label": "ATTACK"}], "sentText": "above is the code, as it appeared on the pages. i have played around with this code and it seems to get user information using: it is then combined into a url similar to the one below, but with the user information from above added to the url "}, {"sentId": 105, "articleId": "4", "threatType": "D", "relationMentions": [{"em1Text": "no access restrictions", "em2Text": "attacked by dos etc", "label": "None"}, {"em1Text": "attacked by dos etc", "em2Text": "no access restrictions", "label": "PARENT"}], "entityMentions": [{"start": 78, "text": "no access restrictions", "label": "ATTACK"}, {"start": 130, "text": "attacked by dos etc", "label": "ATTACK"}], "sentText": "the load this server is normally subjected to is minimal, but since there are no access restrictions, the server can obviously be attacked by dos etc. "}, {"sentId": 119, "articleId": "4", "threatType": "D", "relationMentions": [], "entityMentions": [{"start": 73, "text": "decompression bomb attacks", "label": "ATTACK"}], "sentText": "i am playing with image uploads to a website and i found out about these decompression bomb attacks that can take place when it's allowed to upload [code] files (and some other). since i am going to change the uploaded images, i want to make sure i don't become a victim of this attack. so when it comes to checking if a [code] file is a bomb, can i just read the file's headers and make sure that width and height are not more than the set limit, like 4000x4000 or whatever? is it a valid method? or what is the better way to go? "}, {"sentId": 101, "articleId": "1", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 81, "text": "buffer overflow security vulnerability", "label": "ATTACK"}], "sentText": "assuming that a c# program uses only managed .net code, is it possible to have a buffer overflow security vulnerability within that program? if so, how would such vulnerability be possible? "}, {"sentId": 162, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "anyone can just change their cookie to another reasonable-looking number based on their own", "em2Text": "spoof that user", "label": "None"}, {"em1Text": "spoof that user", "em2Text": "anyone can just change their cookie to another reasonable-looking number based on their own", "label": "PARENT"}], "entityMentions": [{"start": 67, "text": "anyone can just change their cookie to another reasonable-looking number based on their own", "label": "ATTACK"}, {"start": 244, "text": "spoof that user", "label": "ATTACK"}], "sentText": "if your user id is a sequential number, this is pretty insecure as anyone can just change their cookie to another reasonable-looking number based on their own (e.g. if mine is 1274, i could try some other numbers in that range) and immediately spoof that user. "}, {"sentId": 12, "articleId": "3", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 328, "text": "xss attacks", "label": "ATTACK"}], "sentText": "i am currently in a project with a php frontend. we're pretty concerned about security, because we'll have quite a lot of users and are an attractive target for hackers. our users are able to submit html formatted content that is visible to other users later. this is a big problem because we're vulnerable for the whole set of xss attacks. we're filtering as good as we can, but the variety of attack vectors is pretty big. "}, {"sentId": 40, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "using a sha-512 hash 1000 times on a salt + password", "em2Text": "querying information about a user", "label": "None"}, {"em1Text": "using a sha-512 hash 1000 times on a salt + password", "em2Text": "passwords can be cracked", "label": "None"}, {"em1Text": "querying information about a user", "em2Text": "using a sha-512 hash 1000 times on a salt + password", "label": "PARENT"}, {"em1Text": "querying information about a user", "em2Text": "passwords can be cracked", "label": "None"}, {"em1Text": "passwords can be cracked", "em2Text": "using a sha-512 hash 1000 times on a salt + password", "label": "None"}, {"em1Text": "passwords can be cracked", "em2Text": "querying information about a user", "label": "PARENT"}], "entityMentions": [{"start": 5, "text": "using a sha-512 hash 1000 times on a salt + password", "label": "ATTACK"}, {"start": 90, "text": "querying information about a user", "label": "ATTACK"}, {"start": 185, "text": "passwords can be cracked", "label": "ATTACK"}], "sentText": "i am using a sha-512 hash 1000 times on a salt + password. is it safe to return that when querying information about a user or should i secure it and make it available only over https? passwords can be cracked. given a hash and knowledge of how the hash was constructed, you can bruteforce the relevant parameters. even though it takes 1000 times longer, and the salt might have to be bruteforced (if not included in the query response), the possibility still exists (and someone patient enough, with the right resources, might just do it if the value was high enough). don't take the risk -- just don't disclose the password in any form. "}, {"sentId": 53, "articleId": "1", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 44, "text": "someone crawls the image directories of your server", "label": "ATTACK"}], "sentText": "here comes the problem: it is possible that someone crawls the image directories of your server. but you want to protect your users from such attacks. "}, {"sentId": 72, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "access the php script they just uploaded", "em2Text": "visiting the url in their browser", "label": "None"}, {"em1Text": "access the php script they just uploaded", "em2Text": "the shell script to execute", "label": "None"}, {"em1Text": "access the php script they just uploaded", "em2Text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "label": "PARENT"}, {"em1Text": "visiting the url in their browser", "em2Text": "access the php script they just uploaded", "label": "PARENT"}, {"em1Text": "visiting the url in their browser", "em2Text": "the shell script to execute", "label": "None"}, {"em1Text": "visiting the url in their browser", "em2Text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "label": "None"}, {"em1Text": "the shell script to execute", "em2Text": "access the php script they just uploaded", "label": "None"}, {"em1Text": "the shell script to execute", "em2Text": "visiting the url in their browser", "label": "PARENT"}, {"em1Text": "the shell script to execute", "em2Text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "label": "None"}, {"em1Text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "em2Text": "access the php script they just uploaded", "label": "None"}, {"em1Text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "em2Text": "visiting the url in their browser", "label": "None"}, {"em1Text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "em2Text": "the shell script to execute", "label": "None"}], "entityMentions": [{"start": 167, "text": "access the php script they just uploaded", "label": "ATTACK"}, {"start": 211, "text": "visiting the url in their browser", "label": "ATTACK"}, {"start": 254, "text": "the shell script to execute", "label": "ATTACK"}, {"start": 283, "text": "if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it", "label": "ATTACK"}], "sentText": "you have an unprotected directory that users can upload to.they upload two files: a shell script, and a php file that has a [code] call in it to the shell script.they access the php script they just uploaded by visiting the url in their browser, causing the shell script to execute. if this directory is 777, that means that anybody (including the user apache, which is what php script will execute as) can execute it! if the execute bit is not set on that directory and presumably the files inside the directory, then step 3 above would do nothing. "}, {"sentId": 153, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 20, "text": "post to the form from another page using some nifty post-to-iframe hack it", "label": "ATTACK"}], "sentText": "if someone tries to post to the form from another page using some nifty post-to-iframe hack it will be [code], you can throw it out immediately. "}, {"sentId": 74, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 53, "text": "cross site request forgery attack", "label": "ATTACK"}], "sentText": "is checking the referrer enough to protect against a cross site request forgery attack? i know the referrer can be spoofed, but is there any way for the attacker to do that for the client? i know tokens are the norm, but would this work? "}, {"sentId": 113, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 175, "text": "which can easily be decompiled using dotpeek or any other tool", "label": "ATTACK"}], "sentText": "i want to know to secure my xamarin code specially when deploying to android. i know that xamarin.ios converts to native code but xamarin.android deploys the .net code in dll which can easily be decompiled using dotpeek or any other tool and the code will be visible including my encryption keys or any other security related data which is necessary for security between server and my app. obfuscation is an option but i want to know any other options. please guide me on this issue because it is of much concern to me. "}, {"sentId": 23, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "user is logged in", "em2Text": "access the stored keys", "label": "None"}, {"em1Text": "user is logged in", "em2Text": "injecting code into a users process", "label": "AND"}, {"em1Text": "access the stored keys", "em2Text": "user is logged in", "label": "PARENT"}, {"em1Text": "access the stored keys", "em2Text": "injecting code into a users process", "label": "None"}, {"em1Text": "injecting code into a users process", "em2Text": "user is logged in", "label": "None"}, {"em1Text": "injecting code into a users process", "em2Text": "access the stored keys", "label": "None"}], "entityMentions": [{"start": 18, "text": "user is logged in", "label": "ATTACK"}, {"start": 198, "text": "access the stored keys", "label": "ATTACK"}, {"start": 231, "text": "injecting code into a users process", "label": "ATTACK"}], "sentText": "however, once the user is logged in, there is the possibility for other users' processes on the same machine with sufficient privileges (generally only granted to administrative/system accounts) to access the stored keys, e.g. by  injecting code into a users process that will run i'm the context of the user and hence be able to do anything the user could do with the key (use it to decrypt, sign, or export the key, etc.). "}, {"sentId": 131, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "sql injections", "em2Text": "xss", "label": "None"}, {"em1Text": "xss", "em2Text": "sql injections", "label": "None"}], "entityMentions": [{"start": 187, "text": "sql injections", "label": "ATTACK"}, {"start": 254, "text": "xss", "label": "ATTACK"}], "sentText": "i'm trying to make a php application i've written secure and have a question about escaping output. i switched to using prepared statements with pdo once i learned doing so would prevent sql injections, and it seems that the other main type of attack is xss. i build the output for my pages like this (assume the variables have data from the database in them): xss preventionconverting special characters to proper html entities, for example it converts the copyright character to [code]. in html content you should use the appropriate html entity instead of inserting a raw special character. for xss prevention, you could use [link] instead, but it will only convert some basic characters to html entities, namely quotes, ampersand and the less than/greater than characters. "}, {"sentId": 110, "articleId": "6", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 29, "text": "xss attack", "label": "ATTACK"}], "sentText": "how can i protect it against xss attack. user table is in an external db, so i cannot trust it. i have tried different approaches using sanitize and h but when i replace in my local db user website by [code], javascript is still being executed when i click on the link. "}, {"sentId": 53, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 140, "text": "rainbow table attacks", "label": "ATTACK"}], "sentText": "you don't need to make salts really long and it's not important that they be cryptographically secure. the point of salts is simply to make rainbow table attacks harder as you no longer have a 1-to-1 mapping between passwords and hashes. (they also keep administrators with wandering eyes from seeing 482c811da5d5b4bc6d497ffa98491e38 in the database and then knowing joe's password is \"password123\".) "}, {"sentId": 5, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "do an md5 hash on that", "em2Text": "use that md5 generated by the salt", "label": "AND"}, {"em1Text": "do an md5 hash on that", "em2Text": "seed the password at given points in the md5sum", "label": "None"}, {"em1Text": "do an md5 hash on that", "em2Text": "get access to the md5 password list", "label": "None"}, {"em1Text": "use that md5 generated by the salt", "em2Text": "do an md5 hash on that", "label": "None"}, {"em1Text": "use that md5 generated by the salt", "em2Text": "seed the password at given points in the md5sum", "label": "None"}, {"em1Text": "use that md5 generated by the salt", "em2Text": "get access to the md5 password list", "label": "None"}, {"em1Text": "seed the password at given points in the md5sum", "em2Text": "do an md5 hash on that", "label": "PARENT"}, {"em1Text": "seed the password at given points in the md5sum", "em2Text": "use that md5 generated by the salt", "label": "PARENT"}, {"em1Text": "seed the password at given points in the md5sum", "em2Text": "get access to the md5 password list", "label": "None"}, {"em1Text": "get access to the md5 password list", "em2Text": "do an md5 hash on that", "label": "None"}, {"em1Text": "get access to the md5 password list", "em2Text": "use that md5 generated by the salt", "label": "None"}, {"em1Text": "get access to the md5 password list", "em2Text": "seed the password at given points in the md5sum", "label": "None"}], "entityMentions": [{"start": 526, "text": "do an md5 hash on that", "label": "ATTACK"}, {"start": 558, "text": "use that md5 generated by the salt", "label": "ATTACK"}, {"start": 596, "text": "seed the password at given points in the md5sum", "label": "ATTACK"}, {"start": 731, "text": "get access to the md5 password list", "label": "ATTACK"}], "sentText": "i can't find a configuration for this salt value. it seems to be relying on one already present within the password stored in the database. is there one or do i need to configure auth to do so since this login needs to be portable and reproducible? if it can't detect the salt, in the hash_password routine, it defaults to using uniqid(), which i don't believe is portable at all.in terms of adding users, does it make sense to modify the auth library to add this feature? ie, introduce my own customized salt that i can say, do an md5 hash on that and then use that md5 generated by the salt to seed the password at given points in the md5sum?i'm no security expert, but is this overkill? granted, it prevents someone who were to get access to the md5 password list from using a md5 lookup of predetermined hashes. if you have used the kohana php framework, if you have any lessons learned or experiences after using it that might give insight as to the right approach for this problem, let me know. i'm reading numerous forums and wiki's about it, and there isn't a real concrete opinion yet that i've seen. i'm essentially trying to get a reproducible approach for authenticating someone in this site, both using php and eventually from a mobile device, like an iphone. i'm also thinking of eventually adding support for google friend connect for openid support and integration. "}, {"sentId": 22, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "hard-code the exact public license key string value", "em2Text": "malicious third-parties to modify the public  license key string", "label": "None"}, {"em1Text": "malicious third-parties to modify the public  license key string", "em2Text": "hard-code the exact public license key string value", "label": "PARENT"}], "entityMentions": [{"start": 69, "text": "hard-code the exact public license key string value", "label": "ATTACK"}, {"start": 364, "text": "malicious third-parties to modify the public  license key string", "label": "ATTACK"}], "sentText": "  security recommendation: it is highly recommended that you do not  hard-code the exact public license key string value as provided by  google play. instead, you can construct the whole public license key  string at runtime from substrings, or retrieve it from an encrypted  store, before passing it to the constructor. this approach makes it  more difficult for malicious third-parties to modify the public  license key string in your apk file. "}, {"sentId": 164, "articleId": "6", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 87, "text": "possible attacks in ways to which the similar  function is not susceptible", "label": "ATTACK"}], "sentText": "  a third-party code can see the scope in which eval() was invoked,  which can lead to possible attacks in ways to which the similar  function is not susceptible.    [link] "}, {"sentId": 83, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "xss", "em2Text": "sql injections", "label": "AND"}, {"em1Text": "sql injections", "em2Text": "xss", "label": "None"}], "entityMentions": [{"start": 111, "text": "xss", "label": "ATTACK"}, {"start": 139, "text": "sql injections", "label": "ATTACK"}], "sentText": "i got these two functions from a book and the author says that by using these two, i can be extra safe against xss(the first function) and sql injections(2nd func). are all those necessary? also for sanitizing, i use prepared statements to prevent sql injections.  "}, {"sentId": 32, "articleId": "1", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 0, "text": "any variable that a user can control,  an attacker can also control", "label": "ATTACK"}], "sentText": "any variable that a user can control,  an attacker can also control and is therefore a source of an attack.  this is called a \"tainted\" variable, and is unsafe.  "}, {"sentId": 48, "articleId": "4", "threatType": "T", "relationMentions": [{"em1Text": "attached a yellow screen of death that i encountered on one of the websites", "em2Text": "xss attacks", "label": "None"}, {"em1Text": "xss attacks", "em2Text": "attached a yellow screen of death that i encountered on one of the websites", "label": "PARENT"}], "entityMentions": [{"start": 2, "text": "attached a yellow screen of death that i encountered on one of the websites", "label": "ATTACK"}, {"start": 417, "text": "xss attacks", "label": "ATTACK"}], "sentText": "i attached a yellow screen of death that i encountered on one of the websites that i created a long time ago and it sparked my interest.(the error is that it fails when attempting to cast a query string parameter to an int.  yea, i know its bad code, i wrote it many years ago ;) say, for example, you have written your own forum software. you have put in lots of validation for when the user writes posts to prevent xss attacks and such, but your validation is faulty. if a hacker can bring up the ysod when they make a post, the stack trace shown could potentially show them the cracks in your validation and exploit them to create xss attacks or obtain member details or passwords and such. "}, {"sentId": 104, "articleId": "6", "threatType": "E", "relationMentions": [], "entityMentions": [{"start": 0, "text": "apache log4j vulnerability", "label": "ATTACK"}], "sentText": "apache log4j vulnerability [link] is impacting a number of cloud services.i am using log4j in my android application.how does it impact it or is there no impact at all?i am assuming since the malicious actor could only run local scripts, it should not be an issue but i wanted to confirm. "}, {"sentId": 30, "articleId": "3", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 186, "text": "cross-site request forgery attacks (csrf)", "label": "ATTACK"}], "sentText": "  samesite cookies let servers require that a cookie shouldn't be sent with cross-site (where site is defined by the registrable domain) requests, which provides some protection against cross-site request forgery attacks (csrf). "}, {"sentId": 127, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "a rainbow table attack", "em2Text": "have knowledge of the hashes", "label": "None"}, {"em1Text": "a rainbow table attack", "em2Text": "retrieve passwords", "label": "PARENT"}, {"em1Text": "have knowledge of the hashes", "em2Text": "a rainbow table attack", "label": "None"}, {"em1Text": "have knowledge of the hashes", "em2Text": "retrieve passwords", "label": "None"}, {"em1Text": "retrieve passwords", "em2Text": "a rainbow table attack", "label": "None"}, {"em1Text": "retrieve passwords", "em2Text": "have knowledge of the hashes", "label": "PARENT"}], "entityMentions": [{"start": 128, "text": "a rainbow table attack", "label": "ATTACK"}, {"start": 156, "text": "have knowledge of the hashes", "label": "ATTACK"}, {"start": 197, "text": "retrieve passwords", "label": "ATTACK"}], "sentText": "the password hashing all takes place server side, and the hashes are stored in the database. the client has no way to see these.a rainbow table attack must have knowledge of the hashes in order to retrieve passwords. so, is the point of trying to foil a rainbow table attack simply to protect the retrieval of passwords from an already compromised database/system. is it that simple or is there something else that i am missing. "}, {"sentId": 43, "articleId": "1", "threatType": "T", "relationMentions": [{"em1Text": "xss hacks", "em2Text": "user could potentially enter javascript that another user ends up executing", "label": "PARENT"}, {"em1Text": "user could potentially enter javascript that another user ends up executing", "em2Text": "xss hacks", "label": "None"}], "entityMentions": [{"start": 31, "text": "xss hacks", "label": "ATTACK"}, {"start": 45, "text": "user could potentially enter javascript that another user ends up executing", "label": "ATTACK"}], "sentText": "this introduces a high risk of xss hacks - a user could potentially enter javascript that another user ends up executing. since we hold sensitive data it's essential that this never happens. "}, {"sentId": 1, "articleId": "1", "threatType": "I", "relationMentions": [{"em1Text": "make ajax requests to get this data", "em2Text": "url is visited with your cookies", "label": "None"}, {"em1Text": "make ajax requests to get this data", "em2Text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "label": "None"}, {"em1Text": "make ajax requests to get this data", "em2Text": "read the json content", "label": "PARENT"}, {"em1Text": "url is visited with your cookies", "em2Text": "make ajax requests to get this data", "label": "None"}, {"em1Text": "url is visited with your cookies", "em2Text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "label": "AND"}, {"em1Text": "url is visited with your cookies", "em2Text": "read the json content", "label": "None"}, {"em1Text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "em2Text": "make ajax requests to get this data", "label": "None"}, {"em1Text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "em2Text": "url is visited with your cookies", "label": "None"}, {"em1Text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "em2Text": "read the json content", "label": "None"}, {"em1Text": "read the json content", "em2Text": "make ajax requests to get this data", "label": "None"}, {"em1Text": "read the json content", "em2Text": "url is visited with your cookies", "label": "PARENT"}, {"em1Text": "read the json content", "em2Text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "label": "PARENT"}], "entityMentions": [{"start": 155, "text": "make ajax requests to get this data", "label": "ATTACK"}, {"start": 273, "text": "url is visited with your cookies", "label": "ATTACK"}, {"start": 311, "text": "by [link] they can have a method called whenever an object (array or hash) attribute is set", "label": "ATTACK"}, {"start": 421, "text": "read the json content", "label": "ATTACK"}], "sentText": "contrived example: say google has a url like [code] which returns the first 50 messages of your inbox in json format. evil websites on other domains can't make ajax requests to get this data due to the same-origin policy, but they can include the url via a [code] tag. the url is visited with your cookies, and by [link] they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the json content. "}, {"sentId": 118, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "someone to grab them", "em2Text": "reuse for unsuspicious resource server", "label": "AND"}, {"em1Text": "someone to grab them", "em2Text": "brute-force attack on the refresh_token", "label": "None"}, {"em1Text": "reuse for unsuspicious resource server", "em2Text": "someone to grab them", "label": "None"}, {"em1Text": "reuse for unsuspicious resource server", "em2Text": "brute-force attack on the refresh_token", "label": "None"}, {"em1Text": "brute-force attack on the refresh_token", "em2Text": "someone to grab them", "label": "None"}, {"em1Text": "brute-force attack on the refresh_token", "em2Text": "reuse for unsuspicious resource server", "label": "None"}], "entityMentions": [{"start": 224, "text": "someone to grab them", "label": "ATTACK"}, {"start": 250, "text": "reuse for unsuspicious resource server", "label": "ATTACK"}, {"start": 970, "text": "brute-force attack on the refresh_token", "label": "ATTACK"}], "sentText": "why should we persist short-lived access_token? so far i can think of a two reasons agains this approach. first, potentially it could be a security threat when you are keeping user's access tickes anywhere, just waiting for someone to grab them, and reuse for unsuspicious resource server (remember, they should use the same algorithm to serilize/deserialize keys). second, you would have to care about updating those persisted tickets once you decide to change any part of serialization algorithm. so, why don't we simply create new tickets in runtime once we've verified [code] and [code] instead of reading and deserializing it from database?how access_token should be encrypted, if we should persist it? will salt + sha2 on serialized ticket do the job or there is a better way?why hash refresh_token id? from what kinds of attacks it actually protects? and won't it be more secure if we'd send hashed keys as [code] while keeping real key in the database? this way brute-force attack on the refresh_token (guessing refresh token of a random user) would have to guess hashing algorithm as well. "}, {"sentId": 58, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "switch back to http for the rest of the session", "em2Text": "stay logged in", "label": "AND"}, {"em1Text": "switch back to http for the rest of the session", "em2Text": "hijack your session and send whatever requests they want", "label": "None"}, {"em1Text": "stay logged in", "em2Text": "switch back to http for the rest of the session", "label": "None"}, {"em1Text": "stay logged in", "em2Text": "hijack your session and send whatever requests they want", "label": "None"}, {"em1Text": "hijack your session and send whatever requests they want", "em2Text": "switch back to http for the rest of the session", "label": "None"}, {"em1Text": "hijack your session and send whatever requests they want", "em2Text": "stay logged in", "label": "PARENT"}], "entityMentions": [{"start": 163, "text": "switch back to http for the rest of the session", "label": "ATTACK"}, {"start": 403, "text": "stay logged in", "label": "ATTACK"}, {"start": 449, "text": "hijack your session and send whatever requests they want", "label": "ATTACK"}], "sentText": "so you've performed the login using https to prevent man in the middle attacks and make sure your password isn't sent in the clear. good call. but many sites then switch back to http for the rest of the session. once you're exchanging everything in the clear can't a man in the middle begin hijacking your session again? okay, so they don't have your password but they don't need it! for as long as you stay logged in the man in the middle can just hijack your session and send whatever requests they want. can't they? "}, {"sentId": 25, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "download the data", "em2Text": "proxy system", "label": "None"}, {"em1Text": "proxy system", "em2Text": "download the data", "label": "PARENT"}], "entityMentions": [{"start": 96, "text": "download the data", "label": "ATTACK"}, {"start": 285, "text": "proxy system", "label": "ATTACK"}], "sentText": "suppose that a data source sets a tight ip-based throttle.  would a web scraper have any way to download the data if the throttle starts rejecting their requests as early as 1% of the data being downloaded? the only technique i could think of a hacker using here would be some sort of proxy system.  but, it seems like the proxies (even if fast) would eventually all reach the throttle. "}, {"sentId": 13, "articleId": "4", "threatType": "S", "relationMentions": [{"em1Text": "phishing attacks occur", "em2Text": "using a malicious website that resembles the legitimate website", "label": "PARENT"}, {"em1Text": "using a malicious website that resembles the legitimate website", "em2Text": "phishing attacks occur", "label": "None"}], "entityMentions": [{"start": 0, "text": "phishing attacks occur", "label": "ATTACK"}, {"start": 107, "text": "using a malicious website that resembles the legitimate website", "label": "ATTACK"}], "sentText": "phishing attacks occur when a user is tricked into thinking they are using a known website but instead are using a malicious website that resembles the legitimate website. authereum, portis, and torus are username and password based login solutions so they open up the login auth window in a new popup or redirect. this allows the user to verify the domain of the website for legitimacy. google auth does this pattern as well. besides opening a new window on login for the user to verify, some web-based wallet providers also open a new window when signing messages and transactions to verify the request. "}, {"sentId": 46, "articleId": "6", "threatType": "I", "relationMentions": [{"em1Text": "database is stolen", "em2Text": "control of the user's computer", "label": "None"}, {"em1Text": "database is stolen", "em2Text": "read their cookies", "label": "None"}, {"em1Text": "database is stolen", "em2Text": "keylog their password and log in", "label": "None"}, {"em1Text": "database is stolen", "em2Text": "server is compromised", "label": "None"}, {"em1Text": "database is stolen", "em2Text": "grab the json file from the server", "label": "None"}, {"em1Text": "database is stolen", "em2Text": "access the decrypted file as it's being processed on the server", "label": "None"}, {"em1Text": "control of the user's computer", "em2Text": "database is stolen", "label": "None"}, {"em1Text": "control of the user's computer", "em2Text": "read their cookies", "label": "AND"}, {"em1Text": "control of the user's computer", "em2Text": "keylog their password and log in", "label": "None"}, {"em1Text": "control of the user's computer", "em2Text": "server is compromised", "label": "None"}, {"em1Text": "control of the user's computer", "em2Text": "grab the json file from the server", "label": "None"}, {"em1Text": "control of the user's computer", "em2Text": "access the decrypted file as it's being processed on the server", "label": "None"}, {"em1Text": "read their cookies", "em2Text": "database is stolen", "label": "None"}, {"em1Text": "read their cookies", "em2Text": "control of the user's computer", "label": "PARENT"}, {"em1Text": "read their cookies", "em2Text": "keylog their password and log in", "label": "None"}, {"em1Text": "read their cookies", "em2Text": "server is compromised", "label": "None"}, {"em1Text": "read their cookies", "em2Text": "grab the json file from the server", "label": "None"}, {"em1Text": "read their cookies", "em2Text": "access the decrypted file as it's being processed on the server", "label": "None"}, {"em1Text": "keylog their password and log in", "em2Text": "database is stolen", "label": "None"}, {"em1Text": "keylog their password and log in", "em2Text": "control of the user's computer", "label": "PARENT"}, {"em1Text": "keylog their password and log in", "em2Text": "read their cookies", "label": "None"}, {"em1Text": "keylog their password and log in", "em2Text": "server is compromised", "label": "None"}, {"em1Text": "keylog their password and log in", "em2Text": "grab the json file from the server", "label": "None"}, {"em1Text": "keylog their password and log in", "em2Text": "access the decrypted file as it's being processed on the server", "label": "None"}, {"em1Text": "server is compromised", "em2Text": "database is stolen", "label": "None"}, {"em1Text": "server is compromised", "em2Text": "control of the user's computer", "label": "None"}, {"em1Text": "server is compromised", "em2Text": "read their cookies", "label": "None"}, {"em1Text": "server is compromised", "em2Text": "keylog their password and log in", "label": "None"}, {"em1Text": "server is compromised", "em2Text": "grab the json file from the server", "label": "None"}, {"em1Text": "server is compromised", "em2Text": "access the decrypted file as it's being processed on the server", "label": "None"}, {"em1Text": "grab the json file from the server", "em2Text": "database is stolen", "label": "None"}, {"em1Text": "grab the json file from the server", "em2Text": "control of the user's computer", "label": "None"}, {"em1Text": "grab the json file from the server", "em2Text": "read their cookies", "label": "None"}, {"em1Text": "grab the json file from the server", "em2Text": "keylog their password and log in", "label": "None"}, {"em1Text": "grab the json file from the server", "em2Text": "server is compromised", "label": "PARENT"}, {"em1Text": "grab the json file from the server", "em2Text": "access the decrypted file as it's being processed on the server", "label": "None"}, {"em1Text": "access the decrypted file as it's being processed on the server", "em2Text": "database is stolen", "label": "None"}, {"em1Text": "access the decrypted file as it's being processed on the server", "em2Text": "control of the user's computer", "label": "None"}, {"em1Text": "access the decrypted file as it's being processed on the server", "em2Text": "read their cookies", "label": "None"}, {"em1Text": "access the decrypted file as it's being processed on the server", "em2Text": "keylog their password and log in", "label": "None"}, {"em1Text": "access the decrypted file as it's being processed on the server", "em2Text": "server is compromised", "label": "PARENT"}, {"em1Text": "access the decrypted file as it's being processed on the server", "em2Text": "grab the json file from the server", "label": "None"}], "entityMentions": [{"start": 353, "text": "database is stolen", "label": "ATTACK"}, {"start": 936, "text": "control of the user's computer", "label": "ATTACK"}, {"start": 975, "text": "read their cookies", "label": "ATTACK"}, {"start": 1018, "text": "keylog their password and log in", "label": "ATTACK"}, {"start": 1544, "text": "server is compromised", "label": "ATTACK"}, {"start": 1601, "text": "grab the json file from the server", "label": "ATTACK"}, {"start": 2001, "text": "access the decrypted file as it's being processed on the server", "label": "ATTACK"}], "sentText": "the current process for encrypting the data server-side i plan to use is based on [link]. summarised, it advocates encrypting each separate user's data asymmetrically with their own public key, stored on the server. the private key to decrypt this data is then itself encrypted symmetrically using the user's password, and stored. this way, even if the database is stolen, the user's password hash needs to be broken, and even then the process needs to be repeated for every user's data. the only weakness, pointed out by the author himself, and the main point of my question, is the fact that while the user is logged in, the decrypted key is stored in session storage. the way the article suggests to deal with it is to just limit the time the user is logged in. i thought a better solution would be to store that key in a short-lived secure cookie (of course the whole process is happening over https). that way, if the attacker has control of the user's computer and can read their cookies, they can probably just keylog their password and log in, no need to steal the database, while even if the attacker gains access to the server, they cannot decrypt the https traffic (or can they? i'm not sure.) my current plan is to write all this data to a json file, gzip it and upload it to the server. my question is, how do i do that while ensuring the security of the data? naturally, the upload will happen over https, and i have an api password in place to only allow authorised uploads, but my main concern is how to protect the data if the server is compromised. i don't want the attacker to just grab the json file from the server while it's being processed. one idea i had was to get the server to send me a list of public keys for the users, and perform the encryption in my software, before the upload. it seems to me like that's the only way of protecting that data. i could encrypt the whole json file, perhaps with an api key or a special password, but that's moot if the attacker can just access the decrypted file as it's being processed on the server. is that a good solution? as it happens, i am working on a similar system to encrypt personal details (email, ip) in wordpress comments, so that if the server is compromised, sensitive data in the database is still encrypted. storing an assymetric decryption key in the session was out for me, since this could leave the key on the server for an attacker to grab at the same time as their compromising it. "}, {"sentId": 61, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "running your build", "em2Text": "have access to everything else going on for that user, and that includes other projects", "label": "None"}, {"em1Text": "running your build", "em2Text": "[code] ", "label": "None"}, {"em1Text": "running your build", "em2Text": "man-in-the-middle attacks", "label": "None"}, {"em1Text": "have access to everything else going on for that user, and that includes other projects", "em2Text": "running your build", "label": "PARENT"}, {"em1Text": "have access to everything else going on for that user, and that includes other projects", "em2Text": "[code] ", "label": "None"}, {"em1Text": "have access to everything else going on for that user, and that includes other projects", "em2Text": "man-in-the-middle attacks", "label": "None"}, {"em1Text": "[code] ", "em2Text": "running your build", "label": "None"}, {"em1Text": "[code] ", "em2Text": "have access to everything else going on for that user, and that includes other projects", "label": "None"}, {"em1Text": "[code] ", "em2Text": "man-in-the-middle attacks", "label": "None"}, {"em1Text": "man-in-the-middle attacks", "em2Text": "running your build", "label": "None"}, {"em1Text": "man-in-the-middle attacks", "em2Text": "have access to everything else going on for that user, and that includes other projects", "label": "None"}, {"em1Text": "man-in-the-middle attacks", "em2Text": "[code] ", "label": "PARENT"}], "entityMentions": [{"start": 204, "text": "running your build", "label": "ATTACK"}, {"start": 228, "text": "have access to everything else going on for that user, and that includes other projects", "label": "ATTACK"}, {"start": 60, "text": "[code] ", "label": "ATTACK"}, {"start": 341, "text": "man-in-the-middle attacks", "label": "ATTACK"}], "sentText": "the security concerns you should have are mainly from using [code] and [code] runners. [code] is unsafe unless you're in a controlled environment.this is because it's, literally, a simple shell. the user running your build will have access to everything else going on for that user, and that includes other projects.[code] is susceptible to man-in-the-middle attacks.if you're dealing with private crypto keys in your builds, beware that they may be stolen. fortunately, [link] seems to be sharing only [code] runners.[code] runners are generally safe* because every build runs in a new container, so there's nothing to worry. * unless you're doing the nasty [code] mode! "}, {"sentId": 10, "articleId": "3", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 161, "text": "extract the key from the javascript on the page and use it", "label": "ATTACK"}], "sentText": "the problem is, that the web app (official website) is also a client of the api itself, thus would have to expose its api key. as a result, some user could just extract the key from the javascript on the page and use it, instead of generating his own key. "}, {"sentId": 9, "articleId": "3", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 0, "text": "sql injection", "label": "ATTACK"}], "sentText": "sql injection (owasp a-1)  sql injection is still a concern.buffer overflow is normally prevented by the clr, but is more possible if using non-managed code mixed in with managed code.net code can be decompiled, so storing sensitive info in code, as opposed to encrypted in the app.config... things you should watch, is that it's really hard to completely secure your data layer, when a desktop application connects directly to a database. for instance, sql injection is not an issue for your desktop application in this case, since when the application can directly connect to the database, so can the user. and if the user can connect to the database, he can execute any arbitrary query. this is an extreme form of sql injection, but it completely skips your application. "}, {"sentId": 23, "articleId": "1", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 10, "text": "json hijacking attacks", "label": "ATTACK"}], "sentText": "are these json hijacking attacks still an issue today in modern browsers? "}, {"sentId": 125, "articleId": "4", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 25, "text": "intercept my post data just by listening for it", "label": "ATTACK"}], "sentText": "can anyone from anywhere intercept my post data just by listening for it, perhaps with some third party software like firesheep?   can anyone from anywhere intercept my post data just by listening for it, perhaps with some third party software like firesheep? "}, {"sentId": 84, "articleId": "4", "threatType": "T", "relationMentions": [], "entityMentions": [{"start": 16, "text": "an sql injection attempt", "label": "ATTACK"}], "sentText": "clearly this is an sql injection attempt. but why the constant shown above? i can't see how it could be particularly significant, though it seems to appear quite frequently. "}, {"sentId": 66, "articleId": "2", "threatType": "I", "relationMentions": [{"em1Text": "decompile my apk", "em2Text": "retrieve this \"somesecretphrase\" ", "label": "None"}, {"em1Text": "decompile my apk", "em2Text": "access the server", "label": "None"}, {"em1Text": "retrieve this \"somesecretphrase\" ", "em2Text": "decompile my apk", "label": "PARENT"}, {"em1Text": "retrieve this \"somesecretphrase\" ", "em2Text": "access the server", "label": "None"}, {"em1Text": "access the server", "em2Text": "decompile my apk", "label": "None"}, {"em1Text": "access the server", "em2Text": "retrieve this \"somesecretphrase\" ", "label": "PARENT"}], "entityMentions": [{"start": 168, "text": "decompile my apk", "label": "ATTACK"}, {"start": 210, "text": "retrieve this \"somesecretphrase\" ", "label": "ATTACK"}, {"start": 291, "text": "access the server", "label": "ATTACK"}], "sentText": "now, the question is - is it a safe approach regarding the reverse engineering? for now i can think of no other possibility to get this data. but if someone is able to decompile my apk, he will be also able to retrieve this \"somesecretphrase\" (rather hard to do on the server side) and then access the server, isn't he? is it a real threat? is there any other possibility to authenticate my app by the server? "}, {"sentId": 147, "articleId": "6", "threatType": "S", "relationMentions": [{"em1Text": "decompile my app", "em2Text": "register and then \"scan\" my entire database", "label": "AND"}, {"em1Text": "decompile my app", "em2Text": "sending requests with different gps data", "label": "PARENT"}, {"em1Text": "decompile my app", "em2Text": "gaining access to the api", "label": "None"}, {"em1Text": "decompile my app", "em2Text": "use his login information along with the key from the code", "label": "None"}, {"em1Text": "register and then \"scan\" my entire database", "em2Text": "decompile my app", "label": "None"}, {"em1Text": "register and then \"scan\" my entire database", "em2Text": "sending requests with different gps data", "label": "None"}, {"em1Text": "register and then \"scan\" my entire database", "em2Text": "gaining access to the api", "label": "None"}, {"em1Text": "register and then \"scan\" my entire database", "em2Text": "use his login information along with the key from the code", "label": "None"}, {"em1Text": "sending requests with different gps data", "em2Text": "decompile my app", "label": "None"}, {"em1Text": "sending requests with different gps data", "em2Text": "register and then \"scan\" my entire database", "label": "None"}, {"em1Text": "sending requests with different gps data", "em2Text": "gaining access to the api", "label": "None"}, {"em1Text": "sending requests with different gps data", "em2Text": "use his login information along with the key from the code", "label": "None"}, {"em1Text": "gaining access to the api", "em2Text": "decompile my app", "label": "PARENT"}, {"em1Text": "gaining access to the api", "em2Text": "register and then \"scan\" my entire database", "label": "None"}, {"em1Text": "gaining access to the api", "em2Text": "sending requests with different gps data", "label": "None"}, {"em1Text": "gaining access to the api", "em2Text": "use his login information along with the key from the code", "label": "None"}, {"em1Text": "use his login information along with the key from the code", "em2Text": "decompile my app", "label": "None"}, {"em1Text": "use his login information along with the key from the code", "em2Text": "register and then \"scan\" my entire database", "label": "None"}, {"em1Text": "use his login information along with the key from the code", "em2Text": "sending requests with different gps data", "label": "None"}, {"em1Text": "use his login information along with the key from the code", "em2Text": "gaining access to the api", "label": "PARENT"}], "entityMentions": [{"start": 31, "text": "decompile my app", "label": "ATTACK"}, {"start": 49, "text": "register and then \"scan\" my entire database", "label": "ATTACK"}, {"start": 103, "text": "sending requests with different gps data", "label": "ATTACK"}, {"start": 351, "text": "gaining access to the api", "label": "ATTACK"}, {"start": 419, "text": "use his login information along with the key from the code", "label": "ATTACK"}], "sentText": "however, i fear somebody might decompile my app, register and then \"scan\" my entire database by simply sending requests with different gps data that doesn't actually come from an ios device. is there any way to prevent this? i've googled already and found this threat: i've looked into api keys but didn't find a way how to stop a malicious user from gaining access to the api through registering/ decompiling and then use his login information along with the key from the code. "}, {"sentId": 60, "articleId": "6", "threatType": "E", "relationMentions": [], "entityMentions": [{"start": 80, "text": "freezer attack", "label": "ATTACK"}], "sentText": "is there any way to protect encryption keys that are being stored in ram from a freezer attack? (sticking the computer in a freezer before rebooting malicious code to access the contents of ram) "}, {"sentId": 54, "articleId": "1", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 11, "text": "evil people can do bad things if they identify your public key", "label": "ATTACK"}], "sentText": "presumably evil people can do bad things if they identify your public key. google seems to think so, apparently. i can guess what this step does, but i'm not sure i really want to speculate on that in an open forum, and give anyone any ideas.  you want to do it though. "}, {"sentId": 126, "articleId": "4", "threatType": "S", "relationMentions": [], "entityMentions": [{"start": 31, "text": "csrf", "label": "ATTACK"}], "sentText": "i'm trying to implement secure csrf protection to html login form,i know the best way to implement csrf protection is storing random csrf_key in a session,but i want to add csrf to my login &amp; register forms... and i do not want to store many sessions for any anonymous unregistered users... so i want to create the best secure posibble without using sessions or database, with only form hidden field /&amp; a cookie, and after the login i will use sessions csrf protection. my idea of secured user_storage only csrf: csrf_token= aes(ip+useragent+timestamp+random_data, csrf_aes_site_key) when csrf_aes_site_key is hard-coded in config file.and after every login/register i will decrypt the aes string + velidate that the ip&amp;ua is matching the request ip&amp;ua, and timestamp is not too match ahead, let say 5 min (if csrf_timestamp + 18000>=current_ts), and random_data is just randomness (and make sure that the same user will not get the same csrf_token if requested multiple times in the same ts)... issue 1:user may take the csrf_token and submit to the form successfuly using the same token for the next 5minbug? what do i care if the user submit many times? as long as it not csrf attack... can you spot any specific security risk with this implementation? or can i assume this is a secure way of doing csrf protection? the method with storing the csrf token in cookie is quite widely used ([link], [link]) but it works a bit differently. the server sends the token in cookie, the client uses javascript to read the cookie and reflect the token in a http header. the server should only verify the value from the http header, even though the cookie will be sent automatically as well. this prevents csrf because only javascript running from the authentic origin will be able to read the cookie (see [link] on wikipedia). the token can be a hmac of the session cookie, which avoids the need to remember token state on the server side. the main advantage is that this approach (unlike the one with token in form fields) works with single-page, javascript based applications where you don't generate the html on the server and can't really embed the csrf token in their code. "}, {"sentId": 112, "articleId": "6", "threatType": "E", "relationMentions": [], "entityMentions": [{"start": 69, "text": "the latest log4j exploit", "label": "ATTACK"}], "sentText": "i am trying to make sure my jenkins instance is not exploitable with the latest log4j exploit.i have a pipeline script that runs, i tried following this instruction :[link]this is one of my stages of my pipeline script:[code]but i get a different error than what's described here and i'm unsure if i'm checking this correctly.  this is the error:[code] "}, {"sentId": 53, "articleId": "4", "threatType": "I", "relationMentions": [{"em1Text": "cycript technology", "em2Text": "all ios application are able to debug", "label": "AND"}, {"em1Text": "cycript technology", "em2Text": "able to access variables and methods inside application", "label": "None"}, {"em1Text": "cycript technology", "em2Text": "overwrite the runtime variables and methods", "label": "None"}, {"em1Text": "all ios application are able to debug", "em2Text": "cycript technology", "label": "None"}, {"em1Text": "all ios application are able to debug", "em2Text": "able to access variables and methods inside application", "label": "AND"}, {"em1Text": "all ios application are able to debug", "em2Text": "overwrite the runtime variables and methods", "label": "None"}, {"em1Text": "able to access variables and methods inside application", "em2Text": "cycript technology", "label": "None"}, {"em1Text": "able to access variables and methods inside application", "em2Text": "all ios application are able to debug", "label": "None"}, {"em1Text": "able to access variables and methods inside application", "em2Text": "overwrite the runtime variables and methods", "label": "None"}, {"em1Text": "overwrite the runtime variables and methods", "em2Text": "cycript technology", "label": "None"}, {"em1Text": "overwrite the runtime variables and methods", "em2Text": "all ios application are able to debug", "label": "None"}, {"em1Text": "overwrite the runtime variables and methods", "em2Text": "able to access variables and methods inside application", "label": "PARENT"}], "entityMentions": [{"start": 9, "text": "cycript technology", "label": "ATTACK"}, {"start": 29, "text": "all ios application are able to debug", "label": "ATTACK"}, {"start": 71, "text": "able to access variables and methods inside application", "label": "ATTACK"}, {"start": 156, "text": "overwrite the runtime variables and methods", "label": "ATTACK"}], "sentText": "with the cycript technology, all ios application are able to debug and able to access variables and methods inside application.  and also it is possible to overwrite the runtime variables and methods.    with the cycript technology, all ios application are able to debug and able to access variables and methods inside application. and also it is possible to overwrite the runtime variables and methods. "}, {"sentId": 47, "articleId": "6", "threatType": "T", "relationMentions": [{"em1Text": "ssh password was cracked", "em2Text": "it installed a new index file in each and every folder", "label": "None"}, {"em1Text": "it installed a new index file in each and every folder", "em2Text": "ssh password was cracked", "label": "PARENT"}], "entityMentions": [{"start": 73, "text": "ssh password was cracked", "label": "ATTACK"}, {"start": 102, "text": "it installed a new index file in each and every folder", "label": "ATTACK"}], "sentText": "update: it actually wasn't my website that got hacked, yet the host. the ssh password was cracked and it installed a new index file in each and every folder. "}, {"sentId": 35, "articleId": "3", "threatType": "I", "relationMentions": [{"em1Text": "passwords will be revealed", "em2Text": "a compromised server", "label": "PARENT"}, {"em1Text": "a compromised server", "em2Text": "passwords will be revealed", "label": "None"}], "entityMentions": [{"start": 299, "text": "passwords will be revealed", "label": "ATTACK"}, {"start": 419, "text": "a compromised server", "label": "ATTACK"}], "sentText": "i am planning to aes_encrypt the passwords in the db, which means that if somebody is somehow able to access the db they won't be able to get the plaintext. however my code will need to have access to the key to unencrypt them, thus if the entire server is compromised this is no protection and the passwords will be revealed.  i know that whatever i do, ultimately the passwords must be accessible in plaintext and so a compromised server means the passwords will be revealed, but i am wondering what steps i can do to mitigate my risk. e.g. encrypting the db protects me in the situation where the db is compromised but not the entire server. other similar mitigating steps would be much appreciated. "}, {"sentId": 59, "articleId": "2", "threatType": "I", "relationMentions": [], "entityMentions": [{"start": 0, "text": "inspect any (user) process memoryread local (user) files", "label": "ATTACK"}], "sentText": "inspect any (user) process memoryread local (user) files "}, {"sentId": 89, "articleId": "1", "threatType": "D", "relationMentions": [{"em1Text": "create a 100timessha512 function", "em2Text": "dos vulnerability", "label": "None"}, {"em1Text": "dos vulnerability", "em2Text": "create a 100timessha512 function", "label": "PARENT"}], "entityMentions": [{"start": 150, "text": "create a 100timessha512 function", "label": "ATTACK"}, {"start": 267, "text": "dos vulnerability", "label": "ATTACK"}], "sentText": "so, i wonder whether adding it every time adds some strength to the hash. for example, would it be possible that an attacker found some clever way to create a 100timessha512 function which were way faster than simply executing sha512 100 times? yes, it does expose a dos vulnerability, but it also prevents brute force attacks (or at least makes them prohibitively slow).  there is absolutely a tradeoff, but to some the benefits exceed the risks... "}, {"sentId": 98, "articleId": "6", "threatType": "E", "relationMentions": [{"em1Text": "allow an attacker to predict boot time of the machine", "em2Text": "being able to grant control over it", "label": "None"}, {"em1Text": "being able to grant control over it", "em2Text": "allow an attacker to predict boot time of the machine", "label": "PARENT"}], "entityMentions": [{"start": 307, "text": "allow an attacker to predict boot time of the machine", "label": "ATTACK"}, {"start": 366, "text": "being able to grant control over it", "label": "ATTACK"}], "sentText": "we've hired a security consultant to perform a pentest on our application's public ip (kubernetes loadbalancer) and write a report on our security flaws and the measurements required to avoid them. their report warned us that we have tcp timestamp enabled, and from what i've read about the issue, it would allow an attacker to predict boot time of the machine thus being able to grant control over it. "}, {"sentId": 90, "articleId": "1", "threatType": "S", "relationMentions": [{"em1Text": "a security vulnerability to read php source", "em2Text": "string dumps from a security breach", "label": "OR"}, {"em1Text": "string dumps from a security breach", "em2Text": "a security vulnerability to read php source", "label": "None"}], "entityMentions": [{"start": 92, "text": "a security vulnerability to read php source", "label": "ATTACK"}, {"start": 216, "text": "string dumps from a security breach", "label": "ATTACK"}], "sentText": "make the file unreadable via the web using rules in .htaccess (in case php fails or there's a security vulnerability to read php source)destroy the password in memory after the db connect is made (unset) (to prevent string dumps from a security breach, injection, etc.)  "}]