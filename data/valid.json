[
  {
    "sentId": 95,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "performs a memory dump",
        "em2Text": "information is compromised",
        "label": "None"
      },
      {
        "em1Text": "information is compromised",
        "em2Text": "performs a memory dump",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 112,
        "text": "performs a memory dump",
        "label": "ATTACK"
      },
      {
        "start": 142,
        "text": "information is compromised",
        "label": "ATTACK"
      }
    ],
    "sentText": "heap inspection is about sensitive information stored in the machine memory unencrypted, so that if an attacker performs a memory dump , that information is compromised. thus, simply holding that information makes it vulnerable. "
  },
  {
    "sentId": 51,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "make some simple get request (by [link])",
        "em2Text": "download the page containing the antiforgery token in a hidden input field",
        "label": "None"
      },
      {
        "em1Text": "make some simple get request (by [link])",
        "em2Text": "extracts it",
        "label": "None"
      },
      {
        "em1Text": "make some simple get request (by [link])",
        "em2Text": "use it to make a valid [link]",
        "label": "None"
      },
      {
        "em1Text": "download the page containing the antiforgery token in a hidden input field",
        "em2Text": "make some simple get request (by [link])",
        "label": "PARENT"
      },
      {
        "em1Text": "download the page containing the antiforgery token in a hidden input field",
        "em2Text": "extracts it",
        "label": "None"
      },
      {
        "em1Text": "download the page containing the antiforgery token in a hidden input field",
        "em2Text": "use it to make a valid [link]",
        "label": "None"
      },
      {
        "em1Text": "extracts it",
        "em2Text": "make some simple get request (by [link])",
        "label": "None"
      },
      {
        "em1Text": "extracts it",
        "em2Text": "download the page containing the antiforgery token in a hidden input field",
        "label": "PARENT"
      },
      {
        "em1Text": "extracts it",
        "em2Text": "use it to make a valid [link]",
        "label": "None"
      },
      {
        "em1Text": "use it to make a valid [link]",
        "em2Text": "make some simple get request (by [link])",
        "label": "None"
      },
      {
        "em1Text": "use it to make a valid [link]",
        "em2Text": "download the page containing the antiforgery token in a hidden input field",
        "label": "None"
      },
      {
        "em1Text": "use it to make a valid [link]",
        "em2Text": "extracts it",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 42,
        "text": "make some simple get request (by [link])",
        "label": "ATTACK"
      },
      {
        "start": 95,
        "text": "download the page containing the antiforgery token in a hidden input field",
        "label": "ATTACK"
      },
      {
        "start": 171,
        "text": "extracts it",
        "label": "ATTACK"
      },
      {
        "start": 188,
        "text": "use it to make a valid [link]",
        "label": "ATTACK"
      }
    ],
    "sentText": "but what if a malicious script will first make some simple get request (by [link]) in order to download the page containing the antiforgery token in a hidden input field, extracts it, and use it to make a valid [link]?  "
  },
  {
    "sentId": 61,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "creating a forum software using php and mysql backend",
        "em2Text": "user input for forum posts.",
        "label": "None"
      },
      {
        "em1Text": "user input for forum posts.",
        "em2Text": "creating a forum software using php and mysql backend",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 5,
        "text": "creating a forum software using php and mysql backend",
        "label": "ATTACK"
      },
      {
        "start": 115,
        "text": "user input for forum posts.",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am creating a forum software using php and mysql backend, and want to know what is the most secure way to escape user input for forum posts. "
  },
  {
    "sentId": 6,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "enters the password",
        "em2Text": "the same hash is generated",
        "label": "None"
      },
      {
        "em1Text": "enters the password",
        "em2Text": "access the file",
        "label": "None"
      },
      {
        "em1Text": "the same hash is generated",
        "em2Text": "enters the password",
        "label": "PARENT"
      },
      {
        "em1Text": "the same hash is generated",
        "em2Text": "access the file",
        "label": "None"
      },
      {
        "em1Text": "access the file",
        "em2Text": "enters the password",
        "label": "None"
      },
      {
        "em1Text": "access the file",
        "em2Text": "the same hash is generated",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 149,
        "text": "enters the password",
        "label": "ATTACK"
      },
      {
        "start": 177,
        "text": "the same hash is generated",
        "label": "ATTACK"
      },
      {
        "start": 129,
        "text": "access the file",
        "label": "ATTACK"
      }
    ],
    "sentText": "to save a file i defined the following method[code]this returns a hashvalue that is stored in a file. whenever the user wants to access the file, he enters the password, and if the same hash is generated, he can access the file.i suppose this isn't really safe, but how safe it is? how high is the chance that string#hashcode generates the same hash with two different inputs?edit:according to your answers i changed the code:[code]so it should be better now?? "
  },
  {
    "sentId": 52,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "csrf",
        "em2Text": "automated attacks",
        "label": "AND"
      },
      {
        "em1Text": "automated attacks",
        "em2Text": "csrf",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 57,
        "text": "csrf",
        "label": "ATTACK"
      },
      {
        "start": 66,
        "text": "automated attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i used new session for each page as defense against both csrf and automated attacks. lets say we have forum that uses ajax to post threads and its validated by php session. every thing works fine until the user opens page.php?id=456 on another tab, the ajax returns 'invalid request' on ajax.php?id=123 [link]. they suggested to use only one session hash all the time, until he/she logs out - only then the session is regenerated. if the token is the same user could simply bypass it and do the automated attacks. any ideas on that?  it sounds like your objection to letting the session stay open as long as the browser is open is the issue of automated attacks. unfortunately, refreshing the token on each page load only deters the most amateur attackers. this method of changing the token on each page load would do absolutely nothing to stop someone who actually wanted to attack you all that badly. therefore, since the token has no effect on automation, focus on its effects on csrf. from the perspective of blocking csrf, creating one token and maintaining it until the user closes the browser seems to accomplish all goals. simple csrf attacks are defeated, and the user is able to open multiple tabs. the first token will stay the same until the browser session ends. this token exists to prevent csrf attacks. any submission from this user with this token will be accepted. this way, if i open a tab to form a and a tab to form b, each one has my personal anti-csrf token (csrf taken care of), and my one-time form token (form resubmission taken care of). both issues are resolved without any ill effect on the user experience. "
  },
  {
    "sentId": 86,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "malicious website takes advantage of your authenticated state on another website",
        "em2Text": "perform fraudulent cross-site requests",
        "label": "None"
      },
      {
        "em1Text": "perform fraudulent cross-site requests",
        "em2Text": "malicious website takes advantage of your authenticated state on another website",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 81,
        "text": "malicious website takes advantage of your authenticated state on another website",
        "label": "ATTACK"
      },
      {
        "start": 166,
        "text": "perform fraudulent cross-site requests",
        "label": "ATTACK"
      }
    ],
    "sentText": "both [code] and [code] are used to describe what's called a [code]. it's where a malicious website takes advantage of your authenticated state on another website, to perform fraudulent cross-site requests.  "
  },
  {
    "sentId": 12,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "use grep like functionality",
        "em2Text": "identify all sinks in an application",
        "label": "None"
      },
      {
        "em1Text": "use grep like functionality",
        "em2Text": "an attacker can see [code]",
        "label": "PARENT"
      },
      {
        "em1Text": "identify all sinks in an application",
        "em2Text": "use grep like functionality",
        "label": "PARENT"
      },
      {
        "em1Text": "identify all sinks in an application",
        "em2Text": "an attacker can see [code]",
        "label": "None"
      },
      {
        "em1Text": "an attacker can see [code]",
        "em2Text": "use grep like functionality",
        "label": "None"
      },
      {
        "em1Text": "an attacker can see [code]",
        "em2Text": "identify all sinks in an application",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 189,
        "text": "use grep like functionality",
        "label": "ATTACK"
      },
      {
        "start": 220,
        "text": "identify all sinks in an application",
        "label": "ATTACK"
      },
      {
        "start": 556,
        "text": "an attacker can see [code]",
        "label": "ATTACK"
      }
    ],
    "sentText": "most of these function calls are classified as sinks. when a tainted variable (like $_request) is passed to a sink function, then you have a vulnerability.  programs like [link] and [link] use grep like functionality to identify all sinks in an application.  this means that programmers should take extra care when using these functions,  but if they where all banned then you wouldn't be able to get much done.   most of these function calls are not sinks.   but rather it maybe a vulnerability if any of the data returned is viewable to an attacker.  if an attacker can see [code] it is definitely a vulnerability.  "
  },
  {
    "sentId": 89,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss injections",
        "em2Text": "sql injection",
        "label": "AND"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "xss injections",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "xss injections",
        "label": "ATTACK"
      },
      {
        "start": 15,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "xss injections sql injection this is only a brief overview of what you can do with sql injection. to protect yourself, use mysql_real_escape_string or pdo or any good db abstraction layer. "
  },
  {
    "sentId": 21,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "access to private fields",
        "em2Text": "inspection and modification of internal data is possible",
        "label": "None"
      },
      {
        "em1Text": "access to private fields",
        "em2Text": "lead to various malicious exploits",
        "label": "None"
      },
      {
        "em1Text": "inspection and modification of internal data is possible",
        "em2Text": "access to private fields",
        "label": "PARENT"
      },
      {
        "em1Text": "inspection and modification of internal data is possible",
        "em2Text": "lead to various malicious exploits",
        "label": "None"
      },
      {
        "em1Text": "lead to various malicious exploits",
        "em2Text": "access to private fields",
        "label": "None"
      },
      {
        "em1Text": "lead to various malicious exploits",
        "em2Text": "inspection and modification of internal data is possible",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 219,
        "text": "access to private fields",
        "label": "ATTACK"
      },
      {
        "start": 250,
        "text": "inspection and modification of internal data is possible",
        "label": "ATTACK"
      },
      {
        "start": 315,
        "text": "lead to various malicious exploits",
        "label": "ATTACK"
      }
    ],
    "sentText": "reflection can not be turned off altogether; it's always possible to reflect on its own public fields/methods. reflection on private structures with [code] can however be disabled, because it breaks encapsulation. with access to private fields, etc. inspection and modification of internal data is possible. it can lead to various malicious exploits, e.g.  "
  },
  {
    "sentId": 11,
    "articleId": "1",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "build a rainbow table",
        "em2Text": "taking a particular salt string into account",
        "label": "AND"
      },
      {
        "em1Text": "build a rainbow table",
        "em2Text": "crack one account at a time",
        "label": "None"
      },
      {
        "em1Text": "build a rainbow table",
        "em2Text": "database is compromised",
        "label": "None"
      },
      {
        "em1Text": "build a rainbow table",
        "em2Text": "salts file will be compromised",
        "label": "None"
      },
      {
        "em1Text": "taking a particular salt string into account",
        "em2Text": "build a rainbow table",
        "label": "None"
      },
      {
        "em1Text": "taking a particular salt string into account",
        "em2Text": "crack one account at a time",
        "label": "None"
      },
      {
        "em1Text": "taking a particular salt string into account",
        "em2Text": "database is compromised",
        "label": "PARENT"
      },
      {
        "em1Text": "taking a particular salt string into account",
        "em2Text": "salts file will be compromised",
        "label": "None"
      },
      {
        "em1Text": "crack one account at a time",
        "em2Text": "build a rainbow table",
        "label": "PARENT"
      },
      {
        "em1Text": "crack one account at a time",
        "em2Text": "taking a particular salt string into account",
        "label": "None"
      },
      {
        "em1Text": "crack one account at a time",
        "em2Text": "database is compromised",
        "label": "None"
      },
      {
        "em1Text": "crack one account at a time",
        "em2Text": "salts file will be compromised",
        "label": "None"
      },
      {
        "em1Text": "database is compromised",
        "em2Text": "build a rainbow table",
        "label": "None"
      },
      {
        "em1Text": "database is compromised",
        "em2Text": "taking a particular salt string into account",
        "label": "None"
      },
      {
        "em1Text": "database is compromised",
        "em2Text": "crack one account at a time",
        "label": "None"
      },
      {
        "em1Text": "database is compromised",
        "em2Text": "salts file will be compromised",
        "label": "None"
      },
      {
        "em1Text": "salts file will be compromised",
        "em2Text": "build a rainbow table",
        "label": "None"
      },
      {
        "em1Text": "salts file will be compromised",
        "em2Text": "taking a particular salt string into account",
        "label": "None"
      },
      {
        "em1Text": "salts file will be compromised",
        "em2Text": "crack one account at a time",
        "label": "None"
      },
      {
        "em1Text": "salts file will be compromised",
        "em2Text": "database is compromised",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 162,
        "text": "build a rainbow table",
        "label": "ATTACK"
      },
      {
        "start": 185,
        "text": "taking a particular salt string into account",
        "label": "ATTACK"
      },
      {
        "start": 242,
        "text": "crack one account at a time",
        "label": "ATTACK"
      },
      {
        "start": 115,
        "text": "database is compromised",
        "label": "ATTACK"
      },
      {
        "start": 622,
        "text": "salts file will be compromised",
        "label": "ATTACK"
      }
    ],
    "sentText": "however, some people recommend that the salt be stored separately from the database. their argument is that if the database is compromised, an attacker can still build a rainbow table, taking a particular salt string into account in order to crack one account at a time. if this account has admin privileges, then he may not even need to crack any others. from a security perspective, is it worth it to store salts in a different place? consider a web application with the server code and db on the same machine. if the salts are stored in a flat file on that machine, chances are that if the database is compromised, the salts file will be compromised, too.  "
  },
  {
    "sentId": 60,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "inspect the requests being made by a legitimate client",
        "em2Text": "steal the oauth client_id",
        "label": "AND"
      },
      {
        "em1Text": "inspect the requests being made by a legitimate client",
        "em2Text": "construct any request they want to impersonate the legitimate client",
        "label": "None"
      },
      {
        "em1Text": "steal the oauth client_id",
        "em2Text": "inspect the requests being made by a legitimate client",
        "label": "None"
      },
      {
        "em1Text": "steal the oauth client_id",
        "em2Text": "construct any request they want to impersonate the legitimate client",
        "label": "None"
      },
      {
        "em1Text": "construct any request they want to impersonate the legitimate client",
        "em2Text": "inspect the requests being made by a legitimate client",
        "label": "None"
      },
      {
        "em1Text": "construct any request they want to impersonate the legitimate client",
        "em2Text": "steal the oauth client_id",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 46,
        "text": "inspect the requests being made by a legitimate client",
        "label": "ATTACK"
      },
      {
        "start": 116,
        "text": "steal the oauth client_id",
        "label": "ATTACK"
      },
      {
        "start": 179,
        "text": "construct any request they want to impersonate the legitimate client",
        "label": "ATTACK"
      }
    ],
    "sentText": "the major concern i have is that anyone could inspect the requests being made by a legitimate client to the api and steal the oauth client_id. at that point they would be able to construct any request they want to impersonate the legitimate client. "
  },
  {
    "sentId": 72,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 148,
        "text": "insert backdoor or intentionally alter some security features",
        "label": "ATTACK"
      }
    ],
    "sentText": "my aim is creating an enviroment for developing applications managing sensible data: credit cards, passwords, and so on...a malicious developer may insert backdoor or intentionally alter some security features. so the access to the source code should be controlled strictly.i must confess that my knowledge of version control systems is poor, so, i fear, customizing svn could be a hard task for me. "
  },
  {
    "sentId": 158,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "accessing/modifying/creating any files outside of their folder",
        "em2Text": "connecting to the internet/downloading/sending data",
        "label": "AND"
      },
      {
        "em1Text": "connecting to the internet/downloading/sending data",
        "em2Text": "accessing/modifying/creating any files outside of their folder",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 379,
        "text": "accessing/modifying/creating any files outside of their folder",
        "label": "ATTACK"
      },
      {
        "start": 446,
        "text": "connecting to the internet/downloading/sending data",
        "label": "ATTACK"
      }
    ],
    "sentText": "i want to allow users to make their own python \"mods\" for my game, by placing their scripts in a special folder which the game \"scans\" for python modules and imports.what would be the simplest way to prevent \"dangerous\" scripts from being imported? i don't want people complaining to me that they used someone's mod and it erased their hard drive.things i would like to limit is accessing/modifying/creating any files outside of their folder and connecting to the internet/downloading/sending data. if you can thik of anything else, let me know. "
  },
  {
    "sentId": 76,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "gets access to the htdigest file",
        "em2Text": "use it directly for digest authentication",
        "label": "None"
      },
      {
        "em1Text": "use it directly for digest authentication",
        "em2Text": "gets access to the htdigest file",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 638,
        "text": "gets access to the htdigest file",
        "label": "ATTACK"
      },
      {
        "start": 678,
        "text": "use it directly for digest authentication",
        "label": "ATTACK"
      }
    ],
    "sentText": "with basic authentication the password is sent nearly plain (base64 encoded) to the server and on the server side it gets hashed and compared against the hashed password (stored in htpasswd file or similar). with digest authentication the hashed password is sent to the server (with some server defined data added so replay attacks will not work). but to verify the password you need to have the plain password on the server side (or something close to the plain password). this means, that if the attacker gets access to the htpasswd file it needs to crack all the passwords before they can be used for basic authentication, while if it gets access to the htdigest file it can use it directly for digest authentication. "
  },
  {
    "sentId": 91,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "crack open the extension",
        "em2Text": "use/abuse my api key",
        "label": "None"
      },
      {
        "em1Text": "crack open the extension",
        "em2Text": "get it revoked",
        "label": "None"
      },
      {
        "em1Text": "use/abuse my api key",
        "em2Text": "crack open the extension",
        "label": "PARENT"
      },
      {
        "em1Text": "use/abuse my api key",
        "em2Text": "get it revoked",
        "label": "None"
      },
      {
        "em1Text": "get it revoked",
        "em2Text": "crack open the extension",
        "label": "None"
      },
      {
        "em1Text": "get it revoked",
        "em2Text": "use/abuse my api key",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 39,
        "text": "crack open the extension",
        "label": "ATTACK"
      },
      {
        "start": 221,
        "text": "use/abuse my api key",
        "label": "ATTACK"
      },
      {
        "start": 252,
        "text": "get it revoked",
        "label": "ATTACK"
      }
    ],
    "sentText": "my concern is that any user could just crack open the extension and pull out these values if i include them in the published extension. this may or may not pose a security rise for the user, but he or she could certainly use/abuse my api key and maybe get it revoked. "
  },
  {
    "sentId": 26,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "username and password written as constants in my code",
        "em2Text": "accessing anything in that application or file",
        "label": "None"
      },
      {
        "em1Text": "accessing anything in that application or file",
        "em2Text": "username and password written as constants in my code",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 66,
        "text": "username and password written as constants in my code",
        "label": "ATTACK"
      },
      {
        "start": 623,
        "text": "accessing anything in that application or file",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm making an android application and currently, i have my server username and password written as constants in my code (which is not very secure). i have researched online but i couldn't really find something that would completely secure the password from the user or at least prevent from hackers. could anyone help me out on how to securely store a password locally on android? thanks! it seems your question is actually \"can i restrict server access to my application only?\". this is not possible. once an application or file exists on a client (eg. a user device), there's no sure-fire way to prevent that client from accessing anything in that application or file, with or without your authorization. "
  },
  {
    "sentId": 57,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 46,
        "text": "replay attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "is it really a foolproof method of preventing replay attacks? "
  },
  {
    "sentId": 60,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 15,
        "text": "search engines from crawling my whole website",
        "label": "ATTACK"
      }
    ],
    "sentText": "i want to stop search engines from crawling my whole website. "
  },
  {
    "sentId": 62,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "hackers who are trying to make their url as unreadable as possible",
        "em2Text": "carry out xss attacks",
        "label": "None"
      },
      {
        "em1Text": "carry out xss attacks",
        "em2Text": "hackers who are trying to make their url as unreadable as possible",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 95,
        "text": "hackers who are trying to make their url as unreadable as possible",
        "label": "ATTACK"
      },
      {
        "start": 165,
        "text": "carry out xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "what are the possible reasons to encode ascii characters ?? the only reason i can think of are hackers who are trying to make their url as unreadable as possible to carry out xss attacks "
  },
  {
    "sentId": 33,
    "articleId": "3",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "sign up for the app",
        "em2Text": "use those credentials to get request right into my database",
        "label": "None"
      },
      {
        "em1Text": "use those credentials to get request right into my database",
        "em2Text": "sign up for the app",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 185,
        "text": "sign up for the app",
        "label": "ATTACK"
      },
      {
        "start": 215,
        "text": "use those credentials to get request right into my database",
        "label": "ATTACK"
      }
    ],
    "sentText": "my question is, how safe is \"auth !== null\"? yes, i realize that this means that only an authenticated user can access the data, but how easy is it to become authenticated? can someone sign up for the app, and then use those credentials to get request right into my database? "
  },
  {
    "sentId": 7,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "script they run on the browser",
        "em2Text": "do evil things",
        "label": "None"
      },
      {
        "em1Text": "do evil things",
        "em2Text": "script they run on the browser",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 111,
        "text": "script they run on the browser",
        "label": "ATTACK"
      },
      {
        "start": 146,
        "text": "do evil things",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am curious, what makes [link] secure from xss based attacks? they have a support for accounts so clearly any script they run on the browser may do evil things. "
  },
  {
    "sentId": 99,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 36,
        "text": "xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "recently i studied a lot related to xss attacks. i was searching for prevention techniques of xss attack.  "
  },
  {
    "sentId": 88,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 271,
        "text": "coopt our site to request any method",
        "label": "ATTACK"
      }
    ],
    "sentText": "my question is related to the cors response headers from the aws api gateway endpoint, specifically the access-control-allow-origin response header that is set to any \"' * '\". this article indicates the risks of using the any \"' * '\" parameter, namely that a 'hacker can coopt our site to request any method' on our back-end: ([link]). "
  },
  {
    "sentId": 15,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "it's viewed by an unauthorised person",
        "em2Text": "sending the login form via http post",
        "label": "None"
      },
      {
        "em1Text": "it's viewed by an unauthorised person",
        "em2Text": "the information being intercepted",
        "label": "None"
      },
      {
        "em1Text": "it's viewed by an unauthorised person",
        "em2Text": "mysql injection",
        "label": "None"
      },
      {
        "em1Text": "sending the login form via http post",
        "em2Text": "it's viewed by an unauthorised person",
        "label": "None"
      },
      {
        "em1Text": "sending the login form via http post",
        "em2Text": "the information being intercepted",
        "label": "None"
      },
      {
        "em1Text": "sending the login form via http post",
        "em2Text": "mysql injection",
        "label": "None"
      },
      {
        "em1Text": "the information being intercepted",
        "em2Text": "it's viewed by an unauthorised person",
        "label": "None"
      },
      {
        "em1Text": "the information being intercepted",
        "em2Text": "sending the login form via http post",
        "label": "PARENT"
      },
      {
        "em1Text": "the information being intercepted",
        "em2Text": "mysql injection",
        "label": "None"
      },
      {
        "em1Text": "mysql injection",
        "em2Text": "it's viewed by an unauthorised person",
        "label": "None"
      },
      {
        "em1Text": "mysql injection",
        "em2Text": "sending the login form via http post",
        "label": "None"
      },
      {
        "em1Text": "mysql injection",
        "em2Text": "the information being intercepted",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 302,
        "text": "it's viewed by an unauthorised person",
        "label": "ATTACK"
      },
      {
        "start": 516,
        "text": "sending the login form via http post",
        "label": "ATTACK"
      },
      {
        "start": 572,
        "text": "the information being intercepted",
        "label": "ATTACK"
      },
      {
        "start": 650,
        "text": "mysql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "i regularly use a standard form to send login information through the http post method and then validate it using php to check if the details are correct. i use an md5 hash on the passwords (and sometimes usernames) to give some degree of security, so i'm not storing a raw password in my code in case it's viewed by an unauthorised person, or something like that. i've recently been working on a forum which has a mysql database of users and passwords, the passwords are stored as md5 hashes, but i worry that when sending the login form via http post the possibility of the information being intercepted is there. i'm aware of the possibilities of mysql injection attacks and think that i'm safe from any simple attacks. "
  },
  {
    "sentId": 19,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "assigning unvalidated values ",
        "em2Text": "open redirects that can be used for phishing and what's more",
        "label": "None"
      },
      {
        "em1Text": "assigning unvalidated values ",
        "em2Text": "xss issues arising",
        "label": "None"
      },
      {
        "em1Text": "assigning unvalidated values ",
        "em2Text": "[code] and [code] uris",
        "label": "None"
      },
      {
        "em1Text": "open redirects that can be used for phishing and what's more",
        "em2Text": "assigning unvalidated values ",
        "label": "PARENT"
      },
      {
        "em1Text": "open redirects that can be used for phishing and what's more",
        "em2Text": "xss issues arising",
        "label": "None"
      },
      {
        "em1Text": "open redirects that can be used for phishing and what's more",
        "em2Text": "[code] and [code] uris",
        "label": "None"
      },
      {
        "em1Text": "xss issues arising",
        "em2Text": "assigning unvalidated values ",
        "label": "None"
      },
      {
        "em1Text": "xss issues arising",
        "em2Text": "open redirects that can be used for phishing and what's more",
        "label": "None"
      },
      {
        "em1Text": "xss issues arising",
        "em2Text": "[code] and [code] uris",
        "label": "PARENT"
      },
      {
        "em1Text": "[code] and [code] uris",
        "em2Text": "assigning unvalidated values ",
        "label": "None"
      },
      {
        "em1Text": "[code] and [code] uris",
        "em2Text": "open redirects that can be used for phishing and what's more",
        "label": "None"
      },
      {
        "em1Text": "[code] and [code] uris",
        "em2Text": "xss issues arising",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 56,
        "text": "assigning unvalidated values ",
        "label": "ATTACK"
      },
      {
        "start": 103,
        "text": "open redirects that can be used for phishing and what's more",
        "label": "ATTACK"
      },
      {
        "start": 165,
        "text": "xss issues arising",
        "label": "ATTACK"
      },
      {
        "start": 200,
        "text": "[code] and [code] uris",
        "label": "ATTACK"
      }
    ],
    "sentText": "the second one is something you should be careful with. assigning unvalidated values to it can lead to open redirects that can be used for phishing and what's more, xss issues arising from the use of [code] and [code] uris. then to the interesting part: [code] and [code] uris. these are the ones that will bite you. the javascript and vbscript uri schemes are non-standard uri schemes that can be used to execute code in the context of the currently open web page. sounds bad, doesn't it? well, it should. consider our attacker-controlled variable [code]: all an attacker has to do to launch an attack against your users is inject a script uri into the variable. when you assign it to [code], it's basically the same as calling [code] on the script. "
  },
  {
    "sentId": 117,
    "articleId": "6",
    "threatType": "D",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 187,
        "text": "dos attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm new to cxf and i would like to know if it has any build-in mechanism that would allow limiting the number of concurrent calls to the web service, thus addressing the possibility of a dos attack? something similar to this feature of wcf? "
  },
  {
    "sentId": 31,
    "articleId": "1",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "man-in-the-middle attack",
        "em2Text": "the server key has been stolen",
        "label": "PARENT"
      },
      {
        "em1Text": "man-in-the-middle attack",
        "em2Text": "attacker can appear to be the server",
        "label": "None"
      },
      {
        "em1Text": "man-in-the-middle attack",
        "em2Text": "fake ca has been injected in his trusted root authorities",
        "label": "None"
      },
      {
        "em1Text": "man-in-the-middle attack",
        "em2Text": "generate any cert he likes",
        "label": "None"
      },
      {
        "em1Text": "the server key has been stolen",
        "em2Text": "man-in-the-middle attack",
        "label": "None"
      },
      {
        "em1Text": "the server key has been stolen",
        "em2Text": "attacker can appear to be the server",
        "label": "PARENT"
      },
      {
        "em1Text": "the server key has been stolen",
        "em2Text": "fake ca has been injected in his trusted root authorities",
        "label": "None"
      },
      {
        "em1Text": "the server key has been stolen",
        "em2Text": "generate any cert he likes",
        "label": "None"
      },
      {
        "em1Text": "attacker can appear to be the server",
        "em2Text": "man-in-the-middle attack",
        "label": "None"
      },
      {
        "em1Text": "attacker can appear to be the server",
        "em2Text": "the server key has been stolen",
        "label": "None"
      },
      {
        "em1Text": "attacker can appear to be the server",
        "em2Text": "fake ca has been injected in his trusted root authorities",
        "label": "None"
      },
      {
        "em1Text": "attacker can appear to be the server",
        "em2Text": "generate any cert he likes",
        "label": "PARENT"
      },
      {
        "em1Text": "fake ca has been injected in his trusted root authorities",
        "em2Text": "man-in-the-middle attack",
        "label": "None"
      },
      {
        "em1Text": "fake ca has been injected in his trusted root authorities",
        "em2Text": "the server key has been stolen",
        "label": "None"
      },
      {
        "em1Text": "fake ca has been injected in his trusted root authorities",
        "em2Text": "attacker can appear to be the server",
        "label": "None"
      },
      {
        "em1Text": "fake ca has been injected in his trusted root authorities",
        "em2Text": "generate any cert he likes",
        "label": "None"
      },
      {
        "em1Text": "generate any cert he likes",
        "em2Text": "man-in-the-middle attack",
        "label": "None"
      },
      {
        "em1Text": "generate any cert he likes",
        "em2Text": "the server key has been stolen",
        "label": "None"
      },
      {
        "em1Text": "generate any cert he likes",
        "em2Text": "attacker can appear to be the server",
        "label": "None"
      },
      {
        "em1Text": "generate any cert he likes",
        "em2Text": "fake ca has been injected in his trusted root authorities",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 584,
        "text": "man-in-the-middle attack",
        "label": "ATTACK"
      },
      {
        "start": 1774,
        "text": "the server key has been stolen",
        "label": "ATTACK"
      },
      {
        "start": 1817,
        "text": "attacker can appear to be the server",
        "label": "ATTACK"
      },
      {
        "start": 2567,
        "text": "fake ca has been injected in his trusted root authorities",
        "label": "ATTACK"
      },
      {
        "start": 2650,
        "text": "generate any cert he likes",
        "label": "ATTACK"
      }
    ],
    "sentText": "first of all i'll describe briefly the authentication procedure as i understand it, as i may be mistaken in that regard: a client starts a connection, which a server responds to with a combination of public key, some metadata and digital signature of a trusted authority. then the client takes the decision if she trusts the server, encrypts some random session key with the public key and sends it back. this session key can be decrypted only with private key stored on the server. server does this and then the https session begins.so, if i'm correct above, the question is how the man-in-the-middle attack can occur in such scenario? i mean, even if somebody intercepts the server (e.g. www.server.com) response with public key and has some means to make me think that he is www.server.com, he still wouldn't be able to decrypt my session key without the private key.speaking about the mutual authentication, is it all about the server confidence about the client identity? i mean, the client can already be sure that she is communicating with the right server, but now the server wants to find out who the client is, right?and the last question is about the alternative to the mutual authentication. if i act as a client in the situation described, what if i send a login/password in the http header after the ssl session is established? as i see it, this information can't be intercepted because the connection is already secured and the server can rely on it for my identification. am i wrong? what are the downsides of such an approach compared with mutual authentication (only security issues are important, not the implementation complexity)? man-in-the-middle attack on ssl are really only possible if one of ssl's preconditions is broken, here are some examples; the server key has been stolen - means the attacker can appear to be the server, and there is no way for the client to know.the client trusts an untrustworthy ca (or one that has had it's root key stolen) - whoever holds a trusted ca key can generate a certificate pretending to be the server and the client will trust it. with the number of cas pre-existing in browsers today, this may be a real problem. this means that the server certificate would appear to change to another valid one, which is something most clients will hide from you.the client doesn't bother to validate the certificate correctly against its list of trusted ca's - anyone can create a ca. with no validation, \"ben's cars and certificates\" will appear to be just as valid as verisign.the client has been attacked and a fake ca has been injected in his trusted root authorities - allows the attacker to generate any cert he likes, and the client will trust it. malware tends to do this to for example redirect you to fake banking sites. "
  },
  {
    "sentId": 2,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "spring expression language (spel)",
        "em2Text": "http parameter submissions",
        "label": "AND"
      },
      {
        "em1Text": "spring expression language (spel)",
        "em2Text": "get sensitive system data, application and user cookies",
        "label": "None"
      },
      {
        "em1Text": "http parameter submissions",
        "em2Text": "spring expression language (spel)",
        "label": "None"
      },
      {
        "em1Text": "http parameter submissions",
        "em2Text": "get sensitive system data, application and user cookies",
        "label": "None"
      },
      {
        "em1Text": "get sensitive system data, application and user cookies",
        "em2Text": "spring expression language (spel)",
        "label": "None"
      },
      {
        "em1Text": "get sensitive system data, application and user cookies",
        "em2Text": "http parameter submissions",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 25,
        "text": "spring expression language (spel)",
        "label": "ATTACK"
      },
      {
        "start": 86,
        "text": "http parameter submissions",
        "label": "ATTACK"
      },
      {
        "start": 143,
        "text": "get sensitive system data, application and user cookies",
        "label": "ATTACK"
      }
    ],
    "sentText": "this article states that\"spring expression language (spel) could be exploited through http parameter submissions that would allow attackers to get sensitive system data, application and user cookies.\"  "
  },
  {
    "sentId": 92,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "it to be compromised",
        "em2Text": "uploading the source code to github",
        "label": "PARENT"
      },
      {
        "em1Text": "uploading the source code to github",
        "em2Text": "it to be compromised",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 75,
        "text": "it to be compromised",
        "label": "ATTACK"
      },
      {
        "start": 99,
        "text": "uploading the source code to github",
        "label": "ATTACK"
      }
    ],
    "sentText": "i used a sensitive password with the superuser i created and i do not want it to be compromised by uploading the source code to github. "
  },
  {
    "sentId": 31,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "xss payload send an http trace request to the web server (or [link], forward or reverse)",
        "em2Text": "echo back to the client the full request - including your cookies, httponly or not",
        "label": "None"
      },
      {
        "em1Text": "xss payload send an http trace request to the web server (or [link], forward or reverse)",
        "em2Text": "the xss payload can then parse the returned info, and retrieve those delicious cookies",
        "label": "None"
      },
      {
        "em1Text": "echo back to the client the full request - including your cookies, httponly or not",
        "em2Text": "xss payload send an http trace request to the web server (or [link], forward or reverse)",
        "label": "PARENT"
      },
      {
        "em1Text": "echo back to the client the full request - including your cookies, httponly or not",
        "em2Text": "the xss payload can then parse the returned info, and retrieve those delicious cookies",
        "label": "None"
      },
      {
        "em1Text": "the xss payload can then parse the returned info, and retrieve those delicious cookies",
        "em2Text": "xss payload send an http trace request to the web server (or [link], forward or reverse)",
        "label": "None"
      },
      {
        "em1Text": "the xss payload can then parse the returned info, and retrieve those delicious cookies",
        "em2Text": "echo back to the client the full request - including your cookies, httponly or not",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 212,
        "text": "xss payload send an http trace request to the web server (or [link], forward or reverse)",
        "label": "ATTACK"
      },
      {
        "start": 313,
        "text": "echo back to the client the full request - including your cookies, httponly or not",
        "label": "ATTACK"
      },
      {
        "start": 397,
        "text": "the xss payload can then parse the returned info, and retrieve those delicious cookies",
        "label": "ATTACK"
      }
    ],
    "sentText": "but, is there anyway to steal httponly cookies, with xss? (ignoring the question of httponly support?)....the answer is: yes.a subset of xss is known as [link] (or go to the original [link]). this attack has the xss payload send an http trace request to the web server (or [link], forward or reverse), which will echo back to the client the full request - including your cookies, httponly or not. the xss payload can then parse the returned info, and retrieve those delicious cookies... "
  },
  {
    "sentId": 36,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "have access to the database and code",
        "em2Text": "dictionary attack",
        "label": "None"
      },
      {
        "em1Text": "dictionary attack",
        "em2Text": "have access to the database and code",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 625,
        "text": "have access to the database and code",
        "label": "ATTACK"
      },
      {
        "start": 84,
        "text": "dictionary attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "update: please note i am not asking what a salt is, what a rainbow table is, what a dictionary attack is, or what the purpose of a salt is. i am querying: if you know the users salt and hash, isn't it quite easy to calculate their password? therfore, a dictionary attack from a hacker who is worth his salt (ha ha) would simply run each keyword against the stored salts in the common combinations listed above. the only thing i can think to do is have a secret blending algorithm that laces the salt and password together in a random pattern, or adds other user fields to the hashing process meaning the hacker would have to have access to the database and code to lace them for a dictionary attack to prove fruitful. (update, as pointed out in comments it's best to assume the hacker has access to all your information so this probably isn't best). "
  },
  {
    "sentId": 16,
    "articleId": "3",
    "threatType": "D",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 111,
        "text": "ddos attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "my problem is that even though my project is 100% legal, and not shady, it is highly susceptible to occasional ddos attacks. "
  },
  {
    "sentId": 19,
    "articleId": "3",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "AND"
      },
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "creates his own app",
        "label": "None"
      },
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "None"
      },
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "None"
      },
      {
        "em1Text": "reverse engineers the app",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "creates his own app",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "None"
      },
      {
        "em1Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "None"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "None"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "AND"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "None"
      },
      {
        "em1Text": "creates his own app",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "creates his own app",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "None"
      },
      {
        "em1Text": "bakes in company's sender id and server registration interface",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "None"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "None"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "creates his own app",
        "label": "PARENT"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "None"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "None"
      },
      {
        "em1Text": "puts app in the store",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "None"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "None"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "creates his own app",
        "label": "None"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "None"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "PARENT"
      },
      {
        "em1Text": "impersonates company's real app as far as gcm goes",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "creates his own app",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "it registers to receive messages from company's sender id",
        "em2Text": "sends its gcm registration id to company's servers",
        "label": "AND"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "reverse engineers the app",
        "label": "None"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "None"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "creates his own app",
        "label": "None"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "bakes in company's sender id and server registration interface",
        "label": "None"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "puts app in the store",
        "label": "None"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "impersonates company's real app as far as gcm goes",
        "label": "None"
      },
      {
        "em1Text": "sends its gcm registration id to company's servers",
        "em2Text": "it registers to receive messages from company's sender id",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 9,
        "text": "reverse engineers the app",
        "label": "ATTACK"
      },
      {
        "start": 39,
        "text": "extracts both the sender id and the server interface used to receive gcm registration ids",
        "label": "ATTACK"
      },
      {
        "start": 139,
        "text": "creates his own app",
        "label": "ATTACK"
      },
      {
        "start": 160,
        "text": "bakes in company's sender id and server registration interface",
        "label": "ATTACK"
      },
      {
        "start": 224,
        "text": "puts app in the store",
        "label": "ATTACK"
      },
      {
        "start": 273,
        "text": "impersonates company's real app as far as gcm goes",
        "label": "ATTACK"
      },
      {
        "start": 326,
        "text": "it registers to receive messages from company's sender id",
        "label": "ATTACK"
      },
      {
        "start": 393,
        "text": "sends its gcm registration id to company's servers",
        "label": "ATTACK"
      }
    ],
    "sentText": "attacker reverse engineers the app and extracts both the sender id and the server interface used to receive gcm registration ids. attacker creates his own app, bakes in company's sender id and server registration interface, puts app in the store.  the attack app basically impersonates company's real app as far as gcm goes:  it registers to receive messages from company's sender id and then sends its gcm registration id to company's servers just like the \"real\" app does. "
  },
  {
    "sentId": 161,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss",
        "em2Text": "other javascript attacks",
        "label": "OR"
      },
      {
        "em1Text": "xss",
        "em2Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "anyone could post a security hole exploit script ",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "infect people with old browsers and plugins",
        "label": "None"
      },
      {
        "em1Text": "other javascript attacks",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "other javascript attacks",
        "em2Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "label": "None"
      },
      {
        "em1Text": "other javascript attacks",
        "em2Text": "anyone could post a security hole exploit script ",
        "label": "None"
      },
      {
        "em1Text": "other javascript attacks",
        "em2Text": "infect people with old browsers and plugins",
        "label": "None"
      },
      {
        "em1Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "em2Text": "other javascript attacks",
        "label": "None"
      },
      {
        "em1Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "em2Text": "anyone could post a security hole exploit script ",
        "label": "None"
      },
      {
        "em1Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "em2Text": "infect people with old browsers and plugins",
        "label": "None"
      },
      {
        "em1Text": "anyone could post a security hole exploit script ",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "anyone could post a security hole exploit script ",
        "em2Text": "other javascript attacks",
        "label": "None"
      },
      {
        "em1Text": "anyone could post a security hole exploit script ",
        "em2Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "label": "None"
      },
      {
        "em1Text": "anyone could post a security hole exploit script ",
        "em2Text": "infect people with old browsers and plugins",
        "label": "None"
      },
      {
        "em1Text": "infect people with old browsers and plugins",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "infect people with old browsers and plugins",
        "em2Text": "other javascript attacks",
        "label": "None"
      },
      {
        "em1Text": "infect people with old browsers and plugins",
        "em2Text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "label": "None"
      },
      {
        "em1Text": "infect people with old browsers and plugins",
        "em2Text": "anyone could post a security hole exploit script ",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 55,
        "text": "xss",
        "label": "ATTACK"
      },
      {
        "start": 62,
        "text": "other javascript attacks",
        "label": "ATTACK"
      },
      {
        "start": 96,
        "text": "an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission",
        "label": "ATTACK"
      },
      {
        "start": 253,
        "text": "anyone could post a security hole exploit script ",
        "label": "ATTACK"
      },
      {
        "start": 314,
        "text": "infect people with old browsers and plugins",
        "label": "ATTACK"
      }
    ],
    "sentText": "anyone know if jsbin.com implements any protection for xss or other javascript attacks? i guess an unfriendly script could do a denial of service on jsbin by continually scripting a \u9225\u69aeave to public url\u9225?submission to clog the database up. and of course anyone could post a security hole exploit script which would infect people with old browsers and plugins; that might also get jsbin on google's blocklist. "
  },
  {
    "sentId": 111,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "this id could be used to hijack another users session",
        "em2Text": "pair their requests with a foreign socket object (which i use as a session cache) through packet forgery",
        "label": "None"
      },
      {
        "em1Text": "this id could be used to hijack another users session",
        "em2Text": "supplying another socket id",
        "label": "None"
      },
      {
        "em1Text": "pair their requests with a foreign socket object (which i use as a session cache) through packet forgery",
        "em2Text": "this id could be used to hijack another users session",
        "label": "None"
      },
      {
        "em1Text": "pair their requests with a foreign socket object (which i use as a session cache) through packet forgery",
        "em2Text": "supplying another socket id",
        "label": "PARENT"
      },
      {
        "em1Text": "supplying another socket id",
        "em2Text": "this id could be used to hijack another users session",
        "label": "None"
      },
      {
        "em1Text": "supplying another socket id",
        "em2Text": "pair their requests with a foreign socket object (which i use as a session cache) through packet forgery",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 187,
        "text": "this id could be used to hijack another users session",
        "label": "ATTACK"
      },
      {
        "start": 1738,
        "text": "pair their requests with a foreign socket object (which i use as a session cache) through packet forgery",
        "label": "ATTACK"
      },
      {
        "start": 1846,
        "text": "supplying another socket id",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm developing a web application using socket.io.i'm currently using the socket id as an identifier which gets broadcast to other clients. now this raised security concerns as to whether this id could be used to hijack another users session. unfortunately it is extremely difficult to find any information on this online. a client cannot do anything with a socket.id directly.  so, allowing the id to be known causes no new vulnerabilities on its own.  however, if your server allows things to be performed on a socket if only an id is known, then you'd have to assess what the risks are for those operations that your server exposes.  we can't really comment on those since you haven't shown us any code or design.for example, if your server supported a message call &quot;buy&quot; and all that was needed was an id for a client to trigger a buy operation, then it could be a problem if you let the id be publicly known.  but as long as the only operations that operate on an id that your server makes available to the client are intended for the public to access on any socket (such as send them a message), then there should not be a problem.so - should the socket id be kept secret or can i safely use it as a public identifier?it is perfectly fine as a public identifier and that's one of the things that it is there for.  it should be used as an identifier (as in &quot;i want to send a message to bob so i will tell the server to send a message to his id&quot;), but not as authorization.  after all, if you're making it public, then it isn't a secret so should not be used by your own server api for authorization.i guess i should've been a bit more specific. i was wondering whether it would be possible for a malicious user to pair their requests with a foreign socket object (which i use as a session cache) through packet forgery by supplying another socket id. i take from your answer that this is not the case - so thanks a lot!the socket.id is not used by socket.io in the transport itself.  so you can't do anything malicious such as pretending to be someone you aren't just because you know their [code]. "
  },
  {
    "sentId": 31,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "steal not only the latest intellectual properly ",
        "em2Text": "our whole history of changes",
        "label": "AND"
      },
      {
        "em1Text": "steal not only the latest intellectual properly ",
        "em2Text": "copying a single folder",
        "label": "PARENT"
      },
      {
        "em1Text": "our whole history of changes",
        "em2Text": "steal not only the latest intellectual properly ",
        "label": "None"
      },
      {
        "em1Text": "our whole history of changes",
        "em2Text": "copying a single folder",
        "label": "None"
      },
      {
        "em1Text": "copying a single folder",
        "em2Text": "steal not only the latest intellectual properly ",
        "label": "None"
      },
      {
        "em1Text": "copying a single folder",
        "em2Text": "our whole history of changes",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 138,
        "text": "steal not only the latest intellectual properly ",
        "label": "ATTACK"
      },
      {
        "start": 190,
        "text": "our whole history of changes",
        "label": "ATTACK"
      },
      {
        "start": 227,
        "text": "copying a single folder",
        "label": "ATTACK"
      }
    ],
    "sentText": "it's been difficult to nail down his exact security concern but i've gathered that it centers on the fact that a malicious employee could steal not only the latest intellectual properly but our whole history of changes just by copying a single folder. "
  },
  {
    "sentId": 59,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 42,
        "text": "man-in-the-middle attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "as far as i can see this should prevent a man-in-the-middle attack, or am i missing something?at point 7 the client should know if someone is trying to give the server the wrong key to encrypt with, as no one else but the server can decrypt key2(public). "
  },
  {
    "sentId": 165,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "None"
      },
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "None"
      },
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "users via web during potential attack",
        "label": "None"
      },
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "app server 2 and private key are compromised",
        "label": "None"
      },
      {
        "em1Text": "app (web) server 1 or db server 1 or both are compromised",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "PARENT"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "None"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "users via web during potential attack",
        "label": "None"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "app server 2 and private key are compromised",
        "label": "None"
      },
      {
        "em1Text": "attacker will however be able to modify web-server",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "None"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "PARENT"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "AND"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "users via web during potential attack",
        "label": "None"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "app server 2 and private key are compromised",
        "label": "None"
      },
      {
        "em1Text": "get currently logged users passwords in plaintext",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "users via web during potential attack",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "app server 2 and private key are compromised",
        "label": "None"
      },
      {
        "em1Text": "decrypt part of user sensitive data stored in db server 1",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "None"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "None"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "None"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "users via web during potential attack",
        "label": "PARENT"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "app server 2 and private key are compromised",
        "label": "None"
      },
      {
        "em1Text": "intercept user sensitive data entered by users",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "None"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "PARENT"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "None"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "app server 2 and private key are compromised",
        "label": "None"
      },
      {
        "em1Text": "users via web during potential attack",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "users via web during potential attack",
        "label": "None"
      },
      {
        "em1Text": "app server 2 and private key are compromised",
        "em2Text": "attacker will have access to everything",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "attacker will however be able to modify web-server",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "get currently logged users passwords in plaintext",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "decrypt part of user sensitive data stored in db server 1",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "intercept user sensitive data entered by users",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "users via web during potential attack",
        "label": "None"
      },
      {
        "em1Text": "attacker will have access to everything",
        "em2Text": "app server 2 and private key are compromised",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 10,
        "text": "app (web) server 1 or db server 1 or both are compromised",
        "label": "ATTACK"
      },
      {
        "start": 259,
        "text": "attacker will however be able to modify web-server",
        "label": "ATTACK"
      },
      {
        "start": 313,
        "text": "get currently logged users passwords in plaintext",
        "label": "ATTACK"
      },
      {
        "start": 367,
        "text": "decrypt part of user sensitive data stored in db server 1",
        "label": "ATTACK"
      },
      {
        "start": 544,
        "text": "intercept user sensitive data entered by users",
        "label": "ATTACK"
      },
      {
        "start": 585,
        "text": "users via web during potential attack",
        "label": "ATTACK"
      },
      {
        "start": 794,
        "text": "app server 2 and private key are compromised",
        "label": "ATTACK"
      },
      {
        "start": 844,
        "text": "attacker will have access to everything",
        "label": "ATTACK"
      }
    ],
    "sentText": "if either app (web) server 1 or db server 1 or both are compromised then attacker will not be able to get any user sensitive data (either encrypted or not). all attacker will have is access to public-key and encryption algorithms which are well known anyway. attacker will however be able to modify web-server to get currently logged users passwords in plaintext and decrypt part of user sensitive data stored in db server 1 (see app server 1, step 3) which i don't consider as a big deal. attacker will be able to (via code modification) also intercept user sensitive data entered by users via web during potential attack. later i consider as a higher risk, but provided that it is hard (is it?) for attacker to modify code without someone noticing i guess i shouldn't worry much about it. if app server 2 and private key are compromised then attacker will have access to everything, but app server 2 or db server 2 are not web facing so it shouldn't be a problem. "
  },
  {
    "sentId": 126,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "directory traversal attack",
        "em2Text": "prevent it from being accessible directly",
        "label": "PARENT"
      },
      {
        "em1Text": "directory traversal attack",
        "em2Text": "prevent getimage.php from being abused",
        "label": "None"
      },
      {
        "em1Text": "prevent it from being accessible directly",
        "em2Text": "directory traversal attack",
        "label": "None"
      },
      {
        "em1Text": "prevent it from being accessible directly",
        "em2Text": "prevent getimage.php from being abused",
        "label": "None"
      },
      {
        "em1Text": "prevent getimage.php from being abused",
        "em2Text": "directory traversal attack",
        "label": "None"
      },
      {
        "em1Text": "prevent getimage.php from being abused",
        "em2Text": "prevent it from being accessible directly",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 139,
        "text": "directory traversal attack",
        "label": "ATTACK"
      },
      {
        "start": 371,
        "text": "prevent it from being accessible directly",
        "label": "ATTACK"
      },
      {
        "start": 550,
        "text": "prevent getimage.php from being abused",
        "label": "ATTACK"
      }
    ],
    "sentText": "i rely on $_get['img'] to determine which image to retrieve, which is a possible security hole (and a major one at that). i could forsee a directory traversal attack, hence the use of realpath, though i'm sure there can be other avenues of attack i do not contain with this script. for that reason, i'd prefer if i could move getimage.php outside of webroot, or at least prevent it from being accessible directly (and only through gallery.php, where the sent img parameter is strictly under my control). so, long story short: what do i need to do to prevent getimage.php from being abused? "
  },
  {
    "sentId": 58,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "any malicious user can turn on chrome debugger",
        "em2Text": "modify javascript code that is being executed",
        "label": "OR"
      },
      {
        "em1Text": "any malicious user can turn on chrome debugger",
        "em2Text": "send their victim a link",
        "label": "None"
      },
      {
        "em1Text": "any malicious user can turn on chrome debugger",
        "em2Text": "construct an image link to send the session cookie to themselves",
        "label": "None"
      },
      {
        "em1Text": "any malicious user can turn on chrome debugger",
        "em2Text": "dom based xss",
        "label": "None"
      },
      {
        "em1Text": "modify javascript code that is being executed",
        "em2Text": "any malicious user can turn on chrome debugger",
        "label": "None"
      },
      {
        "em1Text": "modify javascript code that is being executed",
        "em2Text": "send their victim a link",
        "label": "None"
      },
      {
        "em1Text": "modify javascript code that is being executed",
        "em2Text": "construct an image link to send the session cookie to themselves",
        "label": "None"
      },
      {
        "em1Text": "modify javascript code that is being executed",
        "em2Text": "dom based xss",
        "label": "None"
      },
      {
        "em1Text": "send their victim a link",
        "em2Text": "any malicious user can turn on chrome debugger",
        "label": "None"
      },
      {
        "em1Text": "send their victim a link",
        "em2Text": "modify javascript code that is being executed",
        "label": "None"
      },
      {
        "em1Text": "send their victim a link",
        "em2Text": "construct an image link to send the session cookie to themselves",
        "label": "AND"
      },
      {
        "em1Text": "send their victim a link",
        "em2Text": "dom based xss",
        "label": "None"
      },
      {
        "em1Text": "construct an image link to send the session cookie to themselves",
        "em2Text": "any malicious user can turn on chrome debugger",
        "label": "None"
      },
      {
        "em1Text": "construct an image link to send the session cookie to themselves",
        "em2Text": "modify javascript code that is being executed",
        "label": "None"
      },
      {
        "em1Text": "construct an image link to send the session cookie to themselves",
        "em2Text": "send their victim a link",
        "label": "None"
      },
      {
        "em1Text": "construct an image link to send the session cookie to themselves",
        "em2Text": "dom based xss",
        "label": "None"
      },
      {
        "em1Text": "dom based xss",
        "em2Text": "any malicious user can turn on chrome debugger",
        "label": "None"
      },
      {
        "em1Text": "dom based xss",
        "em2Text": "modify javascript code that is being executed",
        "label": "None"
      },
      {
        "em1Text": "dom based xss",
        "em2Text": "send their victim a link",
        "label": "PARENT"
      },
      {
        "em1Text": "dom based xss",
        "em2Text": "construct an image link to send the session cookie to themselves",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "any malicious user can turn on chrome debugger",
        "label": "ATTACK"
      },
      {
        "start": 64,
        "text": "modify javascript code that is being executed",
        "label": "ATTACK"
      },
      {
        "start": 458,
        "text": "send their victim a link",
        "label": "ATTACK"
      },
      {
        "start": 580,
        "text": "construct an image link to send the session cookie to themselves",
        "label": "ATTACK"
      },
      {
        "start": 702,
        "text": "dom based xss",
        "label": "ATTACK"
      }
    ],
    "sentText": "any malicious user can turn on chrome debugger for example, and modify javascript code that is being executed. so he can put his own functions to be executed etc.   any malicious user can turn on chrome debugger for example, and modify  javascript code that is being executed. so he can put his own  functions to be executed etc. however, the difference between eval and developer tools is that eval may execute things in shareable links. the attacker could send their victim a link, which exploits the code evaluation function. take this to the next stage and the attacker could construct an image link to send the session cookie to themselves this is known as a [link] attack. in fact, the type is a dom based xss, to be specific. "
  },
  {
    "sentId": 98,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss attacks",
        "em2Text": "create an email address, such as this one",
        "label": "None"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "[code]",
        "label": "None"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "use this email address to attack the website",
        "label": "PARENT"
      },
      {
        "em1Text": "create an email address, such as this one",
        "em2Text": "xss attacks",
        "label": "None"
      },
      {
        "em1Text": "create an email address, such as this one",
        "em2Text": "[code]",
        "label": "AND"
      },
      {
        "em1Text": "create an email address, such as this one",
        "em2Text": "use this email address to attack the website",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "xss attacks",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "create an email address, such as this one",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "use this email address to attack the website",
        "label": "None"
      },
      {
        "em1Text": "use this email address to attack the website",
        "em2Text": "xss attacks",
        "label": "None"
      },
      {
        "em1Text": "use this email address to attack the website",
        "em2Text": "create an email address, such as this one",
        "label": "None"
      },
      {
        "em1Text": "use this email address to attack the website",
        "em2Text": "[code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 50,
        "text": "xss attacks",
        "label": "ATTACK"
      },
      {
        "start": 207,
        "text": "create an email address, such as this one",
        "label": "ATTACK"
      },
      {
        "start": 250,
        "text": "[code]",
        "label": "ATTACK"
      },
      {
        "start": 266,
        "text": "use this email address to attack the website",
        "label": "ATTACK"
      }
    ],
    "sentText": "i wonder whether an email address can be used for xss attacks.  let's suppose there is a website where one can register and gives his email address. if one wants to attack the given website, he or she might create an email address, such as this one: [code] and then use this email address to attack the website. the email address in your example appears valid.  the only character that is unusual is the quote [code] -- rest others are valid. "
  },
  {
    "sentId": 95,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "attacker could fetch the encrypted string",
        "em2Text": "fetch the key",
        "label": "None"
      },
      {
        "em1Text": "attacker could fetch the encrypted string",
        "em2Text": "decrypt the data",
        "label": "None"
      },
      {
        "em1Text": "fetch the key",
        "em2Text": "attacker could fetch the encrypted string",
        "label": "PARENT"
      },
      {
        "em1Text": "fetch the key",
        "em2Text": "decrypt the data",
        "label": "None"
      },
      {
        "em1Text": "decrypt the data",
        "em2Text": "attacker could fetch the encrypted string",
        "label": "None"
      },
      {
        "em1Text": "decrypt the data",
        "em2Text": "fetch the key",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 228,
        "text": "attacker could fetch the encrypted string",
        "label": "ATTACK"
      },
      {
        "start": 271,
        "text": "fetch the key",
        "label": "ATTACK"
      },
      {
        "start": 289,
        "text": "decrypt the data",
        "label": "ATTACK"
      }
    ],
    "sentText": "how is such encryption possible i wonder? the algorithm would be fixed and therefore either well-known or deductible (say one of seven widely used in industry algorithms) and there must be a key somewhere in the program. so the attacker could fetch the encrypted string, fetch the key and decrypt the data. "
  },
  {
    "sentId": 63,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "json allows you to [link] from an ajax call",
        "em2Text": "hacking [code]",
        "label": "None"
      },
      {
        "em1Text": "json allows you to [link] from an ajax call",
        "em2Text": "distributing malicious code",
        "label": "None"
      },
      {
        "em1Text": "hacking [code]",
        "em2Text": "json allows you to [link] from an ajax call",
        "label": "PARENT"
      },
      {
        "em1Text": "hacking [code]",
        "em2Text": "distributing malicious code",
        "label": "None"
      },
      {
        "em1Text": "distributing malicious code",
        "em2Text": "json allows you to [link] from an ajax call",
        "label": "None"
      },
      {
        "em1Text": "distributing malicious code",
        "em2Text": "hacking [code]",
        "label": "AND"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "json allows you to [link] from an ajax call",
        "label": "ATTACK"
      },
      {
        "start": 172,
        "text": "hacking [code]",
        "label": "ATTACK"
      },
      {
        "start": 191,
        "text": "distributing malicious code",
        "label": "ATTACK"
      }
    ],
    "sentText": "json allows you to [link] from an ajax call. for example: how does jquery handle the parsing? does it evaluate this code? what safeguards are in place to stop someone from hacking [code] and distributing malicious code? "
  },
  {
    "sentId": 107,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "brute force",
        "em2Text": "find the $secret",
        "label": "None"
      },
      {
        "em1Text": "find the $secret",
        "em2Text": "brute force",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 32,
        "text": "brute force",
        "label": "ATTACK"
      },
      {
        "start": 47,
        "text": "find the $secret",
        "label": "ATTACK"
      }
    ],
    "sentText": "is there any better attack than brute force to find the $secret in general?is there any better attack than brute force to find the $secret using [link]? "
  },
  {
    "sentId": 101,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 23,
        "text": "csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "<h3>why is a dedicated csrf cookie necessary?</h3> <h3>why should csrf nonces be bind to session id? does django do this?</h3> [link] seem to imply that csrf nonce needs to be bound to the session id (e.g. csrf nonce = keyed hash of session id). why is that? does django bind its csrf nonce to session id? csrf protection and session have different nature, so putting those in single cookie would make it harder to maintain. you can use csrf protection without using sessions.you may want to use csrf before session started (ie. you don't want to start session before user logged in, because of performance, but you want to protect your contact form with csrf).sometimes you want to delete session cookie, but probably never csrf.csrf protection is needed for single browser session (until you close browser), but sessions may continue for even weeks.you may want to have cross-domain session, but probably never need cross-domain csrf. "
  },
  {
    "sentId": 87,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "event injection",
        "em2Text": "special application permissions - [link] to be exact",
        "label": "PARENT"
      },
      {
        "em1Text": "special application permissions - [link] to be exact",
        "em2Text": "event injection",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 54,
        "text": "event injection",
        "label": "ATTACK"
      },
      {
        "start": 79,
        "text": "special application permissions - [link] to be exact",
        "label": "ATTACK"
      }
    ],
    "sentText": "i think the biggest problem you'll face is that using event injection requires special application permissions - [link] to be exact.  since granting an application this permission basically allows it to simulate input events into any application at any time, it is considered quite dangerous because a badly-written or intentionally malicious application could do a lot of damage.  therefore many end-users and business do not allow applications that require this permission. "
  },
  {
    "sentId": 17,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 74,
        "text": "sql injection script",
        "label": "ATTACK"
      }
    ],
    "sentText": "the website i worked was recently attempted to be hacked by the following sql injection script "
  },
  {
    "sentId": 34,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "had a validation error caused by a weird and previous unknown script",
        "em2Text": "[code]",
        "label": "AND"
      },
      {
        "em1Text": "had a validation error caused by a weird and previous unknown script",
        "em2Text": "the site has been compromised",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "had a validation error caused by a weird and previous unknown script",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "the site has been compromised",
        "label": "None"
      },
      {
        "em1Text": "the site has been compromised",
        "em2Text": "had a validation error caused by a weird and previous unknown script",
        "label": "None"
      },
      {
        "em1Text": "the site has been compromised",
        "em2Text": "[code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 108,
        "text": "had a validation error caused by a weird and previous unknown script",
        "label": "ATTACK"
      },
      {
        "start": 354,
        "text": "[code]",
        "label": "ATTACK"
      },
      {
        "start": 366,
        "text": "the site has been compromised",
        "label": "ATTACK"
      }
    ],
    "sentText": "i validated my client's website to xhtml strict 1.0/css 2.1 standards last week. today when i re-checked, i had a validation error caused by a weird and previous unknown script. i found this in the index.php file of my expressionengine cms. is this a hacking attempt as i suspected? i couldn't help but notice the russian domain encoded in the script... [code] yes. the site has been compromised.  "
  },
  {
    "sentId": 62,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "compromise a cryptosystem",
        "em2Text": "analyzing the time  taken to execute cryptographic algorithms",
        "label": "PARENT"
      },
      {
        "em1Text": "analyzing the time  taken to execute cryptographic algorithms",
        "em2Text": "compromise a cryptosystem",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 95,
        "text": "compromise a cryptosystem",
        "label": "ATTACK"
      },
      {
        "start": 124,
        "text": "analyzing the time  taken to execute cryptographic algorithms",
        "label": "ATTACK"
      }
    ],
    "sentText": "  in cryptography, a timing attack is a side channel attack in which the  attacker attempts to compromise a cryptosystem by analyzing the time  taken to execute cryptographic algorithms. "
  },
  {
    "sentId": 45,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "someone was able to view your connection data",
        "em2Text": "a \"hacker\" capturing data from an unencrypted wifi connection",
        "label": "None"
      },
      {
        "em1Text": "someone was able to view your connection data",
        "em2Text": "that person would be able to view part or all of your database",
        "label": "None"
      },
      {
        "em1Text": "a \"hacker\" capturing data from an unencrypted wifi connection",
        "em2Text": "someone was able to view your connection data",
        "label": "None"
      },
      {
        "em1Text": "a \"hacker\" capturing data from an unencrypted wifi connection",
        "em2Text": "that person would be able to view part or all of your database",
        "label": "None"
      },
      {
        "em1Text": "that person would be able to view part or all of your database",
        "em2Text": "someone was able to view your connection data",
        "label": "PARENT"
      },
      {
        "em1Text": "that person would be able to view part or all of your database",
        "em2Text": "a \"hacker\" capturing data from an unencrypted wifi connection",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 245,
        "text": "someone was able to view your connection data",
        "label": "ATTACK"
      },
      {
        "start": 300,
        "text": "a \"hacker\" capturing data from an unencrypted wifi connection",
        "label": "ATTACK"
      },
      {
        "start": 377,
        "text": "that person would be able to view part or all of your database",
        "label": "ATTACK"
      }
    ],
    "sentText": "remote access to mysql is not very secure. when your remote computer first connects to your mysql database, the password is encrypted before being transmitted over the internet. but after that, all data is passed as unencrypted \"plain text\". if someone was able to view your connection data (such as a \"hacker\" capturing data from an unencrypted wifi connection you're using), that person would be able to view part or all of your database.  "
  },
  {
    "sentId": 77,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 115,
        "text": "third party application like google analytic could store in their report such urls and query string",
        "label": "ATTACK"
      }
    ],
    "sentText": "urls with their query strings parameters are saved in web server log, and access to them could compromise security.third party application like google analytic could store in their report such urls and query string. "
  },
  {
    "sentId": 75,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "reverse engineering",
        "em2Text": "programs like cheat engine",
        "label": "OR"
      },
      {
        "em1Text": "programs like cheat engine",
        "em2Text": "reverse engineering",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 129,
        "text": "reverse engineering",
        "label": "ATTACK"
      },
      {
        "start": 152,
        "text": "programs like cheat engine",
        "label": "ATTACK"
      }
    ],
    "sentText": "the problem is i want to store these data securely in the vb.net application so that it's hard for any hackers/crackers through (reverse engineering or programs like cheat engine) to get my gmail account data. "
  },
  {
    "sentId": 68,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "attacker can read your memory",
        "em2Text": "access to your memory ",
        "label": "None"
      },
      {
        "em1Text": "access to your memory ",
        "em2Text": "attacker can read your memory",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 23,
        "text": "attacker can read your memory",
        "label": "ATTACK"
      },
      {
        "start": 225,
        "text": "access to your memory ",
        "label": "ATTACK"
      }
    ],
    "sentText": "some think that \"if an attacker can read your memory, you have 100% lost.\" (comment to [link]), which indicates that whether you store passwords in memory or not might be superfluous, since you're screwed anyway if they have access to your memory (see [link], which shows an example of how access to memory in an umnanaged environment can be pretty disastrous). "
  },
  {
    "sentId": 132,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "hacks this mechanism",
        "em2Text": "install arbitrary apps on a device",
        "label": "None"
      },
      {
        "em1Text": "install arbitrary apps on a device",
        "em2Text": "hacks this mechanism",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 65,
        "text": "hacks this mechanism",
        "label": "ATTACK"
      },
      {
        "start": 103,
        "text": "install arbitrary apps on a device",
        "label": "ATTACK"
      }
    ],
    "sentText": "google can delete and install apps silently ([link]). if someone hacks this mechanism, an attacker can install arbitrary apps on a device. unsure if this app has automatically all rights it wants to have. this doesn't happens till now, but it's possible. you can only protect your phone by checking regularly all installed apps and there rights. this mechanism can be misused by a hacker.malicious applications can do a lot evil things, but if you don't give every app the rights the apps wanted and think a little bit, you can protect your phone.some security holes in the browser or the system allows an app to get root-access. in this case the app can do everything it wanted. i don't know any protection against this. as far as i know android has such security holes, so this is the most dangerous issue. "
  },
  {
    "sentId": 29,
    "articleId": "2",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "debug my code and find my url",
        "em2Text": "send amount of data to my site and make it down",
        "label": "None"
      },
      {
        "em1Text": "send amount of data to my site and make it down",
        "em2Text": "debug my code and find my url",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 258,
        "text": "debug my code and find my url",
        "label": "ATTACK"
      },
      {
        "start": 320,
        "text": "send amount of data to my site and make it down",
        "label": "ATTACK"
      }
    ],
    "sentText": "it is an example and my real code send much more data to server, and maybe code above doesn't work, i just make my question more exact and specific as stackoverflow want me.my question is how to make these transactions safe and secure from hackers which may debug my code and find my url , in code above (params[0]) and send amount of data to my site and make it down. or how can i use the service of sending data to server more secure from these kind of dangers?? "
  },
  {
    "sentId": 91,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "this is sent by the http client and could therefore be forged",
        "em2Text": "which is sent by the http client and could contain potentially dangerous characters",
        "label": "None"
      },
      {
        "em1Text": "which is sent by the http client and could contain potentially dangerous characters",
        "em2Text": "this is sent by the http client and could therefore be forged",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 101,
        "text": "this is sent by the http client and could therefore be forged",
        "label": "ATTACK"
      },
      {
        "start": 217,
        "text": "which is sent by the http client and could contain potentially dangerous characters",
        "label": "ATTACK"
      }
    ],
    "sentText": "there's a well-known caveat about not trusting the mime type sent via file upload in php ([code]) as this is sent by the http client and could therefore be forged. there's a similar caveat for the file name ([code]), which is sent by the http client and could contain potentially dangerous characters. "
  },
  {
    "sentId": 41,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "set the csrf cookie using set-cookie",
        "em2Text": "supply a matching token in the post form data",
        "label": "None"
      },
      {
        "em1Text": "supply a matching token in the post form data",
        "em2Text": "set the csrf cookie using set-cookie",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 19,
        "text": "set the csrf cookie using set-cookie",
        "label": "ATTACK"
      },
      {
        "start": 66,
        "text": "supply a matching token in the post form data",
        "label": "ATTACK"
      }
    ],
    "sentText": "  the attacker can set the csrf cookie using set-cookie, and then supply a matching token in the post form data. since the site does not tie the session cookies to the csrf cookies, it has no way of determining that the csrf token + cookie are genuine (doing hashing etc. of one of them will not work, as the attacker can just get a valid pair from the site directly, and use that pair in the attack). "
  },
  {
    "sentId": 99,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "rename a malicious executable to [code]",
        "em2Text": "'hack' your system",
        "label": "None"
      },
      {
        "em1Text": "'hack' your system",
        "em2Text": "rename a malicious executable to [code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 13,
        "text": "rename a malicious executable to [code]",
        "label": "ATTACK"
      },
      {
        "start": 57,
        "text": "'hack' your system",
        "label": "ATTACK"
      }
    ],
    "sentText": "i can easily rename a malicious executable to [code] and 'hack' your system. "
  },
  {
    "sentId": 31,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "attack vector",
        "em2Text": "xss escaping",
        "label": "None"
      },
      {
        "em1Text": "xss escaping",
        "em2Text": "attack vector",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 76,
        "text": "attack vector",
        "label": "ATTACK"
      },
      {
        "start": 194,
        "text": "xss escaping",
        "label": "ATTACK"
      }
    ],
    "sentText": "if the api is implemented in a web service presented through a browser, the attack vector is quite real. on the other hand, if the api is implemented in a desktop app, or a mobile application - xss escaping would be a total nuisance and not needed. "
  },
  {
    "sentId": 70,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "any services running on a user's machine could effectively bypass the [link]",
        "em2Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "label": "PARENT"
      },
      {
        "em1Text": "any services running on a user's machine could effectively bypass the [link]",
        "em2Text": "grab details about the user",
        "label": "None"
      },
      {
        "em1Text": "any services running on a user's machine could effectively bypass the [link]",
        "em2Text": "the user is running a local reverse proxy to access something",
        "label": "None"
      },
      {
        "em1Text": "any services running on a user's machine could effectively bypass the [link]",
        "em2Text": "target site be malicious or be compromised",
        "label": "PARENT"
      },
      {
        "em1Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "em2Text": "any services running on a user's machine could effectively bypass the [link]",
        "label": "None"
      },
      {
        "em1Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "em2Text": "grab details about the user",
        "label": "AND"
      },
      {
        "em1Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "em2Text": "the user is running a local reverse proxy to access something",
        "label": "None"
      },
      {
        "em1Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "em2Text": "target site be malicious or be compromised",
        "label": "None"
      },
      {
        "em1Text": "grab details about the user",
        "em2Text": "any services running on a user's machine could effectively bypass the [link]",
        "label": "None"
      },
      {
        "em1Text": "grab details about the user",
        "em2Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "label": "None"
      },
      {
        "em1Text": "grab details about the user",
        "em2Text": "the user is running a local reverse proxy to access something",
        "label": "None"
      },
      {
        "em1Text": "grab details about the user",
        "em2Text": "target site be malicious or be compromised",
        "label": "None"
      },
      {
        "em1Text": "the user is running a local reverse proxy to access something",
        "em2Text": "any services running on a user's machine could effectively bypass the [link]",
        "label": "None"
      },
      {
        "em1Text": "the user is running a local reverse proxy to access something",
        "em2Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "label": "None"
      },
      {
        "em1Text": "the user is running a local reverse proxy to access something",
        "em2Text": "grab details about the user",
        "label": "None"
      },
      {
        "em1Text": "the user is running a local reverse proxy to access something",
        "em2Text": "target site be malicious or be compromised",
        "label": "None"
      },
      {
        "em1Text": "target site be malicious or be compromised",
        "em2Text": "any services running on a user's machine could effectively bypass the [link]",
        "label": "None"
      },
      {
        "em1Text": "target site be malicious or be compromised",
        "em2Text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "label": "None"
      },
      {
        "em1Text": "target site be malicious or be compromised",
        "em2Text": "grab details about the user",
        "label": "None"
      },
      {
        "em1Text": "target site be malicious or be compromised",
        "em2Text": "the user is running a local reverse proxy to access something",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 17,
        "text": "any services running on a user's machine could effectively bypass the [link]",
        "label": "ATTACK"
      },
      {
        "start": 109,
        "text": "a malicious or compromised service running on the user's computer could make that request via the user's browser",
        "label": "ATTACK"
      },
      {
        "start": 231,
        "text": "grab details about the user",
        "label": "ATTACK"
      },
      {
        "start": 376,
        "text": "the user is running a local reverse proxy to access something",
        "label": "ATTACK"
      },
      {
        "start": 523,
        "text": "target site be malicious or be compromised",
        "label": "ATTACK"
      }
    ],
    "sentText": "the risk is that any services running on a user's machine could effectively bypass the [link] for your site. a malicious or compromised service running on the user's computer could make that request via the user's browser and then grab details about the user, because their authentication cookie will be passed with the request. another scenario that could put you at risk if the user is running a local reverse proxy to access something. this would enable the target site to compromise the user through yours, should that target site be malicious or be compromised. this is because the user would be accessing the target site with a domain of [code]. "
  },
  {
    "sentId": 74,
    "articleId": "4",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "using the [code]",
        "em2Text": "open a server up",
        "label": "AND"
      },
      {
        "em1Text": "using the [code]",
        "em2Text": "generate many, many files and attack the server using some kind of dos attack",
        "label": "None"
      },
      {
        "em1Text": "open a server up",
        "em2Text": "using the [code]",
        "label": "None"
      },
      {
        "em1Text": "open a server up",
        "em2Text": "generate many, many files and attack the server using some kind of dos attack",
        "label": "None"
      },
      {
        "em1Text": "generate many, many files and attack the server using some kind of dos attack",
        "em2Text": "using the [code]",
        "label": "None"
      },
      {
        "em1Text": "generate many, many files and attack the server using some kind of dos attack",
        "em2Text": "open a server up",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 46,
        "text": "using the [code]",
        "label": "ATTACK"
      },
      {
        "start": 76,
        "text": "open a server up",
        "label": "ATTACK"
      },
      {
        "start": 635,
        "text": "generate many, many files and attack the server using some kind of dos attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "any there any security implications caused by using the [code] and could it open a server up for attack? if you use [code] just for generating c# source code, then you only need a permission to save the generated files to some directory or to noting at all (if it is possible to get the code generated into a memory stream)if you use it for compiling generated c# source, then you need a permission to run [code] (which may not be available in some limited environments such as shared hostings).if you just generate files &amp; compile them, then it probably won't be harmful (although someone could probably abuse your application to generate many, many files and attack the server using some kind of dos attack.if you also load &amp; execute the generated code, then it depends on how you generate it. if you assume that there are no bugs in c#/codedom and can guarantee that the generated code is safe, then you should be fine.if your code contain things such as [link] that can be provided by the user (in some way) than the user can write and run anything he or she wants on your server, so this would be potentially quite dangerous. "
  },
  {
    "sentId": 50,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "/posts page that takes id paramater",
        "em2Text": "displays info",
        "label": "AND"
      },
      {
        "em1Text": "/posts page that takes id paramater",
        "em2Text": "user/hacker will know the real object id of the document",
        "label": "None"
      },
      {
        "em1Text": "displays info",
        "em2Text": "/posts page that takes id paramater",
        "label": "None"
      },
      {
        "em1Text": "displays info",
        "em2Text": "user/hacker will know the real object id of the document",
        "label": "None"
      },
      {
        "em1Text": "user/hacker will know the real object id of the document",
        "em2Text": "/posts page that takes id paramater",
        "label": "PARENT"
      },
      {
        "em1Text": "user/hacker will know the real object id of the document",
        "em2Text": "displays info",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 47,
        "text": "/posts page that takes id paramater",
        "label": "ATTACK"
      },
      {
        "start": 136,
        "text": "displays info",
        "label": "ATTACK"
      },
      {
        "start": 173,
        "text": "user/hacker will know the real object id of the document",
        "label": "ATTACK"
      }
    ],
    "sentText": "let's say there is a posts collection, and the /posts page that takes id paramater (something like /posts/4d901acd8df94c1fe600009b) and displays info about it. this way the user/hacker will know the real object id of the document. is it okay or is it not secure? "
  },
  {
    "sentId": 148,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sql injection attack",
        "em2Text": "bugger up the database",
        "label": "None"
      },
      {
        "em1Text": "bugger up the database",
        "em2Text": "sql injection attack",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 29,
        "text": "sql injection attack",
        "label": "ATTACK"
      },
      {
        "start": 202,
        "text": "bugger up the database",
        "label": "ATTACK"
      }
    ],
    "sentText": "while option 1 is open to an sql injection attack, since my sproc is being called from an authenticated source, does it really matter? only trusted sources will execute this sproc, so if they choose to bugger up the database, that is their prerogative. "
  },
  {
    "sentId": 143,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sql injection",
        "em2Text": "stole credentials",
        "label": "PARENT"
      },
      {
        "em1Text": "stole credentials",
        "em2Text": "sql injection",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 429,
        "text": "sql injection",
        "label": "ATTACK"
      },
      {
        "start": 454,
        "text": "stole credentials",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm new into rest apis and developing an api that is going to be used for ios/android/web apps, but i'm unfamiliar with the kind of threats the apis face once published.i see these same tips all over:use oauth 2 to allow transactions,receiving and sending only encrypted json web tokens,use ssl/ttl.i think using ssl/tls and jwt should be enough security for sending/receiving data, but even with that, i fear the possibility of sql injection if someone stole credentials.should i check the requests for sql injection strings ([link])?and if i'm going to support user login, would it make more sense to use oauth instead of jwt? "
  },
  {
    "sentId": 64,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 37,
        "text": "replay attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "the major security flaw i can see is replay attacks. how do i prevent someone from getting ahold of that encrypted string, and posting as that user? i know i can use ssl to make it harder to steal that string, and maybe i can rotate the encryption key on a regular basis to limit the amount of time that the string is good for, but i'd really like to find a bulletproof solution. anybody have any ideas? does the asp.net viewstate prevent replay? if so, how do they do it? if you hash in a time-stamp along with the user name and password, you can close the window for replay attacks to within a couple of seconds. i don't know if this meets your needs, but it is at least a partial solution. "
  },
  {
    "sentId": 160,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 36,
        "text": "xss attack vector",
        "label": "ATTACK"
      }
    ],
    "sentText": "in [link] article, i'm warned of an xss attack vector [code].  i'm wondering what type of syntax [code] is.  in my brief tests on chromium, it doesn't actually get rendered into a tag, leading me to believe that the syntax is used by either an sql engine, or a server side programming language.  i'm not concerned with stored/reflected xss, only dom-based ones.  i don't recognize it though, so maybe its like ruby or python or something? "
  },
  {
    "sentId": 111,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 62,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "in rails, when i want to find by a user given value and avoid sql injection (escape apostrophes and the like) i can do something like this: i know that an unsafe way of doing this (possible sql injection) is this: my question is, does the following method prevent sql injection or not? "
  },
  {
    "sentId": 18,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "removing the strong name signature",
        "em2Text": "maliciously modifying your assembly",
        "label": "None"
      },
      {
        "em1Text": "removing the strong name signature",
        "em2Text": "re-signing it with his own key",
        "label": "None"
      },
      {
        "em1Text": "removing the strong name signature",
        "em2Text": "passing off his assembly as yours",
        "label": "None"
      },
      {
        "em1Text": "maliciously modifying your assembly",
        "em2Text": "removing the strong name signature",
        "label": "PARENT"
      },
      {
        "em1Text": "maliciously modifying your assembly",
        "em2Text": "re-signing it with his own key",
        "label": "None"
      },
      {
        "em1Text": "maliciously modifying your assembly",
        "em2Text": "passing off his assembly as yours",
        "label": "None"
      },
      {
        "em1Text": "re-signing it with his own key",
        "em2Text": "removing the strong name signature",
        "label": "None"
      },
      {
        "em1Text": "re-signing it with his own key",
        "em2Text": "maliciously modifying your assembly",
        "label": "PARENT"
      },
      {
        "em1Text": "re-signing it with his own key",
        "em2Text": "passing off his assembly as yours",
        "label": "None"
      },
      {
        "em1Text": "passing off his assembly as yours",
        "em2Text": "removing the strong name signature",
        "label": "None"
      },
      {
        "em1Text": "passing off his assembly as yours",
        "em2Text": "maliciously modifying your assembly",
        "label": "None"
      },
      {
        "em1Text": "passing off his assembly as yours",
        "em2Text": "re-signing it with his own key",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 75,
        "text": "removing the strong name signature",
        "label": "ATTACK"
      },
      {
        "start": 111,
        "text": "maliciously modifying your assembly",
        "label": "ATTACK"
      },
      {
        "start": 148,
        "text": "re-signing it with his own key",
        "label": "ATTACK"
      },
      {
        "start": 189,
        "text": "passing off his assembly as yours",
        "label": "ATTACK"
      }
    ],
    "sentText": "  \"cannot stop full replacement. strong names cannot prevent a hacker from removing the strong name signature, maliciously modifying your assembly, re-signing it with his own key, and then passing off his assembly as yours.\" "
  },
  {
    "sentId": 127,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "receipts may be fake",
        "em2Text": "hack my app",
        "label": "PARENT"
      },
      {
        "em1Text": "hack my app",
        "em2Text": "receipts may be fake",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 352,
        "text": "receipts may be fake",
        "label": "ATTACK"
      },
      {
        "start": 511,
        "text": "hack my app",
        "label": "ATTACK"
      }
    ],
    "sentText": "i read (almost) all the answers on verifying in-app purchase, and actually i already implement it in a server-side fashion. but managing a server sometimes could be too much expensive, and in theory you could do the verify from your app: basically is just sending a json to apple and get the answer back.of course i know that on jailbroken devices the receipts may be fake (that's why you verify them) but (i beg pardon my ignorance) why i can't trust an https connection to the apple server?i mean if the user hack my app, there's no real way to be sure of anything, but if the hack is a general method to provide fake receipts testing with apple could be enough right? "
  },
  {
    "sentId": 121,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 93,
        "text": "become compromised via script injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "[link] gives me concern about the potential for a [link], in a case where my application has become compromised via script injection. "
  },
  {
    "sentId": 24,
    "articleId": "6",
    "threatType": "R",
    "relationMentions": [
      {
        "em1Text": "an attacker recover the secrets in that flash",
        "em2Text": "indistinct general side channel attack",
        "label": "PARENT"
      },
      {
        "em1Text": "an attacker recover the secrets in that flash",
        "em2Text": "recover those keys",
        "label": "None"
      },
      {
        "em1Text": "an attacker recover the secrets in that flash",
        "em2Text": "shave-down the chip",
        "label": "None"
      },
      {
        "em1Text": "an attacker recover the secrets in that flash",
        "em2Text": "some kind of microscope attack",
        "label": "None"
      },
      {
        "em1Text": "indistinct general side channel attack",
        "em2Text": "an attacker recover the secrets in that flash",
        "label": "None"
      },
      {
        "em1Text": "indistinct general side channel attack",
        "em2Text": "recover those keys",
        "label": "None"
      },
      {
        "em1Text": "indistinct general side channel attack",
        "em2Text": "shave-down the chip",
        "label": "None"
      },
      {
        "em1Text": "indistinct general side channel attack",
        "em2Text": "some kind of microscope attack",
        "label": "None"
      },
      {
        "em1Text": "recover those keys",
        "em2Text": "an attacker recover the secrets in that flash",
        "label": "None"
      },
      {
        "em1Text": "recover those keys",
        "em2Text": "indistinct general side channel attack",
        "label": "None"
      },
      {
        "em1Text": "recover those keys",
        "em2Text": "shave-down the chip",
        "label": "None"
      },
      {
        "em1Text": "recover those keys",
        "em2Text": "some kind of microscope attack",
        "label": "None"
      },
      {
        "em1Text": "shave-down the chip",
        "em2Text": "an attacker recover the secrets in that flash",
        "label": "None"
      },
      {
        "em1Text": "shave-down the chip",
        "em2Text": "indistinct general side channel attack",
        "label": "None"
      },
      {
        "em1Text": "shave-down the chip",
        "em2Text": "recover those keys",
        "label": "None"
      },
      {
        "em1Text": "shave-down the chip",
        "em2Text": "some kind of microscope attack",
        "label": "OR"
      },
      {
        "em1Text": "some kind of microscope attack",
        "em2Text": "an attacker recover the secrets in that flash",
        "label": "None"
      },
      {
        "em1Text": "some kind of microscope attack",
        "em2Text": "indistinct general side channel attack",
        "label": "None"
      },
      {
        "em1Text": "some kind of microscope attack",
        "em2Text": "recover those keys",
        "label": "None"
      },
      {
        "em1Text": "some kind of microscope attack",
        "em2Text": "shave-down the chip",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 10,
        "text": "an attacker recover the secrets in that flash",
        "label": "ATTACK"
      },
      {
        "start": 161,
        "text": "indistinct general side channel attack",
        "label": "ATTACK"
      },
      {
        "start": 266,
        "text": "recover those keys",
        "label": "ATTACK"
      },
      {
        "start": 352,
        "text": "shave-down the chip",
        "label": "ATTACK"
      },
      {
        "start": 375,
        "text": "some kind of microscope attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "how might an attacker recover the secrets in that flash? i understand they can fuzz for vulnerabilities in the app code and exploit it, that there could be some indistinct general side channel attack or something. but how would an attacker really go about trying to recover those keys?  are there viable approaches for a determined attacker to somehow shave-down the chip or some kind of microscope attack? "
  },
  {
    "sentId": 22,
    "articleId": "3",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "coercive parsing attack",
        "em2Text": "exploits the nature of the xml model to overwhelm the parser",
        "label": "PARENT"
      },
      {
        "em1Text": "coercive parsing attack",
        "em2Text": "xml bombs",
        "label": "None"
      },
      {
        "em1Text": "coercive parsing attack",
        "em2Text": "exhausts the memory",
        "label": "None"
      },
      {
        "em1Text": "exploits the nature of the xml model to overwhelm the parser",
        "em2Text": "coercive parsing attack",
        "label": "None"
      },
      {
        "em1Text": "exploits the nature of the xml model to overwhelm the parser",
        "em2Text": "xml bombs",
        "label": "None"
      },
      {
        "em1Text": "exploits the nature of the xml model to overwhelm the parser",
        "em2Text": "exhausts the memory",
        "label": "None"
      },
      {
        "em1Text": "xml bombs",
        "em2Text": "coercive parsing attack",
        "label": "None"
      },
      {
        "em1Text": "xml bombs",
        "em2Text": "exploits the nature of the xml model to overwhelm the parser",
        "label": "None"
      },
      {
        "em1Text": "xml bombs",
        "em2Text": "exhausts the memory",
        "label": "PARENT"
      },
      {
        "em1Text": "exhausts the memory",
        "em2Text": "coercive parsing attack",
        "label": "None"
      },
      {
        "em1Text": "exhausts the memory",
        "em2Text": "exploits the nature of the xml model to overwhelm the parser",
        "label": "None"
      },
      {
        "em1Text": "exhausts the memory",
        "em2Text": "xml bombs",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 262,
        "text": "coercive parsing attack",
        "label": "ATTACK"
      },
      {
        "start": 634,
        "text": "exploits the nature of the xml model to overwhelm the parser",
        "label": "ATTACK"
      },
      {
        "start": 342,
        "text": "xml bombs",
        "label": "ATTACK"
      },
      {
        "start": 751,
        "text": "exhausts the memory",
        "label": "ATTACK"
      }
    ],
    "sentText": "xml has been the backbone of the service oriented application(soa) and it will be a useful one in the coming future.as xml is easy , flexible, it can be easily made vulnerable and the attackers can use it for their own purpose.as such some of the attacks by are coercive parsing attack, xml external entity(xee) attack, xml dos(xdos) attack, xml bombs.can any one tell in detail about these attacks.how could one can simulate these attacks practically in a single system? i don't think there is percise definition of a \"bomb\", but it refers to an attack that is particularly \"compact\" and which \"expands\". a \"coercive parsing attack\" exploits the nature of the xml model to overwhelm the parser. a bomb using entities which result in a dos because it exhausts the memory "
  },
  {
    "sentId": 34,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 40,
        "text": "csrf attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "the antiforgerytoken is used to prevent csrf attacks, however the links on msdn don't give me much insight to what exactly the antiforgerytoken does, or how it works, or why things are done the way they are. "
  },
  {
    "sentId": 11,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 23,
        "text": "removes \"dangerous\" attributes and tags from html",
        "label": "ATTACK"
      }
    ],
    "sentText": "we have some code that removes \"dangerous\" attributes and tags from html.  i noticed that [code] is among the list of \"dangerous\" attributes.  what could be the risk from that attribute? "
  },
  {
    "sentId": 145,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 89,
        "text": "forged request attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'd like to make it both easy to use from client-side javascript apps and secure against forged request attacks. is there a best practice to follow here? "
  },
  {
    "sentId": 3,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "inject malicious code",
        "em2Text": "reroute the program logic",
        "label": "OR"
      },
      {
        "em1Text": "inject malicious code",
        "em2Text": "access memory addresses that fall outside legitimately allocated buffers",
        "label": "PARENT"
      },
      {
        "em1Text": "reroute the program logic",
        "em2Text": "inject malicious code",
        "label": "None"
      },
      {
        "em1Text": "reroute the program logic",
        "em2Text": "access memory addresses that fall outside legitimately allocated buffers",
        "label": "PARENT"
      },
      {
        "em1Text": "access memory addresses that fall outside legitimately allocated buffers",
        "em2Text": "inject malicious code",
        "label": "None"
      },
      {
        "em1Text": "access memory addresses that fall outside legitimately allocated buffers",
        "em2Text": "reroute the program logic",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 15,
        "text": "inject malicious code",
        "label": "ATTACK"
      },
      {
        "start": 41,
        "text": "reroute the program logic",
        "label": "ATTACK"
      },
      {
        "start": 101,
        "text": "access memory addresses that fall outside legitimately allocated buffers",
        "label": "ATTACK"
      }
    ],
    "sentText": "the ability to inject malicious code, or reroute the program logic depends entirely on being able to access memory addresses that fall outside legitimately allocated buffers.  but in a language like java, this is simply impossible.  the worst that could happen is a program will terminate with an [code], leading to a denial-of-service.   "
  },
  {
    "sentId": 21,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "upload images to the actual site",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "upload images to the actual site",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 19,
        "text": "upload images to the actual site",
        "label": "ATTACK"
      },
      {
        "start": 679,
        "text": "xss",
        "label": "ATTACK"
      }
    ],
    "sentText": "if i allow them to upload images to the actual site, it seems like this will quickly become expensive (this is a side project, not funded by anyone than myself and my own obsessions). let's say the site becomes moderately popular, with 100k users posting one image a week, of only 250k in size. that's (100000 * .1 * 52 / 1024) = 508 mb/year in storage (and that doesn't take into account increased bandwidth). plus i'd have to increase the server load to scale the images. i'm not sure if i should just go ahead with this, or if there are better possibilities. linking to other sites seems better in some ways. you do have broken links, but a larger concern for me is security: xss. my objectives are (in order): - secure, both for my own site, and to not allow xss attacks against other sites - best possible user experience - easy to maintain and implement "
  },
  {
    "sentId": 106,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "php is gets compromised",
        "em2Text": "malicious user will not be able to obtain the details needed for connection string for mysql",
        "label": "None"
      },
      {
        "em1Text": "php is gets compromised",
        "em2Text": "the user has broken the root login of the linux box running php",
        "label": "None"
      },
      {
        "em1Text": "malicious user will not be able to obtain the details needed for connection string for mysql",
        "em2Text": "php is gets compromised",
        "label": "None"
      },
      {
        "em1Text": "malicious user will not be able to obtain the details needed for connection string for mysql",
        "em2Text": "the user has broken the root login of the linux box running php",
        "label": "None"
      },
      {
        "em1Text": "the user has broken the root login of the linux box running php",
        "em2Text": "php is gets compromised",
        "label": "None"
      },
      {
        "em1Text": "the user has broken the root login of the linux box running php",
        "em2Text": "malicious user will not be able to obtain the details needed for connection string for mysql",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 81,
        "text": "php is gets compromised",
        "label": "ATTACK"
      },
      {
        "start": 304,
        "text": "malicious user will not be able to obtain the details needed for connection string for mysql",
        "label": "ATTACK"
      },
      {
        "start": 410,
        "text": "the user has broken the root login of the linux box running php",
        "label": "ATTACK"
      }
    ],
    "sentText": "how to secure database credentials in a web application in case the server where php is gets compromised?assume that in this problem's case we are not talking about shared hosting, vps or anything alike, there's only one person who has access to the box that stores mysql information. how to ensure that malicious user will not be able to obtain the details needed for connection string for mysql? assume that the user has broken the root login of the linux box running php. "
  },
  {
    "sentId": 5,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "this attack to work",
        "em2Text": "use a fileupload at some point",
        "label": "PARENT"
      },
      {
        "em1Text": "this attack to work",
        "em2Text": "the files stored must be executed via php",
        "label": "None"
      },
      {
        "em1Text": "use a fileupload at some point",
        "em2Text": "this attack to work",
        "label": "None"
      },
      {
        "em1Text": "use a fileupload at some point",
        "em2Text": "the files stored must be executed via php",
        "label": "AND"
      },
      {
        "em1Text": "the files stored must be executed via php",
        "em2Text": "this attack to work",
        "label": "None"
      },
      {
        "em1Text": "the files stored must be executed via php",
        "em2Text": "use a fileupload at some point",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 16,
        "text": "this attack to work",
        "label": "ATTACK"
      },
      {
        "start": 88,
        "text": "use a fileupload at some point",
        "label": "ATTACK"
      },
      {
        "start": 138,
        "text": "the files stored must be executed via php",
        "label": "ATTACK"
      }
    ],
    "sentText": "so in order for this attack to work, you need to have two conditions : the website must use a fileupload at some point that you can accessthe files stored must be executed via php, even the image files (in that case). "
  },
  {
    "sentId": 49,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 66,
        "text": "unauthorized changes",
        "label": "ATTACK"
      }
    ],
    "sentText": "so then the next question came. how do i secure my app to prevent unauthorized changes? in doing some research i found a couple articles talking about [code] and [code] and how they can be used. the particular url i found talking about these was posted back in may of '07 ([link]).  "
  },
  {
    "sentId": 149,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "database was stolen",
        "em2Text": "a thief might be able to gain access to user user accounts on 3rd party websites",
        "label": "None"
      },
      {
        "em1Text": "a thief might be able to gain access to user user accounts on 3rd party websites",
        "em2Text": "database was stolen",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 200,
        "text": "database was stolen",
        "label": "ATTACK"
      },
      {
        "start": 221,
        "text": "a thief might be able to gain access to user user accounts on 3rd party websites",
        "label": "ATTACK"
      }
    ],
    "sentText": "i understand that passwords should be encrypted using a 1-way hash function with salt.  this is especially true for user supplied passwords as users typically re-use them over and over again.  if the database was stolen, a thief might be able to gain access to user user accounts on 3rd party websites such as: utility bills, social networks, even potential for online banking. because the temporary password would be machine generated, if the database was stolen, the thief would not be able to access any 3rd party websites that the users log into.  the thief would however be able to login to the application that generated the temporary passwords. "
  },
  {
    "sentId": 109,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 95,
        "text": "open up the users computer for malicious code",
        "label": "ATTACK"
      }
    ],
    "sentText": "i also read [link], telling me that i should not request all permissions, because i would then open up the users computer for malicious code. "
  },
  {
    "sentId": 25,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 64,
        "text": "users can execute malicious sql on your website",
        "label": "ATTACK"
      }
    ],
    "sentText": "when you execute a sql query, you have to clean your strings or users can execute malicious sql on your website. "
  },
  {
    "sentId": 43,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "decompilers",
        "em2Text": "get the key",
        "label": "None"
      },
      {
        "em1Text": "get the key",
        "em2Text": "decompilers",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 464,
        "text": "decompilers",
        "label": "ATTACK"
      },
      {
        "start": 480,
        "text": "get the key",
        "label": "ATTACK"
      }
    ],
    "sentText": "regardless of the programming languagei have a client server application.mobile client - http serverthe app will be available on several mobiles not only android.i want to make sure the request is coming from client's mobile only.how can i solve this security problem?i propose :have a secret key hard-coded on the mobile app:each request is encrypted using this key and decrypted on the server side.is it safe to hardcode the key if this way makes sense at all? (decompilers can get the key? the app will be available not only for android!)extra info:each user will have a userid/username... "
  },
  {
    "sentId": 62,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "allow community members to supply their own javascript code",
        "em2Text": "a script has control",
        "label": "None"
      },
      {
        "em1Text": "a script has control",
        "em2Text": "allow community members to supply their own javascript code",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 23,
        "text": "allow community members to supply their own javascript code",
        "label": "ATTACK"
      },
      {
        "start": 333,
        "text": "a script has control",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'd like to be able to allow community members to supply their own javascript code for others to use, because the users' imaginations are collectively far greater than anything i could think of. well createelement('iframe').src='http\u9225?//evil.iframeexploitz.ru/aff=2345' is one of the worse attacks you can expect... but really, when a script has control, it can do anything a user can on your site. it can make them post \u9225\u6dda'm a big old paedophile!\u9225?a thousand times on your forums and then delete their own account. for example. "
  },
  {
    "sentId": 97,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "an attacker has access to the settings file",
        "em2Text": "all is probably already lost",
        "label": "None"
      },
      {
        "em1Text": "an attacker has access to the settings file",
        "em2Text": "attacker would probably have the means to decrypt it",
        "label": "OR"
      },
      {
        "em1Text": "all is probably already lost",
        "em2Text": "an attacker has access to the settings file",
        "label": "PARENT"
      },
      {
        "em1Text": "all is probably already lost",
        "em2Text": "attacker would probably have the means to decrypt it",
        "label": "None"
      },
      {
        "em1Text": "attacker would probably have the means to decrypt it",
        "em2Text": "an attacker has access to the settings file",
        "label": "None"
      },
      {
        "em1Text": "attacker would probably have the means to decrypt it",
        "em2Text": "all is probably already lost",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 131,
        "text": "an attacker has access to the settings file",
        "label": "ATTACK"
      },
      {
        "start": 181,
        "text": "all is probably already lost",
        "label": "ATTACK"
      },
      {
        "start": 252,
        "text": "attacker would probably have the means to decrypt it",
        "label": "ATTACK"
      }
    ],
    "sentText": "i can't seem to think of a better way at the moment, but this seems to be against best practices for password storage. granted, if an attacker has access to the settings file, then all is probably already lost. even if the the file were encrypted, the attacker would probably have the means to decrypt it by then. "
  },
  {
    "sentId": 117,
    "articleId": "4",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "adds a slash",
        "em2Text": "encoded javascript",
        "label": "None"
      },
      {
        "em1Text": "adds a slash",
        "em2Text": "kills the page",
        "label": "None"
      },
      {
        "em1Text": "encoded javascript",
        "em2Text": "adds a slash",
        "label": "PARENT"
      },
      {
        "em1Text": "encoded javascript",
        "em2Text": "kills the page",
        "label": "None"
      },
      {
        "em1Text": "kills the page",
        "em2Text": "adds a slash",
        "label": "None"
      },
      {
        "em1Text": "kills the page",
        "em2Text": "encoded javascript",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 40,
        "text": "adds a slash",
        "label": "ATTACK"
      },
      {
        "start": 63,
        "text": "encoded javascript",
        "label": "ATTACK"
      },
      {
        "start": 119,
        "text": "kills the page",
        "label": "ATTACK"
      }
    ],
    "sentText": "the problem is that the attacker simply adds a slash then some encoded javascript (an image tag with alert box), which kills the page.  simple and effective attack.   "
  },
  {
    "sentId": 35,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "alter the ldap query",
        "em2Text": "injecting malicious code",
        "label": "PARENT"
      },
      {
        "em1Text": "injecting malicious code",
        "em2Text": "alter the ldap query",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 193,
        "text": "alter the ldap query",
        "label": "ATTACK"
      },
      {
        "start": 217,
        "text": "injecting malicious code",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am working on my first desktop app that queries ldap. i'm working in c under unix and using opends, and i'm new to ldap. after woking a while on that i noticed that the user could be able to alter the ldap query by injecting malicious code.i'd like to know which sanitizing techniques are known, not only for c/unix development but in more general terms, i.e., web development etc.i thought that escaping equals and semicolons would be enough, but not sure. "
  },
  {
    "sentId": 100,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "pgp or symmetric encryption are equally vulnerable",
        "em2Text": "authentication is not possible",
        "label": "PARENT"
      },
      {
        "em1Text": "pgp or symmetric encryption are equally vulnerable",
        "em2Text": "the keys are stolen",
        "label": "None"
      },
      {
        "em1Text": "authentication is not possible",
        "em2Text": "pgp or symmetric encryption are equally vulnerable",
        "label": "None"
      },
      {
        "em1Text": "authentication is not possible",
        "em2Text": "the keys are stolen",
        "label": "AND"
      },
      {
        "em1Text": "the keys are stolen",
        "em2Text": "pgp or symmetric encryption are equally vulnerable",
        "label": "None"
      },
      {
        "em1Text": "the keys are stolen",
        "em2Text": "authentication is not possible",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 130,
        "text": "pgp or symmetric encryption are equally vulnerable",
        "label": "ATTACK"
      },
      {
        "start": 408,
        "text": "authentication is not possible",
        "label": "ATTACK"
      },
      {
        "start": 442,
        "text": "the keys are stolen",
        "label": "ATTACK"
      }
    ],
    "sentText": "pgp requires to store keys on client app.there seems to be no assuring way of securing keys on client app.if the key is out, then pgp or symmetric encryption are equally vulnerable.reverse-engineering pgp keys or symmetic keys is equally hard.in that case pgp is a non-sense burden on the mobile processor.oauth is again useless, since it also have a client key. use simple ssl and cross my fingers ?, since authentication is not possible if the keys are stolen? (only server authentication is possible with this) "
  },
  {
    "sentId": 97,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "circumvent security",
        "em2Text": "exploit vulnerabilities in standard software packages",
        "label": "AND"
      },
      {
        "em1Text": "exploit vulnerabilities in standard software packages",
        "em2Text": "circumvent security",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 89,
        "text": "circumvent security",
        "label": "ATTACK"
      },
      {
        "start": 113,
        "text": "exploit vulnerabilities in standard software packages",
        "label": "ATTACK"
      }
    ],
    "sentText": "it lead to an interesting finding quite fast: they are astonishingly lots of attempts to circumvent security and exploit vulnerabilities in standard software packages that are commonly found on sites, like phpmyadmin, forums, etc. "
  },
  {
    "sentId": 119,
    "articleId": "6",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "ip address spoofing",
        "em2Text": "dos attack",
        "label": "None"
      },
      {
        "em1Text": "ip address spoofing",
        "em2Text": "registering for many accounts",
        "label": "None"
      },
      {
        "em1Text": "ip address spoofing",
        "em2Text": "cause my system to send out a high volume of welcome emails",
        "label": "None"
      },
      {
        "em1Text": "ip address spoofing",
        "em2Text": "prevent users from signing up",
        "label": "None"
      },
      {
        "em1Text": "ip address spoofing",
        "em2Text": "their email account was maliciously registered",
        "label": "None"
      },
      {
        "em1Text": "dos attack",
        "em2Text": "ip address spoofing",
        "label": "None"
      },
      {
        "em1Text": "dos attack",
        "em2Text": "registering for many accounts",
        "label": "PARENT"
      },
      {
        "em1Text": "dos attack",
        "em2Text": "cause my system to send out a high volume of welcome emails",
        "label": "None"
      },
      {
        "em1Text": "dos attack",
        "em2Text": "prevent users from signing up",
        "label": "None"
      },
      {
        "em1Text": "dos attack",
        "em2Text": "their email account was maliciously registered",
        "label": "None"
      },
      {
        "em1Text": "registering for many accounts",
        "em2Text": "ip address spoofing",
        "label": "None"
      },
      {
        "em1Text": "registering for many accounts",
        "em2Text": "dos attack",
        "label": "None"
      },
      {
        "em1Text": "registering for many accounts",
        "em2Text": "cause my system to send out a high volume of welcome emails",
        "label": "None"
      },
      {
        "em1Text": "registering for many accounts",
        "em2Text": "prevent users from signing up",
        "label": "None"
      },
      {
        "em1Text": "registering for many accounts",
        "em2Text": "their email account was maliciously registered",
        "label": "None"
      },
      {
        "em1Text": "cause my system to send out a high volume of welcome emails",
        "em2Text": "ip address spoofing",
        "label": "None"
      },
      {
        "em1Text": "cause my system to send out a high volume of welcome emails",
        "em2Text": "dos attack",
        "label": "PARENT"
      },
      {
        "em1Text": "cause my system to send out a high volume of welcome emails",
        "em2Text": "registering for many accounts",
        "label": "None"
      },
      {
        "em1Text": "cause my system to send out a high volume of welcome emails",
        "em2Text": "prevent users from signing up",
        "label": "None"
      },
      {
        "em1Text": "cause my system to send out a high volume of welcome emails",
        "em2Text": "their email account was maliciously registered",
        "label": "None"
      },
      {
        "em1Text": "prevent users from signing up",
        "em2Text": "ip address spoofing",
        "label": "None"
      },
      {
        "em1Text": "prevent users from signing up",
        "em2Text": "dos attack",
        "label": "None"
      },
      {
        "em1Text": "prevent users from signing up",
        "em2Text": "registering for many accounts",
        "label": "None"
      },
      {
        "em1Text": "prevent users from signing up",
        "em2Text": "cause my system to send out a high volume of welcome emails",
        "label": "None"
      },
      {
        "em1Text": "prevent users from signing up",
        "em2Text": "their email account was maliciously registered",
        "label": "PARENT"
      },
      {
        "em1Text": "their email account was maliciously registered",
        "em2Text": "ip address spoofing",
        "label": "None"
      },
      {
        "em1Text": "their email account was maliciously registered",
        "em2Text": "dos attack",
        "label": "PARENT"
      },
      {
        "em1Text": "their email account was maliciously registered",
        "em2Text": "registering for many accounts",
        "label": "None"
      },
      {
        "em1Text": "their email account was maliciously registered",
        "em2Text": "cause my system to send out a high volume of welcome emails",
        "label": "None"
      },
      {
        "em1Text": "their email account was maliciously registered",
        "em2Text": "prevent users from signing up",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 47,
        "text": "ip address spoofing",
        "label": "ATTACK"
      },
      {
        "start": 266,
        "text": "dos attack",
        "label": "ATTACK"
      },
      {
        "start": 280,
        "text": "registering for many accounts",
        "label": "ATTACK"
      },
      {
        "start": 385,
        "text": "cause my system to send out a high volume of welcome emails",
        "label": "ATTACK"
      },
      {
        "start": 501,
        "text": "prevent users from signing up",
        "label": "ATTACK"
      },
      {
        "start": 534,
        "text": "their email account was maliciously registered",
        "label": "ATTACK"
      }
    ],
    "sentText": "however, i believe i've run into an issue with ip address spoofing. i know the real client will never receive a response back if they spoof their ip address, but that may not be necessary for a call such as a create account call. a client could effectively create a dos attack by registering for many accounts, all with different ips, all the while avoiding the rate limit. this would cause my system to send out a high volume of welcome emails (leading to my servers being marked as spam), and could prevent users from signing up if their email account was maliciously registered. how can this be avoided? "
  },
  {
    "sentId": 83,
    "articleId": "2",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "use atom tables",
        "em2Text": "store executable code",
        "label": "None"
      },
      {
        "em1Text": "store executable code",
        "em2Text": "use atom tables",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 149,
        "text": "use atom tables",
        "label": "ATTACK"
      },
      {
        "start": 168,
        "text": "store executable code",
        "label": "ATTACK"
      }
    ],
    "sentText": "the security world has been abuzz over a new code injection technique called \"atom bombing\" (see [link] and [link]).  simply stated, an attacker can use atom tables to store executable code. "
  },
  {
    "sentId": 109,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 0,
        "text": "[link][link]",
        "label": "ATTACK"
      }
    ],
    "sentText": "[link][link] "
  },
  {
    "sentId": 59,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "someone may steal that user's remember key",
        "em2Text": "spoof the user's identity",
        "label": "None"
      },
      {
        "em1Text": "someone may steal that user's remember key",
        "em2Text": "change his password",
        "label": "None"
      },
      {
        "em1Text": "spoof the user's identity",
        "em2Text": "someone may steal that user's remember key",
        "label": "PARENT"
      },
      {
        "em1Text": "spoof the user's identity",
        "em2Text": "change his password",
        "label": "None"
      },
      {
        "em1Text": "change his password",
        "em2Text": "someone may steal that user's remember key",
        "label": "None"
      },
      {
        "em1Text": "change his password",
        "em2Text": "spoof the user's identity",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 31,
        "text": "someone may steal that user's remember key",
        "label": "ATTACK"
      },
      {
        "start": 92,
        "text": "spoof the user's identity",
        "label": "ATTACK"
      },
      {
        "start": 137,
        "text": "change his password",
        "label": "ATTACK"
      }
    ],
    "sentText": "makes it much more likely that someone may steal that user's remember key, allowing them to spoof the user's identity (and then probably change his password);[link] - [link]. your feature will effectively allow an anonymous attacker to cause unknowing users to submit \"authenticated\" requests to your application, even without being actually logged in. "
  },
  {
    "sentId": 3,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 68,
        "text": "end up with evil/dangerous ones",
        "label": "ATTACK"
      }
    ],
    "sentText": "at best you could end up with invalid keywords.  at worst you could end up with evil/dangerous ones, as micha\u8242 marczyk said.  keep in mind that [code] can be used to run arbitrary code at read-time, so you don't even have to evaluate a string for bad things to happen, you only have to read it. "
  },
  {
    "sentId": 5,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "the following query",
        "em2Text": "any possible injection that would get through the php",
        "label": "None"
      },
      {
        "em1Text": "any possible injection that would get through the php",
        "em2Text": "the following query",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 90,
        "text": "the following query",
        "label": "ATTACK"
      },
      {
        "start": 15,
        "text": "any possible injection that would get through the php",
        "label": "ATTACK"
      }
    ],
    "sentText": "do you know of any possible injection that would get through the php code above? consider the following query: "
  },
  {
    "sentId": 71,
    "articleId": "2",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "running [code]",
        "em2Text": "run any javascript code that you can run",
        "label": "None"
      },
      {
        "em1Text": "run any javascript code that you can run",
        "em2Text": "running [code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 85,
        "text": "running [code]",
        "label": "ATTACK"
      },
      {
        "start": 132,
        "text": "run any javascript code that you can run",
        "label": "ATTACK"
      }
    ],
    "sentText": "however, i do not understand the concerns about security vulnerabilities. certainly, running [code] gives the hacker the ability to run any javascript code that you can run. "
  },
  {
    "sentId": 77,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "include an img tag in their html page",
        "em2Text": "does a get on some well-known uri",
        "label": "None"
      },
      {
        "em1Text": "include an img tag in their html page",
        "em2Text": "your browser will happily send along the basic auth info",
        "label": "None"
      },
      {
        "em1Text": "does a get on some well-known uri",
        "em2Text": "include an img tag in their html page",
        "label": "PARENT"
      },
      {
        "em1Text": "does a get on some well-known uri",
        "em2Text": "your browser will happily send along the basic auth info",
        "label": "None"
      },
      {
        "em1Text": "your browser will happily send along the basic auth info",
        "em2Text": "include an img tag in their html page",
        "label": "None"
      },
      {
        "em1Text": "your browser will happily send along the basic auth info",
        "em2Text": "does a get on some well-known uri",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 93,
        "text": "include an img tag in their html page",
        "label": "ATTACK"
      },
      {
        "start": 136,
        "text": "does a get on some well-known uri",
        "label": "ATTACK"
      },
      {
        "start": 175,
        "text": "your browser will happily send along the basic auth info",
        "label": "ATTACK"
      }
    ],
    "sentText": "using http basic auth does not prevent csrf attacks via get requests. e.g. somebody else can include an img tag in their html page that does a get on some well-known uri, and your browser will happily send along the basic auth info. if the get operation is \"safe\" (which is the #1 rule for anything claiming to be restful), this will not create a problem (beyond wasted bandwidth). "
  },
  {
    "sentId": 67,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 137,
        "text": "write malicious code",
        "label": "ATTACK"
      }
    ],
    "sentText": "i want to make my application to run other people's code, aka plugins. however, what options do i have to make this secure so they don't write malicious code. how do i control what they can or can not do? "
  },
  {
    "sentId": 108,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 22,
        "text": "malicious uploading a short shell script",
        "label": "ATTACK"
      }
    ],
    "sentText": "now, consider someone malicious uploading a short shell script: "
  },
  {
    "sentId": 139,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "malicious users could post twitter status updates masquerading as coming from my app",
        "em2Text": "malicious users could create links on my bit.ly account",
        "label": "None"
      },
      {
        "em1Text": "malicious users could post twitter status updates masquerading as coming from my app",
        "em2Text": "they would need to do a separate attack",
        "label": "None"
      },
      {
        "em1Text": "malicious users could post twitter status updates masquerading as coming from my app",
        "em2Text": "brute-force",
        "label": "None"
      },
      {
        "em1Text": "malicious users could create links on my bit.ly account",
        "em2Text": "malicious users could post twitter status updates masquerading as coming from my app",
        "label": "None"
      },
      {
        "em1Text": "malicious users could create links on my bit.ly account",
        "em2Text": "they would need to do a separate attack",
        "label": "None"
      },
      {
        "em1Text": "malicious users could create links on my bit.ly account",
        "em2Text": "brute-force",
        "label": "None"
      },
      {
        "em1Text": "they would need to do a separate attack",
        "em2Text": "malicious users could post twitter status updates masquerading as coming from my app",
        "label": "None"
      },
      {
        "em1Text": "they would need to do a separate attack",
        "em2Text": "malicious users could create links on my bit.ly account",
        "label": "None"
      },
      {
        "em1Text": "they would need to do a separate attack",
        "em2Text": "brute-force",
        "label": "AND"
      },
      {
        "em1Text": "brute-force",
        "em2Text": "malicious users could post twitter status updates masquerading as coming from my app",
        "label": "None"
      },
      {
        "em1Text": "brute-force",
        "em2Text": "malicious users could create links on my bit.ly account",
        "label": "None"
      },
      {
        "em1Text": "brute-force",
        "em2Text": "they would need to do a separate attack",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "malicious users could post twitter status updates masquerading as coming from my app",
        "label": "ATTACK"
      },
      {
        "start": 161,
        "text": "malicious users could create links on my bit.ly account",
        "label": "ATTACK"
      },
      {
        "start": 218,
        "text": "they would need to do a separate attack",
        "label": "ATTACK"
      },
      {
        "start": 261,
        "text": "brute-force",
        "label": "ATTACK"
      }
    ],
    "sentText": "malicious users could post twitter status updates masquerading as coming from my app. there is no twitter account to hijack and start posting status updates on. malicious users could create links on my bit.ly account. they would need to do a separate attack to brute-force or otherwise gain the password to login to the account. "
  },
  {
    "sentId": 98,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "malicious user logs in using his browser",
        "em2Text": "downloads game",
        "label": "AND"
      },
      {
        "em1Text": "malicious user logs in using his browser",
        "em2Text": "submits score",
        "label": "None"
      },
      {
        "em1Text": "downloads game",
        "em2Text": "malicious user logs in using his browser",
        "label": "None"
      },
      {
        "em1Text": "downloads game",
        "em2Text": "submits score",
        "label": "None"
      },
      {
        "em1Text": "submits score",
        "em2Text": "malicious user logs in using his browser",
        "label": "PARENT"
      },
      {
        "em1Text": "submits score",
        "em2Text": "downloads game",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 160,
        "text": "malicious user logs in using his browser",
        "label": "ATTACK"
      },
      {
        "start": 202,
        "text": "downloads game",
        "label": "ATTACK"
      },
      {
        "start": 228,
        "text": "submits score",
        "label": "ATTACK"
      }
    ],
    "sentText": "create a script &amp; run it to create automatic users  - i think i can prevent it by captcha or someting like that. but again, captcha will annoy game players.malicious user logs in using his browser, downloads game &amp; then submits score as he wish - all via calling the api by simply typing it from his browser. i assume malicious user somehow knows api urls to call - by sniffing when the application was making http requests.i need to ensure that requests are made only from android device that installed the game. (the game will be free) "
  },
  {
    "sentId": 46,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 33,
        "text": "dictionary attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "what's the best way to prevent a dictionary attack? "
  },
  {
    "sentId": 113,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "cookies can be stolen",
        "em2Text": "xss attacks",
        "label": "PARENT"
      },
      {
        "em1Text": "cookies can be stolen",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "cookies can be stolen",
        "label": "None"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "csrf",
        "label": "PARENT"
      },
      {
        "em1Text": "csrf",
        "em2Text": "cookies can be stolen",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "xss attacks",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 4,
        "text": "cookies can be stolen",
        "label": "ATTACK"
      },
      {
        "start": 30,
        "text": "xss attacks",
        "label": "ATTACK"
      },
      {
        "start": 96,
        "text": "csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "no. cookies can be stolen via xss attacks (and other vectors)also, this might be susceptible to csrf since a cookie will be submitted automatically with any request. "
  },
  {
    "sentId": 107,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "malicious user could give themselves a free 10-year subscription",
        "em2Text": "faking the date",
        "label": "PARENT"
      },
      {
        "em1Text": "faking the date",
        "em2Text": "malicious user could give themselves a free 10-year subscription",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 155,
        "text": "malicious user could give themselves a free 10-year subscription",
        "label": "ATTACK"
      },
      {
        "start": 223,
        "text": "faking the date",
        "label": "ATTACK"
      }
    ],
    "sentText": "if i provide an edit page to let users change their own address, for example, it's a security risk to include the [code] field because a knowledgeable and malicious user could give themselves a free 10-year subscription by faking the date (even if i use [code]. so i am not including that field in any way on the edit page html (via razor). "
  },
  {
    "sentId": 66,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 166,
        "text": "man-in-the-middle attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "while improving the security of an ios application that we are developing, we found the need to pin (the entire or parts of) the ssl certificate of server to prevent man-in-the-middle attacks.  "
  },
  {
    "sentId": 87,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "managed to get a hyperlink in the text",
        "em2Text": "htmlentities() does not remove it",
        "label": "AND"
      },
      {
        "em1Text": "managed to get a hyperlink in the text",
        "em2Text": "send some data",
        "label": "None"
      },
      {
        "em1Text": "htmlentities() does not remove it",
        "em2Text": "managed to get a hyperlink in the text",
        "label": "None"
      },
      {
        "em1Text": "htmlentities() does not remove it",
        "em2Text": "send some data",
        "label": "None"
      },
      {
        "em1Text": "send some data",
        "em2Text": "managed to get a hyperlink in the text",
        "label": "None"
      },
      {
        "em1Text": "send some data",
        "em2Text": "htmlentities() does not remove it",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 28,
        "text": "managed to get a hyperlink in the text",
        "label": "ATTACK"
      },
      {
        "start": 71,
        "text": "htmlentities() does not remove it",
        "label": "ATTACK"
      },
      {
        "start": 121,
        "text": "send some data",
        "label": "ATTACK"
      }
    ],
    "sentText": "the problem is that someone managed to get a hyperlink in the text and htmlentities() does not remove it. now the hacker send some data and this was the result html: "
  },
  {
    "sentId": 16,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "use any of the json data",
        "em2Text": "json data being assigned to a variable that you can access globally",
        "label": "PARENT"
      },
      {
        "em1Text": "json data being assigned to a variable that you can access globally",
        "em2Text": "use any of the json data",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 99,
        "text": "use any of the json data",
        "label": "ATTACK"
      },
      {
        "start": 132,
        "text": "json data being assigned to a variable that you can access globally",
        "label": "ATTACK"
      }
    ],
    "sentText": "google returns json like this:[code]but even without the crash script prepended the attacker can't use any of the json data without json data being assigned to a variable that you can access globally (it isn't in these cases). the crash code effectivly does nothing because even without it they have to use server sided scripting to use the data on their site. "
  },
  {
    "sentId": 83,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "hijacks the dns server",
        "em2Text": "arp poisoning or something similar",
        "label": "OR"
      },
      {
        "em1Text": "hijacks the dns server",
        "em2Text": "man-in-the-middle attack",
        "label": "None"
      },
      {
        "em1Text": "arp poisoning or something similar",
        "em2Text": "hijacks the dns server",
        "label": "None"
      },
      {
        "em1Text": "arp poisoning or something similar",
        "em2Text": "man-in-the-middle attack",
        "label": "None"
      },
      {
        "em1Text": "man-in-the-middle attack",
        "em2Text": "hijacks the dns server",
        "label": "PARENT"
      },
      {
        "em1Text": "man-in-the-middle attack",
        "em2Text": "arp poisoning or something similar",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 1550,
        "text": "hijacks the dns server",
        "label": "ATTACK"
      },
      {
        "start": 1608,
        "text": "arp poisoning or something similar",
        "label": "ATTACK"
      },
      {
        "start": 516,
        "text": "man-in-the-middle attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "no ssl. this might be acceptable if our customers aren't worried about their employees seeing/changing each others' data. their employees might want to share results with each other anyway, and i could use ip based access control and/or passwords for security.do ssl with no certificate. this encrypts the communication, which at least protects the data from being read by unauthorized employees. using a password, this is the same level of security as [code] on the command line, right? i don't need to worry about man-in-the-middle attacks in an intranet, right? a con for this approach would be if there were loads of browser warning messages.do ssl with a self-signed certificate. what does this give me that no certificate gives me? if the dns can be changed inappropriately, then the customer then my application is the least of their concerns. worded another way, if the dns can change, then i think [code] would be vulnerable too.do ssl with a local certificate authority. openssl lets me make my own certificate authority. what does this give me that a self-signed certificate does not? i'm assuming that on a lan, it's less important for the server to be verified. do ssl with an external certificate authority. is there ever a reason to go this route for an intranet? i found some \"intranet certificates\" for sale online -- but it's not clear what they're offering i can't do myself. ssl-without-a-certificate, on the other hand, does not store the server's fingerprint. your communications will still be encrypted, but if someone somehow hijacks the dns server as you mentioned, or, [link], does arp poisoning or something similar, they would be able to perform a man-in-the-middle attack. ssh, as previously mentioned, would (supposing you had connected to the correct server some time in the past) notice that the fingerprint had changed and alert you. "
  },
  {
    "sentId": 8,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "generate a url from non-sanitized request parameters",
        "em2Text": "inject malicious data into the generated url",
        "label": "None"
      },
      {
        "em1Text": "inject malicious data into the generated url",
        "em2Text": "generate a url from non-sanitized request parameters",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 16,
        "text": "generate a url from non-sanitized request parameters",
        "label": "ATTACK"
      },
      {
        "start": 86,
        "text": "inject malicious data into the generated url",
        "label": "ATTACK"
      }
    ],
    "sentText": "  attempting to generate a url from non-sanitized request parameters! an attacker can inject malicious data into the generated url, such as changing the host. whitelist and sanitize passed parameters to be secure. "
  },
  {
    "sentId": 27,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "another application has access to your cookies",
        "em2Text": "impersonate you on the website anyway",
        "label": "None"
      },
      {
        "em1Text": "impersonate you on the website anyway",
        "em2Text": "another application has access to your cookies",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 3,
        "text": "another application has access to your cookies",
        "label": "ATTACK"
      },
      {
        "start": 65,
        "text": "impersonate you on the website anyway",
        "label": "ATTACK"
      }
    ],
    "sentText": "if another application has access to your cookies, then they can impersonate you on the website anyway, so access to the api is no different.all authentication methods still go through our control.regular expiry of tokens means that if they are compromised then there is a limited time for exploitation. "
  },
  {
    "sentId": 11,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 146,
        "text": "read the plain-text password used to access the external service",
        "label": "ATTACK"
      }
    ],
    "sentText": "edit: due to discussion raised in the comments, let me clarify the threat i'm trying to address: i want to prevent an attacker from being able to read the plain-text password used to access the external service. meaning that if they somehow gained non-admin access to our network or database, even with the database dump they would not be able to read the passwords in plain text. "
  },
  {
    "sentId": 76,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "attacker has the iv and a cipher text message",
        "em2Text": "dictionary attack",
        "label": "None"
      },
      {
        "em1Text": "dictionary attack",
        "em2Text": "attacker has the iv and a cipher text message",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 394,
        "text": "attacker has the iv and a cipher text message",
        "label": "ATTACK"
      },
      {
        "start": 291,
        "text": "dictionary attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "i understand the purpose of an iv. specifically in cbc mode this insures that the first block of of 2 messages encrypted with the same key will never be identical.  but why is it a vulnerability if the iv's are sequential?  according to [link] non-random iv's allow for the possibility of a dictionary attack.  i know that in practice protocols like wep make no effort to hide the iv.   if the attacker has the iv and a cipher text message then this opens the door for a dictionary attack against the key.  i don't see how a random iv changes this.  (i know the attacks against wep are more complex than this.) "
  },
  {
    "sentId": 69,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "don't prompt the user when creating a communication channel ",
        "em2Text": "easy prey \"man in the middle\" attacks",
        "label": "None"
      },
      {
        "em1Text": "easy prey \"man in the middle\" attacks",
        "em2Text": "don't prompt the user when creating a communication channel ",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 50,
        "text": "don't prompt the user when creating a communication channel ",
        "label": "ATTACK"
      },
      {
        "start": 132,
        "text": "easy prey \"man in the middle\" attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "the only advantage in using insecure, is that you don't prompt the user when creating a communication channel (this one would be an easy prey \"man in the middle\" attacks), but that doesn't mean that it will always work. here's a [link] where the user complains about some devices asks for pairing while others don't.<br/><br/> "
  },
  {
    "sentId": 92,
    "articleId": "2",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "including the  fields in the manifest to have account management access",
        "em2Text": "iterating through all accounts of a particular type and calling maccountmanger.getpassword(account) on them",
        "label": "None"
      },
      {
        "em1Text": "iterating through all accounts of a particular type and calling maccountmanger.getpassword(account) on them",
        "em2Text": "including the  fields in the manifest to have account management access",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 82,
        "text": "including the  fields in the manifest to have account management access",
        "label": "ATTACK"
      },
      {
        "start": 177,
        "text": "iterating through all accounts of a particular type and calling maccountmanger.getpassword(account) on them",
        "label": "ATTACK"
      }
    ],
    "sentText": "due to this, i'm starting to wonder what stops an arbitrary malicious app from 1) including the  fields in the manifest to have account management access, and then then 2) from iterating through all accounts of a particular type and calling maccountmanger.getpassword(account) on them. i know that during installation, a dialog pops up with all the permissions that an app requests to use, but i don't think we can count on the average user to reject an app because it requests suspicious permissions. "
  },
  {
    "sentId": 78,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "perform an mitm attack",
        "em2Text": "intercept all requests to public maven repositories",
        "label": "AND"
      },
      {
        "em1Text": "perform an mitm attack",
        "em2Text": "injecting malicious bytecode into the jar artifacts",
        "label": "None"
      },
      {
        "em1Text": "perform an mitm attack",
        "em2Text": "recalculating and supplying the sha1 hashes",
        "label": "None"
      },
      {
        "em1Text": "perform an mitm attack",
        "em2Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "None"
      },
      {
        "em1Text": "perform an mitm attack",
        "em2Text": "provide masqueraded library copies of the original",
        "label": "None"
      },
      {
        "em1Text": "perform an mitm attack",
        "em2Text": "injected with malicious or harmful code",
        "label": "None"
      },
      {
        "em1Text": "intercept all requests to public maven repositories",
        "em2Text": "perform an mitm attack",
        "label": "None"
      },
      {
        "em1Text": "intercept all requests to public maven repositories",
        "em2Text": "injecting malicious bytecode into the jar artifacts",
        "label": "AND"
      },
      {
        "em1Text": "intercept all requests to public maven repositories",
        "em2Text": "recalculating and supplying the sha1 hashes",
        "label": "None"
      },
      {
        "em1Text": "intercept all requests to public maven repositories",
        "em2Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "None"
      },
      {
        "em1Text": "intercept all requests to public maven repositories",
        "em2Text": "provide masqueraded library copies of the original",
        "label": "None"
      },
      {
        "em1Text": "intercept all requests to public maven repositories",
        "em2Text": "injected with malicious or harmful code",
        "label": "None"
      },
      {
        "em1Text": "injecting malicious bytecode into the jar artifacts",
        "em2Text": "perform an mitm attack",
        "label": "None"
      },
      {
        "em1Text": "injecting malicious bytecode into the jar artifacts",
        "em2Text": "intercept all requests to public maven repositories",
        "label": "None"
      },
      {
        "em1Text": "injecting malicious bytecode into the jar artifacts",
        "em2Text": "recalculating and supplying the sha1 hashes",
        "label": "AND"
      },
      {
        "em1Text": "injecting malicious bytecode into the jar artifacts",
        "em2Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "None"
      },
      {
        "em1Text": "injecting malicious bytecode into the jar artifacts",
        "em2Text": "provide masqueraded library copies of the original",
        "label": "None"
      },
      {
        "em1Text": "injecting malicious bytecode into the jar artifacts",
        "em2Text": "injected with malicious or harmful code",
        "label": "None"
      },
      {
        "em1Text": "recalculating and supplying the sha1 hashes",
        "em2Text": "perform an mitm attack",
        "label": "None"
      },
      {
        "em1Text": "recalculating and supplying the sha1 hashes",
        "em2Text": "intercept all requests to public maven repositories",
        "label": "None"
      },
      {
        "em1Text": "recalculating and supplying the sha1 hashes",
        "em2Text": "injecting malicious bytecode into the jar artifacts",
        "label": "None"
      },
      {
        "em1Text": "recalculating and supplying the sha1 hashes",
        "em2Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "None"
      },
      {
        "em1Text": "recalculating and supplying the sha1 hashes",
        "em2Text": "provide masqueraded library copies of the original",
        "label": "None"
      },
      {
        "em1Text": "recalculating and supplying the sha1 hashes",
        "em2Text": "injected with malicious or harmful code",
        "label": "None"
      },
      {
        "em1Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "em2Text": "perform an mitm attack",
        "label": "PARENT"
      },
      {
        "em1Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "em2Text": "intercept all requests to public maven repositories",
        "label": "None"
      },
      {
        "em1Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "em2Text": "injecting malicious bytecode into the jar artifacts",
        "label": "None"
      },
      {
        "em1Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "em2Text": "recalculating and supplying the sha1 hashes",
        "label": "None"
      },
      {
        "em1Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "em2Text": "provide masqueraded library copies of the original",
        "label": "None"
      },
      {
        "em1Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "em2Text": "injected with malicious or harmful code",
        "label": "None"
      },
      {
        "em1Text": "provide masqueraded library copies of the original",
        "em2Text": "perform an mitm attack",
        "label": "None"
      },
      {
        "em1Text": "provide masqueraded library copies of the original",
        "em2Text": "intercept all requests to public maven repositories",
        "label": "None"
      },
      {
        "em1Text": "provide masqueraded library copies of the original",
        "em2Text": "injecting malicious bytecode into the jar artifacts",
        "label": "None"
      },
      {
        "em1Text": "provide masqueraded library copies of the original",
        "em2Text": "recalculating and supplying the sha1 hashes",
        "label": "None"
      },
      {
        "em1Text": "provide masqueraded library copies of the original",
        "em2Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "PARENT"
      },
      {
        "em1Text": "provide masqueraded library copies of the original",
        "em2Text": "injected with malicious or harmful code",
        "label": "None"
      },
      {
        "em1Text": "injected with malicious or harmful code",
        "em2Text": "perform an mitm attack",
        "label": "None"
      },
      {
        "em1Text": "injected with malicious or harmful code",
        "em2Text": "intercept all requests to public maven repositories",
        "label": "None"
      },
      {
        "em1Text": "injected with malicious or harmful code",
        "em2Text": "injecting malicious bytecode into the jar artifacts",
        "label": "None"
      },
      {
        "em1Text": "injected with malicious or harmful code",
        "em2Text": "recalculating and supplying the sha1 hashes",
        "label": "None"
      },
      {
        "em1Text": "injected with malicious or harmful code",
        "em2Text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "None"
      },
      {
        "em1Text": "injected with malicious or harmful code",
        "em2Text": "provide masqueraded library copies of the original",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 278,
        "text": "perform an mitm attack",
        "label": "ATTACK"
      },
      {
        "start": 305,
        "text": "intercept all requests to public maven repositories",
        "label": "ATTACK"
      },
      {
        "start": 368,
        "text": "injecting malicious bytecode into the jar artifacts",
        "label": "ATTACK"
      },
      {
        "start": 426,
        "text": "recalculating and supplying the sha1 hashes",
        "label": "ATTACK"
      },
      {
        "start": 58,
        "text": "someone sets up masquerades of maven repositories and/or ip streams",
        "label": "ATTACK"
      },
      {
        "start": 129,
        "text": "provide masqueraded library copies of the original",
        "label": "ATTACK"
      },
      {
        "start": 184,
        "text": "injected with malicious or harmful code",
        "label": "ATTACK"
      }
    ],
    "sentText": "what are the risks and possibilities or scenarios whereby someone sets up masquerades of maven repositories and/or ip streams to provide masqueraded library copies of the original but injected with malicious or harmful code. i suppose a dedicated and resourceful attacker could perform an mitm attack and intercept all requests to public maven repositories, carefully injecting malicious bytecode into the jar artifacts, then recalculating and supplying the sha1 hashes. "
  },
  {
    "sentId": 120,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 60,
        "text": "csrf vulnerabilities",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have made a [link] for detecting and exploiting so called csrf vulnerabilities. i use it to quickly make proof of concepts of such vulnerabilities that i send to the affected site owners. quite often i encounter these forms with a viewstate, and these i don't know if they are secure or not. "
  },
  {
    "sentId": 31,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "make their own django templates with a set of pre-defined variables",
        "em2Text": "render this template on the server",
        "label": "None"
      },
      {
        "em1Text": "make their own django templates with a set of pre-defined variables",
        "em2Text": "django template tags that can be abused to get information",
        "label": "None"
      },
      {
        "em1Text": "render this template on the server",
        "em2Text": "make their own django templates with a set of pre-defined variables",
        "label": "PARENT"
      },
      {
        "em1Text": "render this template on the server",
        "em2Text": "django template tags that can be abused to get information",
        "label": "None"
      },
      {
        "em1Text": "django template tags that can be abused to get information",
        "em2Text": "make their own django templates with a set of pre-defined variables",
        "label": "None"
      },
      {
        "em1Text": "django template tags that can be abused to get information",
        "em2Text": "render this template on the server",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 24,
        "text": "make their own django templates with a set of pre-defined variables",
        "label": "ATTACK"
      },
      {
        "start": 102,
        "text": "render this template on the server",
        "label": "ATTACK"
      },
      {
        "start": 296,
        "text": "django template tags that can be abused to get information",
        "label": "ATTACK"
      }
    ],
    "sentText": "is it safe to let users make their own django templates with a set of pre-defined variables, and then render this template on the server? i would only pass a very limited set of parameters to [code], all of which are strings. templates would be something like: so, the question is, are there any django template tags that can be abused to get information that users are not supposed to get? i'm most worried about the [code] tag. "
  },
  {
    "sentId": 4,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "potential attacker is able to change code",
        "em2Text": "application from being modified",
        "label": "PARENT"
      },
      {
        "em1Text": "application from being modified",
        "em2Text": "potential attacker is able to change code",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 70,
        "text": "potential attacker is able to change code",
        "label": "ATTACK"
      },
      {
        "start": 185,
        "text": "application from being modified",
        "label": "ATTACK"
      }
    ],
    "sentText": "and also very well said by @inazaruk: whatever you do to your code, a potential attacker is able to change code in any way she or he finds it feasible. you basically can't protect your application from being modified. and any protection you put in there can be disabled/removed. "
  },
  {
    "sentId": 136,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 98,
        "text": "xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have read (and am coming to terms with) the fact that no solution can be 100% effective against xss attacks. it seems that the best we can hope for is to stop \"most\" xss attack avenues, and probably have good recovery and/or legal plans afterwords. lately, i've been struggling to find a good frame of reference for what should and shouldn't be an acceptable risk. i can see that using an html sanitizer can also be very effective in lowering the avenues of xss attacks if you need the user-input unvalidated. however, in my case, it's kind of the opposite. i have a (very limited) cms with a web interface. the user input (after being url encoded) is saved to a json file, which is then picked up (decoded) on the view-able page.  my main way for stopping xss attacks here is that you would have to be one of few registered members in order to change content at all. by logging registered users, ip addresses, and timestamps, i feel that this threat is mostly mitigated, however, i would like to use a try/catch statement that would catch the ysod produced by asp.net's default request validator in addition to the previously mentioned methods. "
  },
  {
    "sentId": 93,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "malicious code is being added to the start of the [code] file",
        "em2Text": "rogue files are added to the server",
        "label": "None"
      },
      {
        "em1Text": "rogue files are added to the server",
        "em2Text": "malicious code is being added to the start of the [code] file",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "malicious code is being added to the start of the [code] file",
        "label": "ATTACK"
      },
      {
        "start": 61,
        "text": "rogue files are added to the server",
        "label": "ATTACK"
      }
    ],
    "sentText": "malicious code is being added to the start of the [code] filerogue files are added to the server "
  },
  {
    "sentId": 67,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "requires a client",
        "em2Text": "automatically downgrades tls protocol to sslv3",
        "label": "None"
      },
      {
        "em1Text": "requires a client",
        "em2Text": "failing to establish a secure channel with a server using higher version protocol advertised by the server",
        "label": "AND"
      },
      {
        "em1Text": "automatically downgrades tls protocol to sslv3",
        "em2Text": "requires a client",
        "label": "PARENT"
      },
      {
        "em1Text": "automatically downgrades tls protocol to sslv3",
        "em2Text": "failing to establish a secure channel with a server using higher version protocol advertised by the server",
        "label": "None"
      },
      {
        "em1Text": "failing to establish a secure channel with a server using higher version protocol advertised by the server",
        "em2Text": "requires a client",
        "label": "None"
      },
      {
        "em1Text": "failing to establish a secure channel with a server using higher version protocol advertised by the server",
        "em2Text": "automatically downgrades tls protocol to sslv3",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 69,
        "text": "requires a client",
        "label": "ATTACK"
      },
      {
        "start": 92,
        "text": "automatically downgrades tls protocol to sslv3",
        "label": "ATTACK"
      },
      {
        "start": 144,
        "text": "failing to establish a secure channel with a server using higher version protocol advertised by the server",
        "label": "ATTACK"
      }
    ],
    "sentText": "regarding the poodle vulnerability, if i understand it correctly, it requires a client that automatically downgrades tls protocol to sslv3 when failing to establish a secure channel with a server using higher version protocol advertised by the server. "
  },
  {
    "sentId": 17,
    "articleId": "3",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "tries to impersonate some other user",
        "em2Text": "an http connection will be used",
        "label": "None"
      },
      {
        "em1Text": "tries to impersonate some other user",
        "em2Text": "it will send your unencrypted tokens over internet",
        "label": "None"
      },
      {
        "em1Text": "an http connection will be used",
        "em2Text": "tries to impersonate some other user",
        "label": "PARENT"
      },
      {
        "em1Text": "an http connection will be used",
        "em2Text": "it will send your unencrypted tokens over internet",
        "label": "None"
      },
      {
        "em1Text": "it will send your unencrypted tokens over internet",
        "em2Text": "tries to impersonate some other user",
        "label": "PARENT"
      },
      {
        "em1Text": "it will send your unencrypted tokens over internet",
        "em2Text": "an http connection will be used",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 258,
        "text": "tries to impersonate some other user",
        "label": "ATTACK"
      },
      {
        "start": 557,
        "text": "an http connection will be used",
        "label": "ATTACK"
      },
      {
        "start": 593,
        "text": "it will send your unencrypted tokens over internet",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm trying to have a look at how gmail or facebook are implementing this functionality. i can see some cookie like 'presence=dj267619445g09h0l15228675.....' in fb, others in gmail.i'm not too sure if they use some other trick to protect against someone that tries to impersonate some other user. i'll try to impersonate myself using something like [link] to see if they're only using a specific token to remember the user. if they are it looks to me like a big security issue. maybe not facebook(i don't care of it) but with gmail if you don't set '[link]' an http connection will be used and it will send your unencrypted tokens over internet.what do you think?   maybe not facebook(i don't care of it) but with gmail if you don't set 'use always https' an http connection will be used and it will send your unencrypted tokens over internet.  what do you think? "
  },
  {
    "sentId": 90,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "inject code into your application",
        "em2Text": "you are passing parameters (either get or post) into your app",
        "label": "PARENT"
      },
      {
        "em1Text": "you are passing parameters (either get or post) into your app",
        "em2Text": "inject code into your application",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 63,
        "text": "inject code into your application",
        "label": "ATTACK"
      },
      {
        "start": 100,
        "text": "you are passing parameters (either get or post) into your app",
        "label": "ATTACK"
      }
    ],
    "sentText": "i don't believe you can hack via the url. someone could try to inject code into your application if you are passing parameters (either get or post) into your app so your avoidance is going to be very similar to what you'd do for a local application. "
  },
  {
    "sentId": 101,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 40,
        "text": "some bad person would take advantage of the indirect access to win api",
        "label": "ATTACK"
      }
    ],
    "sentText": "but, we have a security concern.what if some bad person would take advantage of the indirect access to win api? "
  },
  {
    "sentId": 27,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "clickjacking",
        "em2Text": "doing a mitm for these social widgets",
        "label": "PARENT"
      },
      {
        "em1Text": "clickjacking",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "clickjacking",
        "em2Text": "hijack your users' cookie's",
        "label": "None"
      },
      {
        "em1Text": "clickjacking",
        "em2Text": "perform [code] against your website",
        "label": "None"
      },
      {
        "em1Text": "doing a mitm for these social widgets",
        "em2Text": "clickjacking",
        "label": "None"
      },
      {
        "em1Text": "doing a mitm for these social widgets",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "doing a mitm for these social widgets",
        "em2Text": "hijack your users' cookie's",
        "label": "PARENT"
      },
      {
        "em1Text": "doing a mitm for these social widgets",
        "em2Text": "perform [code] against your website",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "clickjacking",
        "label": "PARENT"
      },
      {
        "em1Text": "xss",
        "em2Text": "doing a mitm for these social widgets",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "hijack your users' cookie's",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "perform [code] against your website",
        "label": "None"
      },
      {
        "em1Text": "hijack your users' cookie's",
        "em2Text": "clickjacking",
        "label": "None"
      },
      {
        "em1Text": "hijack your users' cookie's",
        "em2Text": "doing a mitm for these social widgets",
        "label": "None"
      },
      {
        "em1Text": "hijack your users' cookie's",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "hijack your users' cookie's",
        "em2Text": "perform [code] against your website",
        "label": "OR"
      },
      {
        "em1Text": "perform [code] against your website",
        "em2Text": "clickjacking",
        "label": "None"
      },
      {
        "em1Text": "perform [code] against your website",
        "em2Text": "doing a mitm for these social widgets",
        "label": "None"
      },
      {
        "em1Text": "perform [code] against your website",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "perform [code] against your website",
        "em2Text": "hijack your users' cookie's",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 49,
        "text": "clickjacking",
        "label": "ATTACK"
      },
      {
        "start": 101,
        "text": "doing a mitm for these social widgets",
        "label": "ATTACK"
      },
      {
        "start": 186,
        "text": "xss",
        "label": "ATTACK"
      },
      {
        "start": 291,
        "text": "hijack your users' cookie's",
        "label": "ATTACK"
      },
      {
        "start": 322,
        "text": "perform [code] against your website",
        "label": "ATTACK"
      }
    ],
    "sentText": "what? how!?is this not a massive opportunity for clickjacking, if used maliciously? (imagine someone doing a mitm for these social widgets!) from an attack perspective this is more like xss (cross-site scripting) than ui-redress.  you are giving google access to your website and they could hijack your users' cookie's or perform [code] against your website if they so choose (but then people would sue them for being malicious and wealthy).  "
  },
  {
    "sentId": 60,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "steal a session",
        "em2Text": "have total access to whatever is in that session",
        "label": "None"
      },
      {
        "em1Text": "steal a session",
        "em2Text": "xss",
        "label": "PARENT"
      },
      {
        "em1Text": "have total access to whatever is in that session",
        "em2Text": "steal a session",
        "label": "PARENT"
      },
      {
        "em1Text": "have total access to whatever is in that session",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "steal a session",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "have total access to whatever is in that session",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 81,
        "text": "steal a session",
        "label": "ATTACK"
      },
      {
        "start": 122,
        "text": "have total access to whatever is in that session",
        "label": "ATTACK"
      },
      {
        "start": 524,
        "text": "xss",
        "label": "ATTACK"
      }
    ],
    "sentText": "sessions are significantly safer than, say, cookies. but it is still possible to steal a session and thus the hacker will have total access to whatever is in that session. some ways to avoid this are ip checking (which works pretty well, but is very low fi and thus not reliable on its own), and using a nonce. typically with a nonce, you have a per-page \"token\" so that each page checks that the last page's nonce matches what it has stored.  but with a cookie, a hacker can steal the session simply by using fairly simple xss techniques. if you store the user's session id as a cookie, they are vulnerable to this as well. so even though the session is only penetrable to someone who can do a server-level hack (which requires much more sophisticated methods and usually some amount of privilege, if your server is secure), you are still going to need some extra level of verification upon each script request. you should not use cookies and ajax together, as this makes it a tad easier to totally go to town if that cookie is stolen, as your ajax requests may not get the security checks on each request. for example, if the page uses a nonce, but the page is never reloaded, the script may only be checking for that match. and if the cookie is holding the authentication method, i can now go to town doing my evilness using the stolen cookie and the ajax hole. "
  },
  {
    "sentId": 90,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "buffer overflow attack",
        "em2Text": "read into [code] there's no overflow protection",
        "label": "None"
      },
      {
        "em1Text": "buffer overflow attack",
        "em2Text": "write directly into the memory location for [code]",
        "label": "None"
      },
      {
        "em1Text": "buffer overflow attack",
        "em2Text": "later on when your code tries to call [code]",
        "label": "None"
      },
      {
        "em1Text": "buffer overflow attack",
        "em2Text": "jump to where the attacker wants it to jump",
        "label": "PARENT"
      },
      {
        "em1Text": "read into [code] there's no overflow protection",
        "em2Text": "buffer overflow attack",
        "label": "None"
      },
      {
        "em1Text": "read into [code] there's no overflow protection",
        "em2Text": "write directly into the memory location for [code]",
        "label": "AND"
      },
      {
        "em1Text": "read into [code] there's no overflow protection",
        "em2Text": "later on when your code tries to call [code]",
        "label": "None"
      },
      {
        "em1Text": "read into [code] there's no overflow protection",
        "em2Text": "jump to where the attacker wants it to jump",
        "label": "None"
      },
      {
        "em1Text": "write directly into the memory location for [code]",
        "em2Text": "buffer overflow attack",
        "label": "None"
      },
      {
        "em1Text": "write directly into the memory location for [code]",
        "em2Text": "read into [code] there's no overflow protection",
        "label": "None"
      },
      {
        "em1Text": "write directly into the memory location for [code]",
        "em2Text": "later on when your code tries to call [code]",
        "label": "None"
      },
      {
        "em1Text": "write directly into the memory location for [code]",
        "em2Text": "jump to where the attacker wants it to jump",
        "label": "None"
      },
      {
        "em1Text": "later on when your code tries to call [code]",
        "em2Text": "buffer overflow attack",
        "label": "None"
      },
      {
        "em1Text": "later on when your code tries to call [code]",
        "em2Text": "read into [code] there's no overflow protection",
        "label": "None"
      },
      {
        "em1Text": "later on when your code tries to call [code]",
        "em2Text": "write directly into the memory location for [code]",
        "label": "PARENT"
      },
      {
        "em1Text": "later on when your code tries to call [code]",
        "em2Text": "jump to where the attacker wants it to jump",
        "label": "None"
      },
      {
        "em1Text": "jump to where the attacker wants it to jump",
        "em2Text": "buffer overflow attack",
        "label": "None"
      },
      {
        "em1Text": "jump to where the attacker wants it to jump",
        "em2Text": "read into [code] there's no overflow protection",
        "label": "None"
      },
      {
        "em1Text": "jump to where the attacker wants it to jump",
        "em2Text": "write directly into the memory location for [code]",
        "label": "None"
      },
      {
        "em1Text": "jump to where the attacker wants it to jump",
        "em2Text": "later on when your code tries to call [code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 54,
        "text": "buffer overflow attack",
        "label": "ATTACK"
      },
      {
        "start": 91,
        "text": "read into [code] there's no overflow protection",
        "label": "ATTACK"
      },
      {
        "start": 152,
        "text": "write directly into the memory location for [code]",
        "label": "ATTACK"
      },
      {
        "start": 204,
        "text": "later on when your code tries to call [code]",
        "label": "ATTACK"
      },
      {
        "start": 258,
        "text": "jump to where the attacker wants it to jump",
        "label": "ATTACK"
      }
    ],
    "sentText": "does such attack needs to be conducted with a kind of buffer overflow attack? and when you read into [code] there's no overflow protection, and you can write directly into the memory location for [code]. later on when your code tries to call [code], it will jump to where the attacker wants it to jump, presumably where they injected executable code into your app. "
  },
  {
    "sentId": 1,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "read or change the value of the cookie",
        "em2Text": "guess the right get/post parameter",
        "label": "None"
      },
      {
        "em1Text": "guess the right get/post parameter",
        "em2Text": "read or change the value of the cookie",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 82,
        "text": "read or change the value of the cookie",
        "label": "ATTACK"
      },
      {
        "start": 168,
        "text": "guess the right get/post parameter",
        "label": "ATTACK"
      }
    ],
    "sentText": "using cookies works, and is a common practice (e. g. [link]). the attacker cannot read or change the value of the cookie due to the same-origin policy, and thus cannot guess the right get/post parameter. "
  },
  {
    "sentId": 70,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "users upload some malicious file",
        "em2Text": "specify the extensions allowed to be uploaded",
        "label": "None"
      },
      {
        "em1Text": "specify the extensions allowed to be uploaded",
        "em2Text": "users upload some malicious file",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 27,
        "text": "users upload some malicious file",
        "label": "ATTACK"
      },
      {
        "start": 130,
        "text": "specify the extensions allowed to be uploaded",
        "label": "ATTACK"
      }
    ],
    "sentText": "my proble is to avoid that users upload some malicious file on my web-server.im working on linux environment (debian). here i can specify the extensions allowed to be uploaded, and if the file dont meet them i delete as soon as the upload is completed.but this way let the user free to change the file extension with a simple rename.. and thats bad for me; even if a file.exe (for example) wont never be executed if is renamed in file.jpg (am i right?), i dont want to have potential danger files on my server. "
  },
  {
    "sentId": 86,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 105,
        "text": "optimizations from modifying your code behavior",
        "label": "ATTACK"
      }
    ],
    "sentText": "yes, your concerns are legitimate. you need to use specifically designed function like [link] to prevent optimizations from modifying your code behavior. "
  },
  {
    "sentId": 33,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "a recent vulnerability was discovered in the jre 1.7",
        "em2Text": "affects java browser plugins",
        "label": "None"
      },
      {
        "em1Text": "affects java browser plugins",
        "em2Text": "a recent vulnerability was discovered in the jre 1.7",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 47,
        "text": "a recent vulnerability was discovered in the jre 1.7",
        "label": "ATTACK"
      },
      {
        "start": 244,
        "text": "affects java browser plugins",
        "label": "ATTACK"
      }
    ],
    "sentText": "today, our enterprise architect mentioned that a recent vulnerability was discovered in the jre 1.7.  i found an article the [link].  the details of the latest vulnerability have not been made public.  however, my understanding is that it only affects java browser plugins.  the recommended mitigation is to disable the java browser plugins.  no mention is made of non-plugin java, so i think it is safe to assume that your dev machine is not vulnerable simply by virtue of having java 7 installed. "
  },
  {
    "sentId": 17,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "[link] ",
        "em2Text": "malicious html or javascript which is targeted on your website is been embedded in another html page (or an email message) which is been successfully executed.",
        "label": "PARENT"
      },
      {
        "em1Text": "malicious html or javascript which is targeted on your website is been embedded in another html page (or an email message) which is been successfully executed.",
        "em2Text": "[link] ",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 17,
        "text": "[link] ",
        "label": "ATTACK"
      },
      {
        "start": 33,
        "text": "malicious html or javascript which is targeted on your website is been embedded in another html page (or an email message) which is been successfully executed.",
        "label": "ATTACK"
      }
    ],
    "sentText": "there's means of [link] whenever malicious html or javascript which is targeted on your website is been embedded in another html page (or an email message) which is been successfully executed. "
  },
  {
    "sentId": 41,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "rainbow table attacks",
        "em2Text": "salts can be easily reverse-engineered",
        "label": "None"
      },
      {
        "em1Text": "salts can be easily reverse-engineered",
        "em2Text": "rainbow table attacks",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 187,
        "text": "rainbow table attacks",
        "label": "ATTACK"
      },
      {
        "start": 433,
        "text": "salts can be easily reverse-engineered",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm working on a project that we plan on releasing as open source, but the problem is that with the source comes the secret formula for generating salts, and therefore the ability to run rainbow table attacks on our site. i figure that lots of people have contemplated this problem before me, and i'm wondering what the best practice is. it seems to me that there is no point having a salt at all if the code is open source, because salts can be easily reverse-engineered. "
  },
  {
    "sentId": 85,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "brute-force attacks",
        "em2Text": "the hacker just tries all values for username",
        "label": "None"
      },
      {
        "em1Text": "brute-force attacks",
        "em2Text": "the failure message changes",
        "label": "None"
      },
      {
        "em1Text": "brute-force attacks",
        "em2Text": "knows a valid user",
        "label": "PARENT"
      },
      {
        "em1Text": "the hacker just tries all values for username",
        "em2Text": "brute-force attacks",
        "label": "None"
      },
      {
        "em1Text": "the hacker just tries all values for username",
        "em2Text": "the failure message changes",
        "label": "AND"
      },
      {
        "em1Text": "the hacker just tries all values for username",
        "em2Text": "knows a valid user",
        "label": "None"
      },
      {
        "em1Text": "the failure message changes",
        "em2Text": "brute-force attacks",
        "label": "None"
      },
      {
        "em1Text": "the failure message changes",
        "em2Text": "the hacker just tries all values for username",
        "label": "None"
      },
      {
        "em1Text": "the failure message changes",
        "em2Text": "knows a valid user",
        "label": "None"
      },
      {
        "em1Text": "knows a valid user",
        "em2Text": "brute-force attacks",
        "label": "None"
      },
      {
        "em1Text": "knows a valid user",
        "em2Text": "the hacker just tries all values for username",
        "label": "PARENT"
      },
      {
        "em1Text": "knows a valid user",
        "em2Text": "the failure message changes",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 71,
        "text": "brute-force attacks",
        "label": "ATTACK"
      },
      {
        "start": 726,
        "text": "the hacker just tries all values for username",
        "label": "ATTACK"
      },
      {
        "start": 807,
        "text": "the failure message changes",
        "label": "ATTACK"
      },
      {
        "start": 845,
        "text": "knows a valid user",
        "label": "ATTACK"
      }
    ],
    "sentText": "you should include some kind of timeout or failover to prevent against brute-force attacks. there are a number of ways to do this, including ip-based blocking, incremental timeouts, etc. none of these will ever stop a hacker, but they can make it much more difficult. another point (which you haven't mentioned, so i don't know your plan) is failure messages. make failure messages as vague as possible. providing an error message like 'that username exists, but the passwords did not match' might be helpful to the end-user, but it kills login functionality. you just converted a brute-force attack that should take [code] time to [code] + [code]. instead of needed to try every permutation in a rainbow table (for example), the hacker just tries all values for username (with a set password) first, until the failure message changes. then, it knows a valid user, and just has to brute force the password. "
  },
  {
    "sentId": 28,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "register with the service, login",
        "em2Text": "modifying the token that they receive to access the accounts of other users",
        "label": "None"
      },
      {
        "em1Text": "modifying the token that they receive to access the accounts of other users",
        "em2Text": "register with the service, login",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 80,
        "text": "register with the service, login",
        "label": "ATTACK"
      },
      {
        "start": 122,
        "text": "modifying the token that they receive to access the accounts of other users",
        "label": "ATTACK"
      }
    ],
    "sentText": "since this is a public facing service i am however concerned that someone could register with the service, login and then modifying the token that they receive to access the accounts of other users. "
  },
  {
    "sentId": 37,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sql injection",
        "em2Text": "output escaping",
        "label": "None"
      },
      {
        "em1Text": "output escaping",
        "em2Text": "sql injection",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 21,
        "text": "sql injection",
        "label": "ATTACK"
      },
      {
        "start": 39,
        "text": "output escaping",
        "label": "ATTACK"
      }
    ],
    "sentText": "note: i take care of sql injection and output escaping elsewhere - this question is about input filtering only, thanks. "
  },
  {
    "sentId": 30,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "using an xss attack",
        "em2Text": "injecting some js code",
        "label": "PARENT"
      },
      {
        "em1Text": "injecting some js code",
        "em2Text": "using an xss attack",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 49,
        "text": "using an xss attack",
        "label": "ATTACK"
      },
      {
        "start": 72,
        "text": "injecting some js code",
        "label": "ATTACK"
      }
    ],
    "sentText": "what if i steal the cookie of one of your users (using an xss attack by injecting some js code in your website) ? i will then fall in case 2. and thus be able to log in. imho, if you want a really secure authentication, do not use \"remember me\"-type cookies to store user credentials.if you do store the credentials in a cookie, please don't store the password in clear.checking for the [code] is a good first step to prevent session hijacking, but maybe you could combine it with the ip address ? it is far more difficult to be on the same host than your target than to simply use the same browser. "
  },
  {
    "sentId": 71,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "http request misuse",
        "em2Text": "tweak your malicious script to authenticate",
        "label": "PARENT"
      },
      {
        "em1Text": "tweak your malicious script to authenticate",
        "em2Text": "http request misuse",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 123,
        "text": "http request misuse",
        "label": "ATTACK"
      },
      {
        "start": 263,
        "text": "tweak your malicious script to authenticate",
        "label": "ATTACK"
      }
    ],
    "sentText": "i've made a voting on comments like the one this website has(something similar), and i'm slightly concerned about possible http request misuse. you'll know what i mean after i show you the questionable code: not even user authentication is very helpful, you just tweak your malicious script to authenticate and you can do it again. how can i make this request more secure, what can i do? thank you "
  },
  {
    "sentId": 18,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "[code]",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "[code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 780,
        "text": "[code]",
        "label": "ATTACK"
      },
      {
        "start": 102,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "how do [link] help us prevent [link] attacks?wikipedia says:prepared statements are resilient against sql injection, becauseparameter values, which are transmitted later using a differentprotocol, need not be correctly escaped. if the original statementtemplate is not derived from external input, sql injection cannotoccur.i cannot see the reason very well. what would be a simple explanation in an easy english and some examples? the root of the sql injection problem is in the mixing of the code and the data.    in fact, our sql query is a legitimate program. and we are creating such a program dynamically, adding some data on the fly. thus, the data may interfere with the program code and even alter it, as every sql injection example shows it (all examples in php/mysql): [code] [code] [code] [code] it works because we are adding the data directly to the program body and it becomes a part of the program, so the data may alter the program, and depending on the data passed, we will either have a regular output or a table [code] deleted. [code] [code] "
  },
  {
    "sentId": 18,
    "articleId": "3",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 36,
        "text": "decompile the app",
        "label": "ATTACK"
      }
    ],
    "sentText": "so the first issue is someone could decompile the app (which i've done) and even with proguard you can without too much difficulty retrieve all the questions.  "
  },
  {
    "sentId": 94,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "modifying the app apk/jar",
        "em2Text": "adding a new class",
        "label": "PARENT"
      },
      {
        "em1Text": "modifying the app apk/jar",
        "em2Text": "helps bypass the licensing check",
        "label": "None"
      },
      {
        "em1Text": "adding a new class",
        "em2Text": "modifying the app apk/jar",
        "label": "None"
      },
      {
        "em1Text": "adding a new class",
        "em2Text": "helps bypass the licensing check",
        "label": "None"
      },
      {
        "em1Text": "helps bypass the licensing check",
        "em2Text": "modifying the app apk/jar",
        "label": "PARENT"
      },
      {
        "em1Text": "helps bypass the licensing check",
        "em2Text": "adding a new class",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 149,
        "text": "modifying the app apk/jar",
        "label": "ATTACK"
      },
      {
        "start": 186,
        "text": "adding a new class",
        "label": "ATTACK"
      },
      {
        "start": 211,
        "text": "helps bypass the licensing check",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm currently dealing with a particular issue with my paid application.  internally it contains a licensing check.  the app is patched by hackers by modifying the app apk/jar.  they are adding a new class which helps bypass the licensing check. "
  },
  {
    "sentId": 54,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "possible access by attackers",
        "em2Text": "attach a php-based website",
        "label": "None"
      },
      {
        "em1Text": "attach a php-based website",
        "em2Text": "possible access by attackers",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 92,
        "text": "possible access by attackers",
        "label": "ATTACK"
      },
      {
        "start": 375,
        "text": "attach a php-based website",
        "label": "ATTACK"
      }
    ],
    "sentText": "is it a wise and practical approach to keep php files outside the public folder to restrict possible access by attackers? if yes, is it common? because i do not see any disadvantage (except a little bit harder handling of file spread in different places); but if it is beneficial for improve security, it is worth of consideration. since i do not know about the ways hackers attach a php-based website, i have no idea how it can improve security.   is it a wise and practical approach to keep php files outside the  public folder to restrict possible access by attackers? "
  },
  {
    "sentId": 114,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 99,
        "text": "retrieve the \"real\" global object",
        "label": "ATTACK"
      }
    ],
    "sentText": "no matter what you do with your code's execution environment using [code], it is still possible to retrieve the \"real\" global object using the following trick: "
  },
  {
    "sentId": 27,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 151,
        "text": "manages to get dodgy code onto a server",
        "label": "ATTACK"
      }
    ],
    "sentText": "i want to know how to disable the eval modifier in php's regex system eg. [code]. it's a potential exploit that can be used in place of eval if anyone manages to get dodgy code onto a server. i had a problem recently with a wordpress theme from woothemes that had a security hole that allowed hackers to upload a back door server admin type script. "
  },
  {
    "sentId": 2,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "develop a rainbow table ",
        "em2Text": "break all hashes that use the algorithm",
        "label": "None"
      },
      {
        "em1Text": "develop a rainbow table ",
        "em2Text": "attack the salted version of your hash",
        "label": "None"
      },
      {
        "em1Text": "develop a rainbow table ",
        "em2Text": "create rainbow tables that include the salt data",
        "label": "None"
      },
      {
        "em1Text": "break all hashes that use the algorithm",
        "em2Text": "develop a rainbow table ",
        "label": "PARENT"
      },
      {
        "em1Text": "break all hashes that use the algorithm",
        "em2Text": "attack the salted version of your hash",
        "label": "None"
      },
      {
        "em1Text": "break all hashes that use the algorithm",
        "em2Text": "create rainbow tables that include the salt data",
        "label": "None"
      },
      {
        "em1Text": "attack the salted version of your hash",
        "em2Text": "develop a rainbow table ",
        "label": "None"
      },
      {
        "em1Text": "attack the salted version of your hash",
        "em2Text": "break all hashes that use the algorithm",
        "label": "None"
      },
      {
        "em1Text": "attack the salted version of your hash",
        "em2Text": "create rainbow tables that include the salt data",
        "label": "AND"
      },
      {
        "em1Text": "create rainbow tables that include the salt data",
        "em2Text": "develop a rainbow table ",
        "label": "None"
      },
      {
        "em1Text": "create rainbow tables that include the salt data",
        "em2Text": "break all hashes that use the algorithm",
        "label": "None"
      },
      {
        "em1Text": "create rainbow tables that include the salt data",
        "em2Text": "attack the salted version of your hash",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 148,
        "text": "develop a rainbow table ",
        "label": "ATTACK"
      },
      {
        "start": 193,
        "text": "break all hashes that use the algorithm",
        "label": "ATTACK"
      },
      {
        "start": 500,
        "text": "attack the salted version of your hash",
        "label": "ATTACK"
      },
      {
        "start": 543,
        "text": "create rainbow tables that include the salt data",
        "label": "ATTACK"
      }
    ],
    "sentText": "my understanding is that a salt is not intended to be secret, it is merely intended to be different from any centralized standard so that you can't develop a rainbow table or similar attack to break all hashes that use the algorithm, since the salt breaks the rainbow table.  my understanding here might not be completely correct, so correct me if i'm wrong. in a widely-used piece of open-source software, the salt would be widely known, and this opens you up to attacks because now they can simply attack the salted version of your hash and create rainbow tables that include the salt data. "
  },
  {
    "sentId": 5,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "gets a valid token",
        "em2Text": "effectively impersonate",
        "label": "None"
      },
      {
        "em1Text": "effectively impersonate",
        "em2Text": "gets a valid token",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 78,
        "text": "gets a valid token",
        "label": "ATTACK"
      },
      {
        "start": 102,
        "text": "effectively impersonate",
        "label": "ATTACK"
      }
    ],
    "sentText": "jwt does not protect you to a man-in-the-middle (mitm) attack. if an attacker gets a valid token, can effectively impersonate. even if the content is encrypted. "
  },
  {
    "sentId": 46,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sql injection",
        "em2Text": "getting [code] to put a backslash in the middle of a multibyte character",
        "label": "PARENT"
      },
      {
        "em1Text": "getting [code] to put a backslash in the middle of a multibyte character",
        "em2Text": "sql injection",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 137,
        "text": "sql injection",
        "label": "ATTACK"
      },
      {
        "start": 201,
        "text": "getting [code] to put a backslash in the middle of a multibyte character",
        "label": "ATTACK"
      }
    ],
    "sentText": "in php, i know that [code] is much safer than using [code].however, i could not find an example of a situation where [code] would let an sql injection happen. basically, the way the attack works is by getting [code] to put a backslash in the middle of a multibyte character such that the backslash loses its meaning by being part of a valid multibyte sequence. "
  },
  {
    "sentId": 133,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 70,
        "text": "server-side javascript code injection attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "  \"the ctl00%24txttopqcksearch parameter appears to be vulnerable to  server-side javascript code injection attacks. the submitted value  appears to be placed into a dynamically evaluated javascript  statement, within a single-quoted context.    the payload '+(function(){if(typeof cb715===\"undefined\"){var a=new  date();do{var b=new date();}while(b-a&lt;20000);cb715=1;}}())+' was  submitted in the ctl00%24txttopqcksearch parameter. the application  took 7641 milliseconds to respond to the request, compared with 5625  milliseconds for the original request, indicating that the injected  javascript code caused a time delay.    please note that to manually reproduce this behavior using the  reported request, you will need to change the name of the canary  variable, which is currently cb715.\" "
  },
  {
    "sentId": 9,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "the phone is rooted",
        "em2Text": "an attacker can get to it",
        "label": "None"
      },
      {
        "em1Text": "the phone is rooted",
        "em2Text": "the attacker is running as root",
        "label": "AND"
      },
      {
        "em1Text": "the phone is rooted",
        "em2Text": "the embedded dex file can still be tampered with",
        "label": "None"
      },
      {
        "em1Text": "the phone is rooted",
        "em2Text": "attacker can then just modify the apk and re-sign it with their own key",
        "label": "None"
      },
      {
        "em1Text": "an attacker can get to it",
        "em2Text": "the phone is rooted",
        "label": "PARENT"
      },
      {
        "em1Text": "an attacker can get to it",
        "em2Text": "the attacker is running as root",
        "label": "None"
      },
      {
        "em1Text": "an attacker can get to it",
        "em2Text": "the embedded dex file can still be tampered with",
        "label": "None"
      },
      {
        "em1Text": "an attacker can get to it",
        "em2Text": "attacker can then just modify the apk and re-sign it with their own key",
        "label": "None"
      },
      {
        "em1Text": "the attacker is running as root",
        "em2Text": "the phone is rooted",
        "label": "None"
      },
      {
        "em1Text": "the attacker is running as root",
        "em2Text": "an attacker can get to it",
        "label": "None"
      },
      {
        "em1Text": "the attacker is running as root",
        "em2Text": "the embedded dex file can still be tampered with",
        "label": "None"
      },
      {
        "em1Text": "the attacker is running as root",
        "em2Text": "attacker can then just modify the apk and re-sign it with their own key",
        "label": "None"
      },
      {
        "em1Text": "the embedded dex file can still be tampered with",
        "em2Text": "the phone is rooted",
        "label": "None"
      },
      {
        "em1Text": "the embedded dex file can still be tampered with",
        "em2Text": "an attacker can get to it",
        "label": "None"
      },
      {
        "em1Text": "the embedded dex file can still be tampered with",
        "em2Text": "the attacker is running as root",
        "label": "None"
      },
      {
        "em1Text": "the embedded dex file can still be tampered with",
        "em2Text": "attacker can then just modify the apk and re-sign it with their own key",
        "label": "PARENT"
      },
      {
        "em1Text": "attacker can then just modify the apk and re-sign it with their own key",
        "em2Text": "the phone is rooted",
        "label": "PARENT"
      },
      {
        "em1Text": "attacker can then just modify the apk and re-sign it with their own key",
        "em2Text": "an attacker can get to it",
        "label": "None"
      },
      {
        "em1Text": "attacker can then just modify the apk and re-sign it with their own key",
        "em2Text": "the attacker is running as root",
        "label": "None"
      },
      {
        "em1Text": "attacker can then just modify the apk and re-sign it with their own key",
        "em2Text": "the embedded dex file can still be tampered with",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 193,
        "text": "the phone is rooted",
        "label": "ATTACK"
      },
      {
        "start": 230,
        "text": "an attacker can get to it",
        "label": "ATTACK"
      },
      {
        "start": 285,
        "text": "the attacker is running as root",
        "label": "ATTACK"
      },
      {
        "start": 324,
        "text": "the embedded dex file can still be tampered with",
        "label": "ATTACK"
      },
      {
        "start": 383,
        "text": "attacker can then just modify the apk and re-sign it with their own key",
        "label": "ATTACK"
      }
    ],
    "sentText": "my understanding is that when your apk is installed, it gets compiled and stored in the dalvik cache as an optimized dex file.  the dalvik cache is only accessible by the system user so unless the phone is rooted, there is no way an attacker can get to it. if the phone is rooted (and the attacker is running as root), then the embedded dex file can still be tampered with since the attacker can then just modify the apk and re-sign it with their own key. "
  },
  {
    "sentId": 122,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 91,
        "text": "xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "so, i want to know if this and only this little snippet presents any security issues (like xss attacks etc) "
  },
  {
    "sentId": 45,
    "articleId": "4",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "used google protocol buffers c++ implementation",
        "em2Text": "receive malicious data",
        "label": "None"
      },
      {
        "em1Text": "used google protocol buffers c++ implementation",
        "em2Text": "crash every time",
        "label": "None"
      },
      {
        "em1Text": "receive malicious data",
        "em2Text": "used google protocol buffers c++ implementation",
        "label": "PARENT"
      },
      {
        "em1Text": "receive malicious data",
        "em2Text": "crash every time",
        "label": "None"
      },
      {
        "em1Text": "crash every time",
        "em2Text": "used google protocol buffers c++ implementation",
        "label": "None"
      },
      {
        "em1Text": "crash every time",
        "em2Text": "receive malicious data",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 14,
        "text": "used google protocol buffers c++ implementation",
        "label": "ATTACK"
      },
      {
        "start": 192,
        "text": "receive malicious data",
        "label": "ATTACK"
      },
      {
        "start": 252,
        "text": "crash every time",
        "label": "ATTACK"
      }
    ],
    "sentText": "for those who used google protocol buffers c++ implementation, how does it deal with malicious or malformed messages? does it crash or continues to operate for example?  my app will certainly receive malicious data at some point and i don't want it to crash every time a malformed message is received. this is the only answer i could find on this issue ([link]). "
  },
  {
    "sentId": 96,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 123,
        "text": "database comes to be hacked",
        "label": "ATTACK"
      }
    ],
    "sentText": "for that i record in their database their key (s) api and the connection is done. but from a security point of view, if my database comes to be hacked despite all the predispositions taken in terms of security (prepared requests etc) ... these are all the api keys of my clients that are revealed and also email addresses of their own customers that can be retrieved, used, resold ... because the tools i connect essentially allows to store contacts, organize and send emails. "
  },
  {
    "sentId": 30,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "database is compromised",
        "em2Text": "all of the secrets will have to be changed",
        "label": "None"
      },
      {
        "em1Text": "database is compromised",
        "em2Text": "compromises the machine",
        "label": "None"
      },
      {
        "em1Text": "database is compromised",
        "em2Text": "encryption can be circumvented",
        "label": "None"
      },
      {
        "em1Text": "all of the secrets will have to be changed",
        "em2Text": "database is compromised",
        "label": "PARENT"
      },
      {
        "em1Text": "all of the secrets will have to be changed",
        "em2Text": "compromises the machine",
        "label": "None"
      },
      {
        "em1Text": "all of the secrets will have to be changed",
        "em2Text": "encryption can be circumvented",
        "label": "None"
      },
      {
        "em1Text": "compromises the machine",
        "em2Text": "database is compromised",
        "label": "None"
      },
      {
        "em1Text": "compromises the machine",
        "em2Text": "all of the secrets will have to be changed",
        "label": "None"
      },
      {
        "em1Text": "compromises the machine",
        "em2Text": "encryption can be circumvented",
        "label": "None"
      },
      {
        "em1Text": "encryption can be circumvented",
        "em2Text": "database is compromised",
        "label": "None"
      },
      {
        "em1Text": "encryption can be circumvented",
        "em2Text": "all of the secrets will have to be changed",
        "label": "None"
      },
      {
        "em1Text": "encryption can be circumvented",
        "em2Text": "compromises the machine",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 43,
        "text": "database is compromised",
        "label": "ATTACK"
      },
      {
        "start": 81,
        "text": "all of the secrets will have to be changed",
        "label": "ATTACK"
      },
      {
        "start": 466,
        "text": "compromises the machine",
        "label": "ATTACK"
      },
      {
        "start": 500,
        "text": "encryption can be circumvented",
        "label": "ATTACK"
      }
    ],
    "sentText": "it's the most obvious solution, but if the database is compromised somehow, then all of the secrets will have to be changed. to me this solution is not ideal because it has all of the problems of storing a password in plain-text. this will provide some security, because if the database is compromised then the secrets will still be safe. but reversible encryption requires an encryption key, and the key has to be stored on the server. it means that if an attacker compromises the machine, then the encryption can be circumvented. "
  },
  {
    "sentId": 8,
    "articleId": "3",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 58,
        "text": "gets access to the database",
        "label": "ATTACK"
      }
    ],
    "sentText": "the whole point of hashing a password is in case a hacker gets access to the database. if i store the salt in the db within the same row as the hashed password, isn't it just like i am handing the hacker the \"secret code\"? i am putting up a door with a lock, and handing the intruder the key. "
  },
  {
    "sentId": 48,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 140,
        "text": "an hack to get the .xhtml sources",
        "label": "ATTACK"
      }
    ],
    "sentText": "since security is not considered, i wonder if the first is \"secure\" from the point of view of access to the xhtml files or perhaps there is an hack to get the .xhtml sources. "
  },
  {
    "sentId": 102,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "someone with physical access to the machine",
        "em2Text": "copy the cookie",
        "label": "AND"
      },
      {
        "em1Text": "someone with physical access to the machine",
        "em2Text": "reuse it on another machine",
        "label": "None"
      },
      {
        "em1Text": "someone with physical access to the machine",
        "em2Text": "stealing the session",
        "label": "None"
      },
      {
        "em1Text": "copy the cookie",
        "em2Text": "someone with physical access to the machine",
        "label": "None"
      },
      {
        "em1Text": "copy the cookie",
        "em2Text": "reuse it on another machine",
        "label": "None"
      },
      {
        "em1Text": "copy the cookie",
        "em2Text": "stealing the session",
        "label": "None"
      },
      {
        "em1Text": "reuse it on another machine",
        "em2Text": "someone with physical access to the machine",
        "label": "PARENT"
      },
      {
        "em1Text": "reuse it on another machine",
        "em2Text": "copy the cookie",
        "label": "None"
      },
      {
        "em1Text": "reuse it on another machine",
        "em2Text": "stealing the session",
        "label": "None"
      },
      {
        "em1Text": "stealing the session",
        "em2Text": "someone with physical access to the machine",
        "label": "None"
      },
      {
        "em1Text": "stealing the session",
        "em2Text": "copy the cookie",
        "label": "None"
      },
      {
        "em1Text": "stealing the session",
        "em2Text": "reuse it on another machine",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 363,
        "text": "someone with physical access to the machine",
        "label": "ATTACK"
      },
      {
        "start": 410,
        "text": "copy the cookie",
        "label": "ATTACK"
      },
      {
        "start": 430,
        "text": "reuse it on another machine",
        "label": "ATTACK"
      },
      {
        "start": 467,
        "text": "stealing the session",
        "label": "ATTACK"
      }
    ],
    "sentText": "most web applications use cookies to manage the session for a user and allow you to stay logged in even if the browser was closed.let's assume we did everything by the book to make sure the cookie itself is safe.encrypt the contentset http onlyset securessl is used for the connectionwe check for tampering with the content of the cookieis it possible to prevent someone with physical access to the machine to copy the cookie and reuse it on another machine and thus stealing the session? "
  },
  {
    "sentId": 10,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "compromise a cryptosystem",
        "em2Text": "analyzing the time taken to execute cryptographic algorithms",
        "label": "PARENT"
      },
      {
        "em1Text": "analyzing the time taken to execute cryptographic algorithms",
        "em2Text": "compromise a cryptosystem",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 94,
        "text": "compromise a cryptosystem",
        "label": "ATTACK"
      },
      {
        "start": 123,
        "text": "analyzing the time taken to execute cryptographic algorithms",
        "label": "ATTACK"
      }
    ],
    "sentText": "  in cryptography, a timing attack is a side channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms. every logical operation in a computer takes time to execute, and the time can differ based on the input; with precise measurements of the time for each operation, an attacker can work backwards to the input. "
  },
  {
    "sentId": 154,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 60,
        "text": "mitm attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "what is the best way to protect the user and secure for any mitm attacks. is my way secure enough? "
  },
  {
    "sentId": 138,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 43,
        "text": "xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have heard that it's possible to trigger xss attacks through css ([link], [link]). "
  },
  {
    "sentId": 123,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "interception",
        "em2Text": "man-in-the-middle-like attacks",
        "label": "PARENT"
      },
      {
        "em1Text": "interception",
        "em2Text": "this key will typically be sent unencrypted along with the rest of the sql query",
        "label": "None"
      },
      {
        "em1Text": "man-in-the-middle-like attacks",
        "em2Text": "interception",
        "label": "None"
      },
      {
        "em1Text": "man-in-the-middle-like attacks",
        "em2Text": "this key will typically be sent unencrypted along with the rest of the sql query",
        "label": "None"
      },
      {
        "em1Text": "this key will typically be sent unencrypted along with the rest of the sql query",
        "em2Text": "interception",
        "label": "None"
      },
      {
        "em1Text": "this key will typically be sent unencrypted along with the rest of the sql query",
        "em2Text": "man-in-the-middle-like attacks",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 101,
        "text": "interception",
        "label": "ATTACK"
      },
      {
        "start": 350,
        "text": "man-in-the-middle-like attacks",
        "label": "ATTACK"
      },
      {
        "start": 807,
        "text": "this key will typically be sent unencrypted along with the rest of the sql query",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have always thought that as the data was being passed internally in the same computer, the risk of interception was zero.  is this not the case, then?  should i be encrypting in php before storing the data? as you have guessed, it is kind of pointless to use ssl for local connections. ssl's main purpose is to encrypt the channel so as to prevent man-in-the-middle-like attacks. but there can be no man in the middle in case of local connection. in you setup, i would recommend a connection through a [link], and bypass the tcp layer altogether. in the latter case (untrusted link to a remote database), [code] is not suitable. the encryption/decryption process is done by mysql. the data transits unencrypted between php and mysql. also, as one must pass an encryption key to mysql's [code] and [code], this key will typically be sent unencrypted along with the rest of the sql query. "
  },
  {
    "sentId": 114,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "inject malicious code into the system  site-packages ",
        "em2Text": "obtain root privilege",
        "label": "None"
      },
      {
        "em1Text": "obtain root privilege",
        "em2Text": "inject malicious code into the system  site-packages ",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 159,
        "text": "inject malicious code into the system  site-packages ",
        "label": "ATTACK"
      },
      {
        "start": 216,
        "text": "obtain root privilege",
        "label": "ATTACK"
      }
    ],
    "sentText": "  if you give yourself write privilege to the system site-packages,  you're risking that any program that runs under you (not necessarily  python program) can inject malicious code into the system  site-packages and obtain root privilege. "
  },
  {
    "sentId": 38,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 76,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "what exactly is going on in the background that makes it so [link] prevents sql injection attacks in a .net parameterized query?  is it just stripping out any suspect characters or is there something more to it? "
  },
  {
    "sentId": 109,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "cross-site request forgery attack",
        "em2Text": "submit malicious requests to a trusted site",
        "label": "PARENT"
      },
      {
        "em1Text": "cross-site request forgery attack",
        "em2Text": "bypass it by initiating clicking on the re-captcha figure at the first few attempts",
        "label": "None"
      },
      {
        "em1Text": "submit malicious requests to a trusted site",
        "em2Text": "cross-site request forgery attack",
        "label": "None"
      },
      {
        "em1Text": "submit malicious requests to a trusted site",
        "em2Text": "bypass it by initiating clicking on the re-captcha figure at the first few attempts",
        "label": "PARENT"
      },
      {
        "em1Text": "bypass it by initiating clicking on the re-captcha figure at the first few attempts",
        "em2Text": "cross-site request forgery attack",
        "label": "None"
      },
      {
        "em1Text": "bypass it by initiating clicking on the re-captcha figure at the first few attempts",
        "em2Text": "submit malicious requests to a trusted site",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 2,
        "text": "cross-site request forgery attack",
        "label": "ATTACK"
      },
      {
        "start": 69,
        "text": "submit malicious requests to a trusted site",
        "label": "ATTACK"
      },
      {
        "start": 462,
        "text": "bypass it by initiating clicking on the re-captcha figure at the first few attempts",
        "label": "ATTACK"
      }
    ],
    "sentText": "a cross-site request forgery attack rides on the victim's session to submit malicious requests to a trusted site. the [link] describes captcha as a good way to prevent csrf attacks. as we know, google re-captcha is effective in preventing bot spamming. after it has been clicked several times at the location with the same ip address, it requires a human to solve a pictures puzzle. since the first few attempts are simply 'free', is it possible for a hacker to bypass it by initiating clicking on the re-captcha figure at the first few attempts? "
  },
  {
    "sentId": 97,
    "articleId": "4",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "block the vm",
        "label": "AND"
      },
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "None"
      },
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "eating all the memory",
        "label": "None"
      },
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "expect 'em getting moved away",
        "label": "None"
      },
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "the jvm crashes",
        "label": "None"
      },
      {
        "em1Text": "do all my code in the finalizer thread",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "AND"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "eating all the memory",
        "label": "None"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "expect 'em getting moved away",
        "label": "None"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "the jvm crashes",
        "label": "None"
      },
      {
        "em1Text": "block the vm",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "block the vm",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "eating all the memory",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "expect 'em getting moved away",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "the jvm crashes",
        "label": "None"
      },
      {
        "em1Text": "same doing [code] bye-bye new threads",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "block the vm",
        "label": "None"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "PARENT"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "expect 'em getting moved away",
        "label": "None"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "the jvm crashes",
        "label": "None"
      },
      {
        "em1Text": "eating all the memory",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "block the vm",
        "label": "None"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "None"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "eating all the memory",
        "label": "PARENT"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "expect 'em getting moved away",
        "label": "AND"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "the jvm crashes",
        "label": "None"
      },
      {
        "em1Text": "accessing zip files in my own jar",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "block the vm",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "eating all the memory",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "the jvm crashes",
        "label": "None"
      },
      {
        "em1Text": "expect 'em getting moved away",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "block the vm",
        "label": "None"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "None"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "eating all the memory",
        "label": "None"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "expect 'em getting moved away",
        "label": "PARENT"
      },
      {
        "em1Text": "the jvm crashes",
        "em2Text": "deny resources",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "do all my code in the finalizer thread",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "block the vm",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "same doing [code] bye-bye new threads",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "eating all the memory",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "accessing zip files in my own jar",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "expect 'em getting moved away",
        "label": "None"
      },
      {
        "em1Text": "deny resources",
        "em2Text": "the jvm crashes",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 35,
        "text": "do all my code in the finalizer thread",
        "label": "ATTACK"
      },
      {
        "start": 83,
        "text": "block the vm",
        "label": "ATTACK"
      },
      {
        "start": 97,
        "text": "same doing [code] bye-bye new threads",
        "label": "ATTACK"
      },
      {
        "start": 136,
        "text": "eating all the memory",
        "label": "ATTACK"
      },
      {
        "start": 195,
        "text": "accessing zip files in my own jar",
        "label": "ATTACK"
      },
      {
        "start": 234,
        "text": "expect 'em getting moved away",
        "label": "ATTACK"
      },
      {
        "start": 268,
        "text": "the jvm crashes",
        "label": "ATTACK"
      },
      {
        "start": 334,
        "text": "deny resources",
        "label": "ATTACK"
      }
    ],
    "sentText": "if i wanna be malicious i am gonna do all my code in the finalizer thread and just block the vm. same doing [code] bye-bye new threads. eating all the memory, eating all direct memory and so on. accessing zip files in my own jar, and expect 'em getting moved away, so the jvm crashes (due to bug(s) in zlib) if one purposely wants to deny resources, it is just not a feasible task to try and catch the hacker. you'd need to know what to search for and dynamically check/enhance the classes on run-time to disallow the behavior.  "
  },
  {
    "sentId": 116,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "hacker knows the pattern",
        "em2Text": "login to jasper server",
        "label": "None"
      },
      {
        "em1Text": "login to jasper server",
        "em2Text": "hacker knows the pattern",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 61,
        "text": "hacker knows the pattern",
        "label": "ATTACK"
      },
      {
        "start": 101,
        "text": "login to jasper server",
        "label": "ATTACK"
      }
    ],
    "sentText": "my question is this really a secured process because as soon hacker knows the pattern, he can simply login to jasper server ?to me looks like security can be compromised here.  am i missing something here?   "
  },
  {
    "sentId": 11,
    "articleId": "2",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "somehow get you jwt module on your server to read them",
        "em2Text": "you vulnerable to csrf attacks",
        "label": "None"
      },
      {
        "em1Text": "somehow get you jwt module on your server to read them",
        "em2Text": "users get unsafe js running on your domain in other users browsers",
        "label": "None"
      },
      {
        "em1Text": "somehow get you jwt module on your server to read them",
        "em2Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "label": "None"
      },
      {
        "em1Text": "somehow get you jwt module on your server to read them",
        "em2Text": "you load 3rd party js with script tags or iframes",
        "label": "None"
      },
      {
        "em1Text": "somehow get you jwt module on your server to read them",
        "em2Text": "might compromise localstorage",
        "label": "None"
      },
      {
        "em1Text": "you vulnerable to csrf attacks",
        "em2Text": "somehow get you jwt module on your server to read them",
        "label": "PARENT"
      },
      {
        "em1Text": "you vulnerable to csrf attacks",
        "em2Text": "users get unsafe js running on your domain in other users browsers",
        "label": "None"
      },
      {
        "em1Text": "you vulnerable to csrf attacks",
        "em2Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "label": "None"
      },
      {
        "em1Text": "you vulnerable to csrf attacks",
        "em2Text": "you load 3rd party js with script tags or iframes",
        "label": "None"
      },
      {
        "em1Text": "you vulnerable to csrf attacks",
        "em2Text": "might compromise localstorage",
        "label": "None"
      },
      {
        "em1Text": "users get unsafe js running on your domain in other users browsers",
        "em2Text": "somehow get you jwt module on your server to read them",
        "label": "None"
      },
      {
        "em1Text": "users get unsafe js running on your domain in other users browsers",
        "em2Text": "you vulnerable to csrf attacks",
        "label": "None"
      },
      {
        "em1Text": "users get unsafe js running on your domain in other users browsers",
        "em2Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "label": "None"
      },
      {
        "em1Text": "users get unsafe js running on your domain in other users browsers",
        "em2Text": "you load 3rd party js with script tags or iframes",
        "label": "None"
      },
      {
        "em1Text": "users get unsafe js running on your domain in other users browsers",
        "em2Text": "might compromise localstorage",
        "label": "None"
      },
      {
        "em1Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "em2Text": "somehow get you jwt module on your server to read them",
        "label": "None"
      },
      {
        "em1Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "em2Text": "you vulnerable to csrf attacks",
        "label": "None"
      },
      {
        "em1Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "em2Text": "users get unsafe js running on your domain in other users browsers",
        "label": "PARENT"
      },
      {
        "em1Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "em2Text": "you load 3rd party js with script tags or iframes",
        "label": "None"
      },
      {
        "em1Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "em2Text": "might compromise localstorage",
        "label": "None"
      },
      {
        "em1Text": "you load 3rd party js with script tags or iframes",
        "em2Text": "somehow get you jwt module on your server to read them",
        "label": "None"
      },
      {
        "em1Text": "you load 3rd party js with script tags or iframes",
        "em2Text": "you vulnerable to csrf attacks",
        "label": "None"
      },
      {
        "em1Text": "you load 3rd party js with script tags or iframes",
        "em2Text": "users get unsafe js running on your domain in other users browsers",
        "label": "None"
      },
      {
        "em1Text": "you load 3rd party js with script tags or iframes",
        "em2Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "label": "None"
      },
      {
        "em1Text": "you load 3rd party js with script tags or iframes",
        "em2Text": "might compromise localstorage",
        "label": "None"
      },
      {
        "em1Text": "might compromise localstorage",
        "em2Text": "somehow get you jwt module on your server to read them",
        "label": "None"
      },
      {
        "em1Text": "might compromise localstorage",
        "em2Text": "you vulnerable to csrf attacks",
        "label": "None"
      },
      {
        "em1Text": "might compromise localstorage",
        "em2Text": "users get unsafe js running on your domain in other users browsers",
        "label": "None"
      },
      {
        "em1Text": "might compromise localstorage",
        "em2Text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "label": "None"
      },
      {
        "em1Text": "might compromise localstorage",
        "em2Text": "you load 3rd party js with script tags or iframes",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 68,
        "text": "somehow get you jwt module on your server to read them",
        "label": "ATTACK"
      },
      {
        "start": 134,
        "text": "you vulnerable to csrf attacks",
        "label": "ATTACK"
      },
      {
        "start": 397,
        "text": "users get unsafe js running on your domain in other users browsers",
        "label": "ATTACK"
      },
      {
        "start": 482,
        "text": "neither jwt in localstorage or sessions and jwt in cookies are safe",
        "label": "ATTACK"
      },
      {
        "start": 813,
        "text": "you load 3rd party js with script tags or iframes",
        "label": "ATTACK"
      },
      {
        "start": 868,
        "text": "might compromise localstorage",
        "label": "ATTACK"
      }
    ],
    "sentText": "storing the tokens in cookies i not dangerous in itself, but if you somehow get you jwt module on your server to read them from there you vulnerable to csrf attacks where any webpage can trigger a users browser to send a form + you sites cookie to your server unless you use csrf tokens. so generally they are stored in localstorage and \"manually\" added to request headers every time. xss is when users get unsafe js running on your domain in other users browsers when that happens neither jwt in localstorage or sessions and jwt in cookies are safe. with httponly flag on cookies, you can't directly access them, but the browser will still send them with ajax requests to your server. if this happens you generally out of luck. to prevent this, make sure to escape all user input if it's sent to the browser. if you load 3rd party js with script tags or iframes this might compromise localstorage unless you are careful, but i haven't worked enough with this to help you here. "
  },
  {
    "sentId": 44,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "execute arbitrary code",
        "em2Text": "[link] overflow",
        "label": "PARENT"
      },
      {
        "em1Text": "execute arbitrary code",
        "em2Text": "[link] overflow",
        "label": "None"
      },
      {
        "em1Text": "[link] overflow",
        "em2Text": "execute arbitrary code",
        "label": "None"
      },
      {
        "em1Text": "[link] overflow",
        "em2Text": "[link] overflow",
        "label": "OR"
      },
      {
        "em1Text": "[link] overflow",
        "em2Text": "execute arbitrary code",
        "label": "None"
      },
      {
        "em1Text": "[link] overflow",
        "em2Text": "[link] overflow",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 19,
        "text": "execute arbitrary code",
        "label": "ATTACK"
      },
      {
        "start": 70,
        "text": "[link] overflow",
        "label": "ATTACK"
      },
      {
        "start": 70,
        "text": "[link] overflow",
        "label": "ATTACK"
      }
    ],
    "sentText": "how is one able to execute arbitrary code simply by causing [link] or [link] overflows? "
  },
  {
    "sentId": 88,
    "articleId": "2",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "allowing users to supply regular expression",
        "em2Text": "allow for a denial of service attack",
        "label": "None"
      },
      {
        "em1Text": "allow for a denial of service attack",
        "em2Text": "allowing users to supply regular expression",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 18,
        "text": "allowing users to supply regular expression",
        "label": "ATTACK"
      },
      {
        "start": 77,
        "text": "allow for a denial of service attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "in most languages allowing users to supply regular expression means that you allow for a denial of service attack. "
  },
  {
    "sentId": 15,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "hardcoded",
        "em2Text": "compromise the backend",
        "label": "None"
      },
      {
        "em1Text": "compromise the backend",
        "em2Text": "hardcoded",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 204,
        "text": "hardcoded",
        "label": "ATTACK"
      },
      {
        "start": 333,
        "text": "compromise the backend",
        "label": "ATTACK"
      }
    ],
    "sentText": "i've setup the steps on the backend to retrieve a password, validate it and respond with a token. the only problem is - the password i use on the front end (mobile app) to be validated by the back end is hardcoded. how should i securely store this password on the mobile app so that it can not be sniffed out by a hacker and used to compromise the backend? although this may obfuscate keys, these still have to be hardcoded. making these kind of useless, unless i'm missing something. <h1>your question</h1>i've setup the steps on the backend to retrieve a password, validate it and respond with a token. the only problem is - the password i use on the front end (mobile app) to be validated by the back end is hardcoded.my question is:how should i securely store this password on the mobile app so that it can not be sniffed out by a hacker and used to compromise the backend?the cruel truth is... you can't!!!it seems that you already have done some extensive research on the subject, and in my opinion you mentioned one effective way of shipping your app with an embedded secret:hidden in native librariesbut as you also say:these methods are basically useless because hackers can easily circumnavigate these methods of protection.some are useless and others make reverse engineer the secret from the mobile app a lot harder. as i wrote [link], the approach of using the native interfaces to hide the secret will require expertise to reverse engineer it, but then if is hard to reverse engineer the binary you can always resort to a man in the middle (mitm) attack to steel the secret, as i show [link] for retrieving a secret that is hidden in the mobile app binary with the use of the native interfaces, [link].to protect your mobile app from a mitm you can employ [link]:pinning is the process of associating a host with their expected x509 certificate or public key. once a certificate or public key is known or seen for a host, the certificate or public key is associated or 'pinned' to the host. if more than one certificate or public key is acceptable, then the program holds a pinset (taking from jon larimer and kenny root google i/o talk). in this case, the advertised identity must match one of the elements in the pinset.you can read [link] of react native articles that show you how to apply certificate pinning to protect the communication channel between your mobile app and the api server.if you don't know yet certificcate pinning can also be bypassed by using tools like frida or xposed.[link]inject your own scripts into black box processes. hook any function, spy on crypto apis or trace private application code, no source code needed. edit, hit save, and instantly see the results. all without compilation steps or program restarts.[link]xposed is a framework for modules that can change the behavior of the system and apps without touching any apks. that's great because it means that modules can work for different versions and even roms without any changes (as long as the original code was not changed too much). it's also easy to undo.so now you may be wondering how can i protect from certificate pinning bypass?well is not easy, but is possible, by using a mobile app attestation solution.before we go further on it, i would like to clarify first a common misconception among developers, regarding who and what is accessing the api server.<h1>the difference between who and what is accessing the api server</h1>to better understand the differences between the who and the what are accessing an api server, let\u9225\u6a9a use this picture:<img src=\"https://i.stack.imgur.com/4dgaj.png\" alt=\"man in the middle attack\" />the intended communication channel represents the mobile app being used as you expected, by a legit user without any malicious intentions, using an untampered version of the mobile app, and communicating directly with the api server without being man in the middle attacked.the actual channel may represent several different scenarios, like a legit user with malicious intentions that may be using a repackaged version of the mobile app, a hacker using the genuine version of the mobile app, while man in the middle attacking it, to understand how the communication between the mobile app and the api server is being done in order to be able to automate attacks against your api. many other scenarios are possible, but we will not enumerate each one here.i hope that by now you may already have a clue why the who and the what are not the same, but if not it will become clear in a moment.the who is the user of the mobile app that we can authenticate, authorize and identify in several ways, like using openid connect or oauth2 flows.[link]generally, oauth provides to clients a &quot;secure delegated access&quot; to server resources on behalf of a resource owner. it specifies a process for resource owners to authorize third-party access to their server resources without sharing their credentials. designed specifically to work with hypertext transfer protocol (http), oauth essentially allows access tokens to be issued to third-party clients by an authorization server, with the approval of the resource owner. the third party then uses the access token to access the protected resources hosted by the resource server.[link]openid connect 1.0 is a simple identity layer on top of the oauth 2.0 protocol. it allows clients to verify the identity of the end-user based on the authentication performed by an authorization server, as well as to obtain basic profile information about the end-user in an interoperable and rest-like manner.while user authentication may let the api server know who is using the api, it cannot guarantee that the requests have originated from what you expect, the original version of the mobile app.now we need a way to identify what is calling the api server, and here things become more tricky than most developers may think. the what is the thing making the request to the api server. is it really a genuine instance of the mobile app, or is a bot, an automated script or an attacker manually poking around with the api server, using a tool like postman?for your surprise you may end up discovering that it can be one of the legit users using a repackaged version of the mobile app or an automated script that is trying to gamify and take advantage of the service provided by the application.well, to identify the what, developers tend to resort to an api key that usually they hard-code in the code of their mobile app. some developers go the extra mile and compute the key at run-time in the mobile app, thus it becomes a runtime secret as opposed to the former approach when a static secret is embedded in the code.the above write-up was extracted from an article i wrote, entitled why does your mobile app need an api key?, and that you can read in full [link], that is the first article in a series of articles about api keys.<h2>mobile app attestation</h2>the use of a mobile app attestation solution will enable the api server to know what is sending the requests, thus allowing to respond only to requests from a genuine mobile app while rejecting all other requests from unsafe sources.the role of a mobile app attestation service is to guarantee at run-time that your mobile app was not tampered, is not running in a rooted device and is not being the target of a mitm attack. this is done by running a sdk in the background that will communicate with a service running in the cloud to attest the integrity of the mobile app and device is running on. the cloud service also verifies that the tls certificate provided to the mobile app on the handshake with the api server is indeed the same in use by the original and genuine api server for the mobile app, not one from a mitm attack.on successful attestation of the mobile app integrity a short time lived jwt token is issued and signed with a secret that only the api server and the mobile app attestation service in the cloud are aware. in the case of failure on the mobile app attestation the jwt token is signed with a secret that the api server does not know.now the app must sent with every api call the jwt token in the headers of the request. this will allow the api server to only serve requests when it can verify the signature and expiration time in the jwt token and refuse them when it fails the verification.once the secret used by the mobile app attestation service is not known by the mobile app, is not possible to reverse engineer it at run-time even when the app is tampered, running in a rooted device or communicating over a connection that is being the target of a man in the middle attack.so this solution works in a positive detection model without false positives, thus not blocking legit users while keeping the bad guys at bays.what suggestions do you have to protect the world (react- native apps) from pesky hackers, when they're stealing keys and using them inappropriately?i think you should relaly go with a mobile app attestation solution, that you can roll in your own if you have the expertise for it, or you can use a solution that already exists as a saas solution at [link](i work here), that provides sdks for several platforms, including ios, android, react native and others. the integration will also need a small check in the api server code to verify the jwt token issued by the cloud service. this check is necessary for the api server to be able to decide what requests to serve and what ones to deny.<h2>summary</h2>i want to be able to store keys in the app so that i can validate the user an allow them to access resources on the backend. however, i don't know what the best plan of action is to ensure user/business security.don't go down this route of storing keys in the mobile app, because as you already know, by your extensive research, they can be bypassed.instead use a mobile attestation solution in conjunction with oauth2 or openid connect, that you can bind with the mobile app attestation token. an example of this token binding can be found in [link] for the check of the custom payload claim in the endpoint [code].<h2>going the extra mile</h2>[link]the owasp mobile security project is a centralized resource intended to give developers and security teams the resources they need to build and maintain secure mobile applications. through the project, our goal is to classify mobile security risks and provide developmental controls to reduce their impact or likelihood of exploitation. "
  },
  {
    "sentId": 20,
    "articleId": "3",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "brute-force attacks",
        "em2Text": "spam",
        "label": "None"
      },
      {
        "em1Text": "brute-force attacks",
        "em2Text": "send a password to someone's email like 1000 times",
        "label": "None"
      },
      {
        "em1Text": "spam",
        "em2Text": "brute-force attacks",
        "label": "None"
      },
      {
        "em1Text": "spam",
        "em2Text": "send a password to someone's email like 1000 times",
        "label": "PARENT"
      },
      {
        "em1Text": "send a password to someone's email like 1000 times",
        "em2Text": "brute-force attacks",
        "label": "None"
      },
      {
        "em1Text": "send a password to someone's email like 1000 times",
        "em2Text": "spam",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 166,
        "text": "brute-force attacks",
        "label": "ATTACK"
      },
      {
        "start": 193,
        "text": "spam",
        "label": "ATTACK"
      },
      {
        "start": 199,
        "text": "send a password to someone's email like 1000 times",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm actually working on a php project that will feature a user system (login,register,send lost password to email,..) and i think that this may be very vulnerable to brute-force attacks and/or spam (send a password to someone's email like 1000 times, etc. use your fantasy). do today's webservers (apache, iis) have some sort of built-in defense against brute-force?what would be the best way to implement an anti-spam/flood system, if i e.g.: want a page not be able to be called more than two times a minute, however another page may be called up to 100 times a minute or so. users with js won't see it and will be fine. users without js will just have to follow the simple instruction. spambots will fall for it and reveal themselves.automatic faux-captcha: this is similar to the above. add an input field with a label saying [link] (for example). using javascript (and knowing that most automated spam bots won't be running js), hide the field and populate it with 'alex'. if the submitted form doesn't have the magic word there, then ignore it. users with js won't see it and will be fine. users without js will just have to follow the simple instruction. spambots won't know what to do and you can ignore their input. this will safeguard you from 99.9% of automated spam bots. what it won't do, even in the slightest, is safeguard you against a targeted attack. someone could customise their bot to avoid the honeypot or always fill in the correct value.  "
  },
  {
    "sentId": 47,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "there was some malicious code at the end, suddenly. the output of my index.php was:[code]",
        "em2Text": "put this code right into the file",
        "label": "PARENT"
      },
      {
        "em1Text": "put this code right into the file",
        "em2Text": "there was some malicious code at the end, suddenly. the output of my index.php was:[code]",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 15,
        "text": "there was some malicious code at the end, suddenly. the output of my index.php was:[code]",
        "label": "ATTACK"
      },
      {
        "start": 186,
        "text": "put this code right into the file",
        "label": "ATTACK"
      }
    ],
    "sentText": "but yesterday, there was some malicious code at the end, suddenly. the output of my index.php was:[code] i opened the file on my webspace (downloaded via ftp) and i saw that someone had put this code right into the file! "
  },
  {
    "sentId": 76,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "spoofing of the server requests that are made from flash",
        "em2Text": "track the calls that flash",
        "label": "PARENT"
      },
      {
        "em1Text": "spoofing of the server requests that are made from flash",
        "em2Text": "reproduce them in a way that (for example) inserts garbage data",
        "label": "None"
      },
      {
        "em1Text": "spoofing of the server requests that are made from flash",
        "em2Text": "associates it with a given facebook user id in my database",
        "label": "None"
      },
      {
        "em1Text": "track the calls that flash",
        "em2Text": "spoofing of the server requests that are made from flash",
        "label": "None"
      },
      {
        "em1Text": "track the calls that flash",
        "em2Text": "reproduce them in a way that (for example) inserts garbage data",
        "label": "AND"
      },
      {
        "em1Text": "track the calls that flash",
        "em2Text": "associates it with a given facebook user id in my database",
        "label": "None"
      },
      {
        "em1Text": "reproduce them in a way that (for example) inserts garbage data",
        "em2Text": "spoofing of the server requests that are made from flash",
        "label": "None"
      },
      {
        "em1Text": "reproduce them in a way that (for example) inserts garbage data",
        "em2Text": "track the calls that flash",
        "label": "None"
      },
      {
        "em1Text": "reproduce them in a way that (for example) inserts garbage data",
        "em2Text": "associates it with a given facebook user id in my database",
        "label": "AND"
      },
      {
        "em1Text": "associates it with a given facebook user id in my database",
        "em2Text": "spoofing of the server requests that are made from flash",
        "label": "None"
      },
      {
        "em1Text": "associates it with a given facebook user id in my database",
        "em2Text": "track the calls that flash",
        "label": "None"
      },
      {
        "em1Text": "associates it with a given facebook user id in my database",
        "em2Text": "reproduce them in a way that (for example) inserts garbage data",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 47,
        "text": "spoofing of the server requests that are made from flash",
        "label": "ATTACK"
      },
      {
        "start": 138,
        "text": "track the calls that flash",
        "label": "ATTACK"
      },
      {
        "start": 192,
        "text": "reproduce them in a way that (for example) inserts garbage data",
        "label": "ATTACK"
      },
      {
        "start": 260,
        "text": "associates it with a given facebook user id in my database",
        "label": "ATTACK"
      }
    ],
    "sentText": "my problem is that i don't know how to prevent spoofing of the server requests that are made from flash; in theory, malicious users could track the calls that flash is making to my server and reproduce them in a way that (for example) inserts garbage data and associates it with a given facebook user id in my database.  all authentication is taking place on the client side (via the facebook js api) with no intervention by the server, so i'm having a hard time figuring out exactly how to secure calls between flash and the server in a manner that ensures that users have to be authenticated with facebook in order to make them. "
  },
  {
    "sentId": 25,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 33,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "i don't see any way to launch an sql injection attack against this, but i realize that if this were as bulletproof as it seems to me someone else would have thought of it already and it would be common practice.   what's wrong with this code? is there a way to get an sql injection attack past this sanitization technique?  sample user input that exploits this technique would be very helpful. i still don't know of any way to effectively launch a sql injection attack against this code. a few people suggested that a backslash would escape one single-quote and leave the other to end the string so that the rest of the string would be executed as part of the sql command, and i realize that this method would work to inject sql into a mysql database, but in sql&nbsp;server 2000 the only way (that i've been able to find) to escape a single-quote is with another single-quote; backslashes won't do it. i understand that there are better ways to sanitize input, but i'm really more interested in learning why the method i provided above won't work. if anyone knows of any specific way to mount a sql injection attack against this sanitization method i would love to see it. "
  },
  {
    "sentId": 10,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "take the id",
        "em2Text": "run it through a mysql query ",
        "label": "AND"
      },
      {
        "em1Text": "take the id",
        "em2Text": "retrieve 1 record",
        "label": "None"
      },
      {
        "em1Text": "take the id",
        "em2Text": "mess this url up",
        "label": "None"
      },
      {
        "em1Text": "take the id",
        "em2Text": "pose a security threat to my application/mysql db",
        "label": "None"
      },
      {
        "em1Text": "run it through a mysql query ",
        "em2Text": "take the id",
        "label": "None"
      },
      {
        "em1Text": "run it through a mysql query ",
        "em2Text": "retrieve 1 record",
        "label": "AND"
      },
      {
        "em1Text": "run it through a mysql query ",
        "em2Text": "mess this url up",
        "label": "None"
      },
      {
        "em1Text": "run it through a mysql query ",
        "em2Text": "pose a security threat to my application/mysql db",
        "label": "None"
      },
      {
        "em1Text": "retrieve 1 record",
        "em2Text": "take the id",
        "label": "None"
      },
      {
        "em1Text": "retrieve 1 record",
        "em2Text": "run it through a mysql query ",
        "label": "None"
      },
      {
        "em1Text": "retrieve 1 record",
        "em2Text": "mess this url up",
        "label": "None"
      },
      {
        "em1Text": "retrieve 1 record",
        "em2Text": "pose a security threat to my application/mysql db",
        "label": "None"
      },
      {
        "em1Text": "mess this url up",
        "em2Text": "take the id",
        "label": "None"
      },
      {
        "em1Text": "mess this url up",
        "em2Text": "run it through a mysql query ",
        "label": "None"
      },
      {
        "em1Text": "mess this url up",
        "em2Text": "retrieve 1 record",
        "label": "PARENT"
      },
      {
        "em1Text": "mess this url up",
        "em2Text": "pose a security threat to my application/mysql db",
        "label": "None"
      },
      {
        "em1Text": "pose a security threat to my application/mysql db",
        "em2Text": "take the id",
        "label": "None"
      },
      {
        "em1Text": "pose a security threat to my application/mysql db",
        "em2Text": "run it through a mysql query ",
        "label": "None"
      },
      {
        "em1Text": "pose a security threat to my application/mysql db",
        "em2Text": "retrieve 1 record",
        "label": "None"
      },
      {
        "em1Text": "pose a security threat to my application/mysql db",
        "em2Text": "mess this url up",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 58,
        "text": "take the id",
        "label": "ATTACK"
      },
      {
        "start": 74,
        "text": "run it through a mysql query ",
        "label": "ATTACK"
      },
      {
        "start": 106,
        "text": "retrieve 1 record",
        "label": "ATTACK"
      },
      {
        "start": 195,
        "text": "mess this url up",
        "label": "ATTACK"
      },
      {
        "start": 216,
        "text": "pose a security threat to my application/mysql db",
        "label": "ATTACK"
      }
    ],
    "sentText": "it's pretty obvious to you and i that the php is going to take the id and run it through a mysql query to retrieve 1 record to display it on the page. is there anyway some malicious hacker could mess this url up and pose a security threat to my application/mysql db? "
  },
  {
    "sentId": 68,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "using the php function htmlentities()",
        "em2Text": "xss attacks",
        "label": "None"
      },
      {
        "em1Text": "using the php function htmlentities()",
        "em2Text": "without appropriate encoding",
        "label": "AND"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "using the php function htmlentities()",
        "label": "PARENT"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "without appropriate encoding",
        "label": "None"
      },
      {
        "em1Text": "without appropriate encoding",
        "em2Text": "using the php function htmlentities()",
        "label": "None"
      },
      {
        "em1Text": "without appropriate encoding",
        "em2Text": "xss attacks",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 42,
        "text": "using the php function htmlentities()",
        "label": "ATTACK"
      },
      {
        "start": 88,
        "text": "xss attacks",
        "label": "ATTACK"
      },
      {
        "start": 289,
        "text": "without appropriate encoding",
        "label": "ATTACK"
      }
    ],
    "sentText": "i was asking myself about the security of using the php function htmlentities() against xss attacks, and maybe of related functions such as htmlspecialchars. you will need to explicitly specify proper encoding (e.g: utf-8), chris had a post on how to inject code even calling htmlentities without appropriate encoding.  "
  },
  {
    "sentId": 4,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "csrf token to be  leaked",
        "em2Text": "use django for generating forms that post to other people's websites",
        "label": "PARENT"
      },
      {
        "em1Text": "use django for generating forms that post to other people's websites",
        "em2Text": "csrf token to be  leaked",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 97,
        "text": "csrf token to be  leaked",
        "label": "ATTACK"
      },
      {
        "start": 384,
        "text": "use django for generating forms that post to other people's websites",
        "label": "ATTACK"
      }
    ],
    "sentText": "  this should not be done for post forms  that target external urls, since that  would cause the csrf token to be  leaked, leading to a vulnerability. the reason it's confusing is that; to me an \"external url\" would be page on that isn't part of my domain (ie, i own www.example.com and put a form that posts to www.spamfoo.com. this obviously can't be the case since people wouldn't use django for generating forms that post to other people's websites, but how could it be true that you can't use csrf protection on public forms (like a login form)?   this should not be done for post forms  that target external urls, since that  would cause the csrf token to be  leaked, leading to a vulnerability. "
  },
  {
    "sentId": 129,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "tamper with the queries",
        "em2Text": "prevent users from requesting information i don't want them to",
        "label": "OR"
      },
      {
        "em1Text": "prevent users from requesting information i don't want them to",
        "em2Text": "tamper with the queries",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 73,
        "text": "tamper with the queries",
        "label": "ATTACK"
      },
      {
        "start": 270,
        "text": "prevent users from requesting information i don't want them to",
        "label": "ATTACK"
      }
    ],
    "sentText": "however my concern is with the security of this method since users could tamper with the queries and do things you don't want them to do or request data you do not want them to see. in an application/plugin like this, what kind of security measures would you suggest to prevent users from requesting information i don't want them to? "
  },
  {
    "sentId": 58,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "uploaded several gifs, which when viewed with a browser, the browser said it was invalid",
        "em2Text": "my virus scanner alerted me that it was a injection",
        "label": "None"
      },
      {
        "em1Text": "my virus scanner alerted me that it was a injection",
        "em2Text": "uploaded several gifs, which when viewed with a browser, the browser said it was invalid",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 8,
        "text": "uploaded several gifs, which when viewed with a browser, the browser said it was invalid",
        "label": "ATTACK"
      },
      {
        "start": 102,
        "text": "my virus scanner alerted me that it was a injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "someone uploaded several gifs, which when viewed with a browser, the browser said it was invalid, and my virus scanner alerted me that it was a injection.  see below for a zip file containing these gifs. "
  },
  {
    "sentId": 84,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "embedded xss attempts",
        "em2Text": "xss vulnerability",
        "label": "None"
      },
      {
        "em1Text": "xss vulnerability",
        "em2Text": "embedded xss attempts",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 727,
        "text": "embedded xss attempts",
        "label": "ATTACK"
      },
      {
        "start": 825,
        "text": "xss vulnerability",
        "label": "ATTACK"
      }
    ],
    "sentText": "json responses can be exploited by overriding array constructors or if hostile values are not javascript string-escaped.let's assume both of those vectors are addressed in the normal way. google famously traps json response direct sourcing by prefixing all json with something like:[code]and then the rest of the json follows. so dr. evil cannot, using the sort of exploit discussed [link]. get your cookie (assuming you're logged in) by putting the following on his site:[code]as for string escaping rules, well if we're using double quotes, we need to prefix each with a backslash and each backslash with another backslash etc.but my question is, what if you're doing all of this?[link] (the automated security tool) detects embedded xss attempts that are returned unhtml-escaped in a json response and it reports it as an xss vulnerability. i have a report that my application contains vulnerabilities of this kind but i am not convinced. i've tried it and i can't make an exploit work.so i don't think this is correct.there is one specific case, that of ie mime-type sniffing that i think could result in an exploit. after all, ie 7 still had the &quot;feature&quot; that script tags embedded in image comments were executed regardless of the content-type header. let's also leave such clearly stupid behaviour aside at first.surely the json would be parsed by either the native javascript parser (window.json in firefox) or by an [code] as per the old default jquery behaviour. in neither case would the following expression result in the alert being executed:[code]am i right or am i wrong? "
  },
  {
    "sentId": 6,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 76,
        "text": "rainbow table attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "coda hale's article [link] claims that:bcrypt has salts built-in to prevent rainbow table attacks.he cites [link], which says that in openbsd's implementation of [code]:openbsd generates the 128-bit bcrypt salt from an arcfour(arc4random(3)) key stream, seeded with random data the kernelcollects from device timings.i don't understand how this can work. in my conception of a salt:it needs to be different for each stored password, so that a separate rainbow table would have to be generated for eachit needs to be stored somewhere so that it's repeatable: when a user tries to log in, we take their password attempt, repeat the same salt-and-hash procedure we did when we originally stored their password, and comparewhen i'm using devise (a rails login manager) with bcrypt, there is no salt column in the database, so i'm confused. if the salt is random and not stored anywhere, how can we reliably repeat the hashing process?in short, how can bcrypt have built-in salts? "
  },
  {
    "sentId": 17,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "PARENT"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      },
      {
        "em1Text": "calling the php page other than through my flash file",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "AND"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      },
      {
        "em1Text": "attackers control the runtime memory of the flash interpreter",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "alter any variable",
        "label": "AND"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "attacker decompiles your flash code",
        "label": "PARENT"
      },
      {
        "em1Text": "anyone who knows how to use a programmable debugger",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "attacker can still just launch the game again",
        "label": "PARENT"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      },
      {
        "em1Text": "alter any variable",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "get a token",
        "label": "AND"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      },
      {
        "em1Text": "attacker can still just launch the game again",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "AND"
      },
      {
        "em1Text": "get a token",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      },
      {
        "em1Text": "get a token",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      },
      {
        "em1Text": "paste that token into a replayed high-score save",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "attacker decompiles your flash code",
        "em2Text": "finds the aes code",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "calling the php page other than through my flash file",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "attackers control the runtime memory of the flash interpreter",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "anyone who knows how to use a programmable debugger",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "alter any variable",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "attacker can still just launch the game again",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "get a token",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "paste that token into a replayed high-score save",
        "label": "None"
      },
      {
        "em1Text": "finds the aes code",
        "em2Text": "attacker decompiles your flash code",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 98,
        "text": "calling the php page other than through my flash file",
        "label": "ATTACK"
      },
      {
        "start": 643,
        "text": "attackers control the runtime memory of the flash interpreter",
        "label": "ATTACK"
      },
      {
        "start": 714,
        "text": "anyone who knows how to use a programmable debugger",
        "label": "ATTACK"
      },
      {
        "start": 770,
        "text": "alter any variable",
        "label": "ATTACK"
      },
      {
        "start": 945,
        "text": "attacker can still just launch the game again",
        "label": "ATTACK"
      },
      {
        "start": 992,
        "text": "get a token",
        "label": "ATTACK"
      },
      {
        "start": 1026,
        "text": "paste that token into a replayed high-score save",
        "label": "ATTACK"
      },
      {
        "start": 1088,
        "text": "attacker decompiles your flash code",
        "label": "ATTACK"
      },
      {
        "start": 1136,
        "text": "finds the aes code",
        "label": "ATTACK"
      }
    ],
    "sentText": "what i really need is the strongest encryption possible in flash/php, and a way to prevent people calling the php page other than through my flash file. i have tried some simple methods in the past of making multiple calls for a single score and completing a checksum / fibonacci sequence etc, and also obfuscating the swf with amayeta swf encrypt, but they were all hacked eventually. flash is even easier to reverse engineer than you might think it is, since the bytecodes are well documented and describe a high-level language (actionscript) --- when you publish a flash game, you're publishing your source code, whether you know it or not.attackers control the runtime memory of the flash interpreter, so that anyone who knows how to use a programmable debugger can alter any variable (including the current score) at any time, or alter the program itself. the game code echoes this token back to the server with the high-score save. but an attacker can still just launch the game again, get a token, and then immediately paste that token into a replayed high-score save.  so now the attacker decompiles your flash code and quickly finds the aes code, which sticks out like a sore thumb, although even if it didn't it'd be tracked down in 15 minutes with a memory search and a tracer (\"i know my score for this game is 666, so let's find 666 in memory, then catch any operation that touches that value --- oh look, the high score encryption code!\"). with the session key, the attacker doesn't even have to run the flash code; she grabs a game launch token and a session key and can send back an arbitrary high score. "
  },
  {
    "sentId": 146,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "a man in the middle attack",
        "em2Text": "cookie hijacking",
        "label": "None"
      },
      {
        "em1Text": "cookie hijacking",
        "em2Text": "a man in the middle attack",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 42,
        "text": "a man in the middle attack",
        "label": "ATTACK"
      },
      {
        "start": 109,
        "text": "cookie hijacking",
        "label": "ATTACK"
      }
    ],
    "sentText": "above said, anything you do is subject to a man in the middle attack. this is the case for lots of sites, so cookie hijacking is a problem all around. "
  },
  {
    "sentId": 20,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "[code]",
        "em2Text": "the garbage collector will copy things around as it reorganizes the heap.",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "on certain architectures it's possible that a page will be freed and the secret will remain when some other program allocates that same page",
        "label": "None"
      },
      {
        "em1Text": "the garbage collector will copy things around as it reorganizes the heap.",
        "em2Text": "[code]",
        "label": "PARENT"
      },
      {
        "em1Text": "the garbage collector will copy things around as it reorganizes the heap.",
        "em2Text": "on certain architectures it's possible that a page will be freed and the secret will remain when some other program allocates that same page",
        "label": "None"
      },
      {
        "em1Text": "on certain architectures it's possible that a page will be freed and the secret will remain when some other program allocates that same page",
        "em2Text": "[code]",
        "label": "None"
      },
      {
        "em1Text": "on certain architectures it's possible that a page will be freed and the secret will remain when some other program allocates that same page",
        "em2Text": "the garbage collector will copy things around as it reorganizes the heap.",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 72,
        "text": "[code]",
        "label": "ATTACK"
      },
      {
        "start": 191,
        "text": "the garbage collector will copy things around as it reorganizes the heap.",
        "label": "ATTACK"
      },
      {
        "start": 265,
        "text": "on certain architectures it's possible that a page will be freed and the secret will remain when some other program allocates that same page",
        "label": "ATTACK"
      }
    ],
    "sentText": "in java the old way of storing a secret, such as a password, was to use [code] as you could overwrite its data when you were done with it. however this has since been shown to be insecure as the garbage collector will copy things around as it reorganizes the heap. on certain architectures it's possible that a page will be freed and the secret will remain when some other program allocates that same page. this is horribly ugly, but what if the secret were stored on the stack of a thread's [code] method? care would still need to be taken to terminate the thread gracefully, so that it could zero out its data, but this problem was present in the old way as well. one major problem i see straight away is that i can't think of a safe way to get data in and out of the container. you could minimize the likelihood of a leaked secret by using streams with very small internal buffers, but in the end you wind up with the same problem as [code]. [edit: would a single [code] member and a flag work? although that would limit you to one secret per classloader. this adds more ugliness, but it might be easy enough to hide behind a well-written interface.] [code] you could store the secret as one or two [code]s. "
  },
  {
    "sentId": 123,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "send something like [code]",
        "em2Text": "executed on every client browser",
        "label": "None"
      },
      {
        "em1Text": "send something like [code]",
        "em2Text": "a xss vulnerability",
        "label": "None"
      },
      {
        "em1Text": "executed on every client browser",
        "em2Text": "send something like [code]",
        "label": "PARENT"
      },
      {
        "em1Text": "executed on every client browser",
        "em2Text": "a xss vulnerability",
        "label": "None"
      },
      {
        "em1Text": "a xss vulnerability",
        "em2Text": "send something like [code]",
        "label": "None"
      },
      {
        "em1Text": "a xss vulnerability",
        "em2Text": "executed on every client browser",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 13,
        "text": "send something like [code]",
        "label": "ATTACK"
      },
      {
        "start": 47,
        "text": "executed on every client browser",
        "label": "ATTACK"
      },
      {
        "start": 118,
        "text": "a xss vulnerability",
        "label": "ATTACK"
      }
    ],
    "sentText": "but when you send something like [code], it is executed on every client browser. how can i be 100% sure of not having a xss vulnerability on my chat? "
  },
  {
    "sentId": 108,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "hacker can get onto your filesystem",
        "em2Text": "see your session file contents",
        "label": "None"
      },
      {
        "em1Text": "hacker can get onto your filesystem",
        "em2Text": "reproduced by the intruder",
        "label": "None"
      },
      {
        "em1Text": "hacker can get onto your filesystem",
        "em2Text": "hijack into a session",
        "label": "None"
      },
      {
        "em1Text": "see your session file contents",
        "em2Text": "hacker can get onto your filesystem",
        "label": "PARENT"
      },
      {
        "em1Text": "see your session file contents",
        "em2Text": "reproduced by the intruder",
        "label": "OR"
      },
      {
        "em1Text": "see your session file contents",
        "em2Text": "hijack into a session",
        "label": "None"
      },
      {
        "em1Text": "reproduced by the intruder",
        "em2Text": "hacker can get onto your filesystem",
        "label": "None"
      },
      {
        "em1Text": "reproduced by the intruder",
        "em2Text": "see your session file contents",
        "label": "None"
      },
      {
        "em1Text": "reproduced by the intruder",
        "em2Text": "hijack into a session",
        "label": "None"
      },
      {
        "em1Text": "hijack into a session",
        "em2Text": "hacker can get onto your filesystem",
        "label": "None"
      },
      {
        "em1Text": "hijack into a session",
        "em2Text": "see your session file contents",
        "label": "PARENT"
      },
      {
        "em1Text": "hijack into a session",
        "em2Text": "reproduced by the intruder",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 5,
        "text": "hacker can get onto your filesystem",
        "label": "ATTACK"
      },
      {
        "start": 44,
        "text": "see your session file contents",
        "label": "ATTACK"
      },
      {
        "start": 681,
        "text": "reproduced by the intruder",
        "label": "ATTACK"
      },
      {
        "start": 189,
        "text": "hijack into a session",
        "label": "ATTACK"
      }
    ],
    "sentText": "if a hacker can get onto your filesystem to see your session file contents, aren't you already hosed at that point? if you tie the session to an ip address, then it becomes a lot harder to hijack into a session. this is something i recommend doing, but you don't need to be utterly strict about it. you can just tie to the first three parts of the ipv4 or so. the choice is yours. the more strict ip check the more secure it is, but the less convenient it is for users. and as for tying the session based on the user agent, that may also help. it must be realized that if you work on an unencrypted channel (http for example), then the user agent check is less useful as it can be reproduced by the intruder as well. "
  },
  {
    "sentId": 115,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 148,
        "text": "read it if they wanted by going to [link]. ",
        "label": "ATTACK"
      }
    ],
    "sentText": "since the verification file is within the web servers root structure, and google needs to access it to read its contents - technically anyone could read it if they wanted by going to [link].  "
  },
  {
    "sentId": 23,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "your code being exploited maliciously",
        "em2Text": "through buffer overflow exploits",
        "label": "PARENT"
      },
      {
        "em1Text": "your code being exploited maliciously",
        "em2Text": "code injection",
        "label": "None"
      },
      {
        "em1Text": "through buffer overflow exploits",
        "em2Text": "your code being exploited maliciously",
        "label": "None"
      },
      {
        "em1Text": "through buffer overflow exploits",
        "em2Text": "code injection",
        "label": "OR"
      },
      {
        "em1Text": "code injection",
        "em2Text": "your code being exploited maliciously",
        "label": "None"
      },
      {
        "em1Text": "code injection",
        "em2Text": "through buffer overflow exploits",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 120,
        "text": "your code being exploited maliciously",
        "label": "ATTACK"
      },
      {
        "start": 164,
        "text": "through buffer overflow exploits",
        "label": "ATTACK"
      },
      {
        "start": 200,
        "text": "code injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "when writing code do you consciously program defensively to ensure high program quality and to avoid the possibility of your code being exploited maliciously, e.g. through buffer overflow exploits or code injection ? "
  },
  {
    "sentId": 144,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 39,
        "text": "cross-site scripting (xss)",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am trying to protect my website from cross-site scripting (xss) and i'm thinking of using regular expressions to validate user inputs.  "
  },
  {
    "sentId": 105,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "attacker gains access to your non-expiring access token",
        "em2Text": "call your resource server",
        "label": "None"
      },
      {
        "em1Text": "attacker gains access to your non-expiring access token",
        "em2Text": "get confidential data as response",
        "label": "None"
      },
      {
        "em1Text": "call your resource server",
        "em2Text": "attacker gains access to your non-expiring access token",
        "label": "PARENT"
      },
      {
        "em1Text": "call your resource server",
        "em2Text": "get confidential data as response",
        "label": "None"
      },
      {
        "em1Text": "get confidential data as response",
        "em2Text": "attacker gains access to your non-expiring access token",
        "label": "None"
      },
      {
        "em1Text": "get confidential data as response",
        "em2Text": "call your resource server",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 149,
        "text": "attacker gains access to your non-expiring access token",
        "label": "ATTACK"
      },
      {
        "start": 222,
        "text": "call your resource server",
        "label": "ATTACK"
      },
      {
        "start": 252,
        "text": "get confidential data as response",
        "label": "ATTACK"
      }
    ],
    "sentText": "the difference between a refresh token and a non-expiring access token in means of security is one additional call to the authorization server.if an attacker gains access to your non-expiring access token, he can directly call your resource server and get confidential data as response.<br />now if he steals your refresh token, he first has to call the authorization server and receive an access token in response. then he can query the resource server for confidential data. "
  },
  {
    "sentId": 28,
    "articleId": "3",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "sniff the username/password pair",
        "em2Text": "find out how they are generated",
        "label": "None"
      },
      {
        "em1Text": "sniff the username/password pair",
        "em2Text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "label": "None"
      },
      {
        "em1Text": "sniff the username/password pair",
        "em2Text": "lead to a denial of service attack",
        "label": "None"
      },
      {
        "em1Text": "find out how they are generated",
        "em2Text": "sniff the username/password pair",
        "label": "None"
      },
      {
        "em1Text": "find out how they are generated",
        "em2Text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "label": "AND"
      },
      {
        "em1Text": "find out how they are generated",
        "em2Text": "lead to a denial of service attack",
        "label": "None"
      },
      {
        "em1Text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "em2Text": "sniff the username/password pair",
        "label": "None"
      },
      {
        "em1Text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "em2Text": "find out how they are generated",
        "label": "None"
      },
      {
        "em1Text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "em2Text": "lead to a denial of service attack",
        "label": "None"
      },
      {
        "em1Text": "lead to a denial of service attack",
        "em2Text": "sniff the username/password pair",
        "label": "None"
      },
      {
        "em1Text": "lead to a denial of service attack",
        "em2Text": "find out how they are generated",
        "label": "PARENT"
      },
      {
        "em1Text": "lead to a denial of service attack",
        "em2Text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 98,
        "text": "sniff the username/password pair",
        "label": "ATTACK"
      },
      {
        "start": 923,
        "text": "find out how they are generated",
        "label": "ATTACK"
      },
      {
        "start": 977,
        "text": "generate a sequence of nonces of their own, in advance of the client generating the same sequence",
        "label": "ATTACK"
      },
      {
        "start": 1086,
        "text": "lead to a denial of service attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "username/password on each request. this guarantees authentication i guess, but if an attacker can sniff the username/password pair then it all fails.private key signing of each request. the server will have the public key, only the client will have the private key. this guarantees integrity because only the client could have generated the signature, but the server can check the signature. it generally guarantees authentication as well because the private key is not part of the request data and cannot be sniffed. however by itself it does not stop the transaction being replayed, because 2 transactions with the same data will have the same signature.using a cryptographic client nonce ( [link] ) as part of the request data and including that in the data to be signed. we have had issues with these especially when they are generated on the client side because if they aren't sufficiently random then an attacker can find out how they are generated then the attacker can generate a sequence of nonces of their own, in advance of the client generating the same sequence, which can lead to a denial of service attack because the client will be trying to re-use a nonce that has already been used by the attacker.  generating nonces on the server side has been considered but it's an extra transaction and potentially a performance issue.including a date/time in the request data, however this can cause issues where the client's clock and the server's clock drift out of sync. "
  },
  {
    "sentId": 29,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "someone will copy the embed code from one site",
        "em2Text": "put it on another",
        "label": "AND"
      },
      {
        "em1Text": "someone will copy the embed code from one site",
        "em2Text": "an enemy of the site hosting my embed will deceptively lure their own users to use the widget",
        "label": "None"
      },
      {
        "em1Text": "put it on another",
        "em2Text": "someone will copy the embed code from one site",
        "label": "None"
      },
      {
        "em1Text": "put it on another",
        "em2Text": "an enemy of the site hosting my embed will deceptively lure their own users to use the widget",
        "label": "None"
      },
      {
        "em1Text": "an enemy of the site hosting my embed will deceptively lure their own users to use the widget",
        "em2Text": "someone will copy the embed code from one site",
        "label": "PARENT"
      },
      {
        "em1Text": "an enemy of the site hosting my embed will deceptively lure their own users to use the widget",
        "em2Text": "put it on another",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 36,
        "text": "someone will copy the embed code from one site",
        "label": "ATTACK"
      },
      {
        "start": 87,
        "text": "put it on another",
        "label": "ATTACK"
      },
      {
        "start": 496,
        "text": "an enemy of the site hosting my embed will deceptively lure their own users to use the widget",
        "label": "ATTACK"
      }
    ],
    "sentText": "the security concern i have is that someone will copy the embed code from one site and put it on another. each page/site combination that implements my script/iframe is going to have a unique id that the site's developers will generate from an authenticated account on my site.  i then supply them with the appropriate embed code. i read [link] which was very helpful, but my use case is a bit different since i'm actually going to pop up content for users to interact with.  the concern is that an enemy of the site hosting my embed will deceptively lure their own users to use the widget. these users will believe they are interacting with my site on behalf of the enemy site but actually be interacting on behalf of the friendly site. "
  },
  {
    "sentId": 71,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 96,
        "text": "tampered software by an attacker",
        "label": "ATTACK"
      }
    ],
    "sentText": "for security reasons, it is desirable to check the integrity of code before execution, avoiding tampered software by an attacker. so, my question is "
  },
  {
    "sentId": 22,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "issue an http",
        "em2Text": "retrieve a form containing the anti-forgery token",
        "label": "AND"
      },
      {
        "em1Text": "issue an http",
        "em2Text": "make an illicit post which contains that same token",
        "label": "None"
      },
      {
        "em1Text": "retrieve a form containing the anti-forgery token",
        "em2Text": "issue an http",
        "label": "None"
      },
      {
        "em1Text": "retrieve a form containing the anti-forgery token",
        "em2Text": "make an illicit post which contains that same token",
        "label": "None"
      },
      {
        "em1Text": "make an illicit post which contains that same token",
        "em2Text": "issue an http",
        "label": "PARENT"
      },
      {
        "em1Text": "make an illicit post which contains that same token",
        "em2Text": "retrieve a form containing the anti-forgery token",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 224,
        "text": "issue an http",
        "label": "ATTACK"
      },
      {
        "start": 245,
        "text": "retrieve a form containing the anti-forgery token",
        "label": "ATTACK"
      },
      {
        "start": 305,
        "text": "make an illicit post which contains that same token",
        "label": "ATTACK"
      }
    ],
    "sentText": "incidentally, if same-origin does not affect form posts - then it makes it somewhat more obvious of why anti-forgery tokens are necessary.  i say \"somewhat\" because it seems too easy to believe that an attacker could simply issue an http get to retrieve a form containing the anti-forgery token, and then make an illicit post which contains that same token.  comments? "
  },
  {
    "sentId": 91,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 75,
        "text": "sql truncation",
        "label": "ATTACK"
      }
    ],
    "sentText": "the issue you might still be left with is a subset of sql injection called sql truncation. the idea is to force some part of the dynamic sql off the end of the string. i am not sure how likely this is to happen in practice, but, depending on how and where you are constructing the dynamic sql, you need to make sure that the variable holding the dynamic sql to execute is large enough to hold the static pieces in your code plus all of the variables assuming they are submitted at their maximum lengths. here is an article from msdn magazine, [link], that shows both regular sql injection as well as sql truncation. you will see in the article that to avoid sql injection they mostly just do the [code] method, but also show using [code] for some situations. "
  },
  {
    "sentId": 66,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "reverse engineering",
        "em2Text": "hit it using rest client",
        "label": "None"
      },
      {
        "em1Text": "hit it using rest client",
        "em2Text": "reverse engineering",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 199,
        "text": "reverse engineering",
        "label": "ATTACK"
      },
      {
        "start": 305,
        "text": "hit it using rest client",
        "label": "ATTACK"
      }
    ],
    "sentText": "hello i am working on android application in which i required to execute few https web services so all my webservice url and web api key are in the code plus ip address of the server. when anyone do reverse engineering of my app then that guy can get my web service url as well as api key then can simply hit it using rest client. "
  },
  {
    "sentId": 110,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sql injection",
        "em2Text": "script injection",
        "label": "AND"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "xss attacks",
        "label": "None"
      },
      {
        "em1Text": "script injection",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "script injection",
        "em2Text": "xss attacks",
        "label": "AND"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "xss attacks",
        "em2Text": "script injection",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 190,
        "text": "sql injection",
        "label": "ATTACK"
      },
      {
        "start": 310,
        "text": "script injection",
        "label": "ATTACK"
      },
      {
        "start": 328,
        "text": "xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have a html form that accepts user entered text of size about 1000, and is submitted to a php page where it will be stored in mysql database. i use pdo with prepared statements to prevent sql injection. but to sanitize the text entered by user, what are the best efforts needed to do ? i want to prevent any script injection, xss attacks, etc. security is an interesting concept and attracts a lot of people to it. unfortunately it's a complex subject and even the professionals get it wrong. i've found security holes in google (csrf), facebook (more csrf), several major online retailers (mainly sql injection / xss), as well as thousands of smaller sites both corporate and personal. 1) use parameterised queries<br />parameterised queries force the values passed to the query to be treated as separate data, so that the input values cannot be parsed as sql code by the dbms. a lot of people will recommend that you escape your strings using [code], but contrary to popular belief it is not a catch-all solution to sql injection. take this query for example: "
  },
  {
    "sentId": 118,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 40,
        "text": "code injectios",
        "label": "ATTACK"
      }
    ],
    "sentText": "and now, if both ways are vulnerable to code injectios, is there anyother way to implement html tags in the same way as a string into html pages? "
  },
  {
    "sentId": 63,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "access hidden fields",
        "em2Text": "using an intercepting proxy (or any number of tools)",
        "label": "PARENT"
      },
      {
        "em1Text": "using an intercepting proxy (or any number of tools)",
        "em2Text": "access hidden fields",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 13,
        "text": "access hidden fields",
        "label": "ATTACK"
      },
      {
        "start": 74,
        "text": "using an intercepting proxy (or any number of tools)",
        "label": "ATTACK"
      }
    ],
    "sentText": "a hacker can access hidden fields just as easily as querystring values by using an intercepting proxy (or any number of tools). "
  },
  {
    "sentId": 34,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 31,
        "text": "csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "is a web service vulnerable to csrf attack if the following are true? ancillary question: are [code] and [code] requests ever vulnerable to csrf? i ask because it seems that most (all?) browsers disallow these methods in html forms. edit: lots of good comments and answers so far, but no one has offered a specific csrf attack to which this web service is vulnerable. forging arbitrary csrf requests with arbitrary media types is effectively only possible with xhr, because a [link] and a [link]. however, [link].so the only threat comes from xhr-based csrf attacks. and those will only be successful if they are from the same origin, so basically from your own site somehow (e. g. xss). be careful not to mistake disabling cors (i.e. not setting access-control-allow-origin: *) as a protection. cors simply prevents clients from reading the response. the whole request is still sent and processed by the server. "
  },
  {
    "sentId": 36,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss attempt",
        "em2Text": "malicious character",
        "label": "OR"
      },
      {
        "em1Text": "malicious character",
        "em2Text": "xss attempt",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 85,
        "text": "xss attempt",
        "label": "ATTACK"
      },
      {
        "start": 102,
        "text": "malicious character",
        "label": "ATTACK"
      }
    ],
    "sentText": "\"a potentially dangerous request.form value was detected from the client may it be a xss attempt or a malicious character "
  },
  {
    "sentId": 32,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "user is logged in",
        "em2Text": "my vuex store retrieves all the info",
        "label": "None"
      },
      {
        "em1Text": "user is logged in",
        "em2Text": "user logs out",
        "label": "None"
      },
      {
        "em1Text": "user is logged in",
        "em2Text": "vuex state save still retains all its data",
        "label": "None"
      },
      {
        "em1Text": "user is logged in",
        "em2Text": "view what the state was before the user logged out",
        "label": "None"
      },
      {
        "em1Text": "my vuex store retrieves all the info",
        "em2Text": "user is logged in",
        "label": "PARENT"
      },
      {
        "em1Text": "my vuex store retrieves all the info",
        "em2Text": "user logs out",
        "label": "None"
      },
      {
        "em1Text": "my vuex store retrieves all the info",
        "em2Text": "vuex state save still retains all its data",
        "label": "None"
      },
      {
        "em1Text": "my vuex store retrieves all the info",
        "em2Text": "view what the state was before the user logged out",
        "label": "None"
      },
      {
        "em1Text": "user logs out",
        "em2Text": "user is logged in",
        "label": "None"
      },
      {
        "em1Text": "user logs out",
        "em2Text": "my vuex store retrieves all the info",
        "label": "PARENT"
      },
      {
        "em1Text": "user logs out",
        "em2Text": "vuex state save still retains all its data",
        "label": "None"
      },
      {
        "em1Text": "user logs out",
        "em2Text": "view what the state was before the user logged out",
        "label": "None"
      },
      {
        "em1Text": "vuex state save still retains all its data",
        "em2Text": "user is logged in",
        "label": "None"
      },
      {
        "em1Text": "vuex state save still retains all its data",
        "em2Text": "my vuex store retrieves all the info",
        "label": "None"
      },
      {
        "em1Text": "vuex state save still retains all its data",
        "em2Text": "user logs out",
        "label": "AND"
      },
      {
        "em1Text": "vuex state save still retains all its data",
        "em2Text": "view what the state was before the user logged out",
        "label": "None"
      },
      {
        "em1Text": "view what the state was before the user logged out",
        "em2Text": "user is logged in",
        "label": "None"
      },
      {
        "em1Text": "view what the state was before the user logged out",
        "em2Text": "my vuex store retrieves all the info",
        "label": "None"
      },
      {
        "em1Text": "view what the state was before the user logged out",
        "em2Text": "user logs out",
        "label": "None"
      },
      {
        "em1Text": "view what the state was before the user logged out",
        "em2Text": "vuex state save still retains all its data",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 72,
        "text": "user is logged in",
        "label": "ATTACK"
      },
      {
        "start": 154,
        "text": "my vuex store retrieves all the info",
        "label": "ATTACK"
      },
      {
        "start": 243,
        "text": "user logs out",
        "label": "ATTACK"
      },
      {
        "start": 265,
        "text": "vuex state save still retains all its data",
        "label": "ATTACK"
      },
      {
        "start": 396,
        "text": "view what the state was before the user logged out",
        "label": "ATTACK"
      }
    ],
    "sentText": "absolutely no data is stored in my vuex state when the page loadsif the user is logged in(or has info stored in [code] and therefore gets auto logged in) my vuex store retrieves all the info from a socket that requires authentication.then the user logs out, but my vuex state save still retains all its data this would be a security issue as not logged in people(or hackers) on a public pc could view what the state was before the user logged out. then call [code] when the user logs out. "
  },
  {
    "sentId": 122,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 288,
        "text": "stolen the cookie",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have followed the advice below to protect against any attack but think that the site is still vulnerable if somebody manages to get at the cookie (albeit only for a short time). is there a way to completely destroy the forms authentication session on logout so that even if someone had stolen the cookie there would be no chance of using it maliciously "
  },
  {
    "sentId": 72,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 391,
        "text": "modify the public  license key string in your apk file",
        "label": "ATTACK"
      }
    ],
    "sentText": "  security recommendation: it is highly recommended that you do not  hard-code the exact public license key string value as provided by  google play. instead, you can construct the whole public license key  string at runtime from substrings, or retrieve it from an encrypted  store, before passing it to the constructor. this approach makes it  more difficult for malicious third-parties to modify the public  license key string in your apk file. "
  },
  {
    "sentId": 44,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 20,
        "text": "xsrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "in order to prevent xsrf i force such request to be [code] requests. with [code] it's trivial to generate a xsrf using the following: "
  },
  {
    "sentId": 102,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 40,
        "text": "sql injection attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "by default does asp.net protect against sql injection attacks when using asp controls? "
  },
  {
    "sentId": 124,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 234,
        "text": "stealing of the session token",
        "label": "ATTACK"
      }
    ],
    "sentText": "how can i display the \"welcome, [your name]\" on public pages for authenticated users, even if they use http? of course, i would like to keep the access to the sensitive pages safe, and i should therefore keep [code] to avoid possible stealing of the session token. "
  },
  {
    "sentId": 49,
    "articleId": "6",
    "threatType": "R",
    "relationMentions": [
      {
        "em1Text": "convince users that an important message from a trusted site has been delivered",
        "em2Text": "trick those people into clicking through to some malware url ",
        "label": "None"
      },
      {
        "em1Text": "trick those people into clicking through to some malware url ",
        "em2Text": "convince users that an important message from a trusted site has been delivered",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 82,
        "text": "convince users that an important message from a trusted site has been delivered",
        "label": "ATTACK"
      },
      {
        "start": 167,
        "text": "trick those people into clicking through to some malware url ",
        "label": "ATTACK"
      }
    ],
    "sentText": "popup windows are a notable \"phishing\" technique. hostile sites can use popups to convince users that an important message from a trusted site has been delivered, and trick those people into clicking through to some malware url (or perhaps even just the click itself might exploit a bug).  yes, the main page of the site could do that too, but a well-crafted popup can distract the user and may not be directly associated with the hostile main page.popups were exploited by many unsavory sites as a way to \"trap\" users and to essentially force ad impressions, etc. in this respect, the security aspect of the problem really is the security of the user's control over their own computer and their browsing desires. "
  },
  {
    "sentId": 87,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 164,
        "text": "throw a [code] exception",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have a line where i grab a database row with [code].  a normal user would always send an [code] that exists in the database, but a hacker might not, and it would throw a [code] exception.  is it important to explicitly catch it or should i just leave the exception uncaught in that case?  either way, the hacker would not see any message so there is not any security risk either way. "
  },
  {
    "sentId": 19,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 126,
        "text": "replay attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "some sources says that the web browser generates the session key. now if the web browser generates it then its vulnerable for replay attacks.  "
  },
  {
    "sentId": 48,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sent a request with the following url to my asp.net 4.0 web forms application (running on iis 7.0):[code]",
        "em2Text": "[code]",
        "label": "None"
      },
      {
        "em1Text": "[code]",
        "em2Text": "sent a request with the following url to my asp.net 4.0 web forms application (running on iis 7.0):[code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 25,
        "text": "sent a request with the following url to my asp.net 4.0 web forms application (running on iis 7.0):[code]",
        "label": "ATTACK"
      },
      {
        "start": 124,
        "text": "[code]",
        "label": "ATTACK"
      }
    ],
    "sentText": "someone (probably a bot) sent a request with the following url to my asp.net 4.0 web forms application (running on iis 7.0):[code] this caused an [code]. i received a logging email from asp.net healthmonitoring i had configured, telling me: [code] i've tested that a colon in a query string (like [code]) does not cause this exception. on ntfs, a given filepath can have multiple associated data streams. apart from the main stream, also known as [code], there can be others, typically used to store metadata like the internet zone marker in downloaded files. [link] are accessed using a colon separator, eg. [code] is an alternative way of saying [code]. the presense of adss through the web has caused microsoft some security issues in the past (eg. returning the source code of asp pages instead of executing them), so as a precaution they're blocking the use of colon in the path part of the url, as the path part often maps to the filesystem (though not in your case). this is less likely to occur from the query string so is not blocked there. there are other characters that even if you turn request validation off you can't put in a path part for routing purposes. in particular, slashes ([code], [code], and byte sequences that would be invalid overlong utf-8 sequences resolving to the same) and the zero byte. it's best to be conservative about what you put in paths in general. "
  },
  {
    "sentId": 163,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 28,
        "text": "avoid attackers to steal the token from a cookie",
        "label": "ATTACK"
      }
    ],
    "sentText": "additional question: how to avoid attackers to steal the token from a cookie? "
  },
  {
    "sentId": 33,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "create a random guid/cryptographically strong random number",
        "em2Text": "send a unique url containing the random number to the user's email  address",
        "label": "AND"
      },
      {
        "em1Text": "create a random guid/cryptographically strong random number",
        "em2Text": "when confirmed, the user is asked to change password",
        "label": "None"
      },
      {
        "em1Text": "create a random guid/cryptographically strong random number",
        "em2Text": "a [code] attack",
        "label": "None"
      },
      {
        "em1Text": "send a unique url containing the random number to the user's email  address",
        "em2Text": "create a random guid/cryptographically strong random number",
        "label": "None"
      },
      {
        "em1Text": "send a unique url containing the random number to the user's email  address",
        "em2Text": "when confirmed, the user is asked to change password",
        "label": "AND"
      },
      {
        "em1Text": "send a unique url containing the random number to the user's email  address",
        "em2Text": "a [code] attack",
        "label": "None"
      },
      {
        "em1Text": "when confirmed, the user is asked to change password",
        "em2Text": "create a random guid/cryptographically strong random number",
        "label": "None"
      },
      {
        "em1Text": "when confirmed, the user is asked to change password",
        "em2Text": "send a unique url containing the random number to the user's email  address",
        "label": "None"
      },
      {
        "em1Text": "when confirmed, the user is asked to change password",
        "em2Text": "a [code] attack",
        "label": "None"
      },
      {
        "em1Text": "a [code] attack",
        "em2Text": "create a random guid/cryptographically strong random number",
        "label": "None"
      },
      {
        "em1Text": "a [code] attack",
        "em2Text": "send a unique url containing the random number to the user's email  address",
        "label": "None"
      },
      {
        "em1Text": "a [code] attack",
        "em2Text": "when confirmed, the user is asked to change password",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 60,
        "text": "create a random guid/cryptographically strong random number",
        "label": "ATTACK"
      },
      {
        "start": 126,
        "text": "send a unique url containing the random number to the user's email  address",
        "label": "ATTACK"
      },
      {
        "start": 208,
        "text": "when confirmed, the user is asked to change password",
        "label": "ATTACK"
      },
      {
        "start": 289,
        "text": "a [code] attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "  a common method that's been mentioned is to simply:    1) create a random guid/cryptographically strong random number    2) send a unique url containing the random number to the user's email  address    3) when confirmed, the user is asked to change password however, isn't this open to a [code] attack? if sending a temporary passwords over the internet to an email is insecure, what's the difference between doing that and simply sending a unique url which the attacker can navigate to? have i missed a key step somewhere that will make this system more secure (or is there a better way of resetting the password)? "
  },
  {
    "sentId": 27,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "server allow cross-website requests",
        "em2Text": "specify some external script that could be dangerous",
        "label": "None"
      },
      {
        "em1Text": "specify some external script that could be dangerous",
        "em2Text": "server allow cross-website requests",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 93,
        "text": "server allow cross-website requests",
        "label": "ATTACK"
      },
      {
        "start": 148,
        "text": "specify some external script that could be dangerous",
        "label": "ATTACK"
      }
    ],
    "sentText": "now let's imagine someone want to include some malicious script within your website. if your server allow cross-website requests, then people could specify some external script that could be dangerous for your server or the others users. "
  },
  {
    "sentId": 96,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "insert html code in his input data",
        "em2Text": "you later inserts in a web page that is sent to another user",
        "label": "None"
      },
      {
        "em1Text": "you later inserts in a web page that is sent to another user",
        "em2Text": "insert html code in his input data",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 39,
        "text": "insert html code in his input data",
        "label": "ATTACK"
      },
      {
        "start": 79,
        "text": "you later inserts in a web page that is sent to another user",
        "label": "ATTACK"
      }
    ],
    "sentText": "the danger in xss is that one user may insert html code in his input data that you later inserts in a web page that is sent to another user. "
  },
  {
    "sentId": 30,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 43,
        "text": "any data written to passwordvault from one desktop app (not a native uwp app) can be read from any other desktop app.",
        "label": "ATTACK"
      }
    ],
    "sentText": "i did some experiments and it appears that any data written to passwordvault from one desktop app (not a native uwp app) can be read from any other desktop app. even packaging my desktop app with [link] technology and thus having a package identity does not fix this vulnerability. "
  },
  {
    "sentId": 15,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "information could be revealed",
        "em2Text": "string object contains sensitive information",
        "label": "PARENT"
      },
      {
        "em1Text": "information could be revealed",
        "em2Text": "application cannot delete the data from computer memory",
        "label": "None"
      },
      {
        "em1Text": "information could be revealed",
        "em2Text": "[code] software that could capture the \"value\" of local variable",
        "label": "None"
      },
      {
        "em1Text": "string object contains sensitive information",
        "em2Text": "information could be revealed",
        "label": "None"
      },
      {
        "em1Text": "string object contains sensitive information",
        "em2Text": "application cannot delete the data from computer memory",
        "label": "AND"
      },
      {
        "em1Text": "string object contains sensitive information",
        "em2Text": "[code] software that could capture the \"value\" of local variable",
        "label": "None"
      },
      {
        "em1Text": "application cannot delete the data from computer memory",
        "em2Text": "information could be revealed",
        "label": "None"
      },
      {
        "em1Text": "application cannot delete the data from computer memory",
        "em2Text": "string object contains sensitive information",
        "label": "None"
      },
      {
        "em1Text": "application cannot delete the data from computer memory",
        "em2Text": "[code] software that could capture the \"value\" of local variable",
        "label": "AND"
      },
      {
        "em1Text": "[code] software that could capture the \"value\" of local variable",
        "em2Text": "information could be revealed",
        "label": "None"
      },
      {
        "em1Text": "[code] software that could capture the \"value\" of local variable",
        "em2Text": "string object contains sensitive information",
        "label": "None"
      },
      {
        "em1Text": "[code] software that could capture the \"value\" of local variable",
        "em2Text": "application cannot delete the data from computer memory",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 396,
        "text": "information could be revealed",
        "label": "ATTACK"
      },
      {
        "start": 273,
        "text": "string object contains sensitive information",
        "label": "ATTACK"
      },
      {
        "start": 456,
        "text": "application cannot delete the data from computer memory",
        "label": "ATTACK"
      },
      {
        "start": 860,
        "text": "[code] software that could capture the \"value\" of local variable",
        "label": "ATTACK"
      }
    ],
    "sentText": "  is both immutable and, when no longer needed, cannot be programmatically scheduled for garbage collection; that is, the instance is read-only after it is created and it is not possible to predict when the instance will be deleted from computer memory. consequently, if a string object contains sensitive information such as a password, credit card number, or personal data, there is a risk the information could be revealed after it is used because your application cannot delete the data from computer memory. a password appears in a log file accidentally.a password is being shown at somewhere - once a gui did show a command line of application that was being run, and the command line consisted of password. oops.using memory profiler to profile software with your colleague. colleague sees your password in memory. sounds unreal? not at all.i once used [code] software that could capture the \"value\" of local variables in case of exceptions, amazingly useful. though, i can imagine that it will log \"string passwords\" accidentally.a crash dump that includes string password. "
  },
  {
    "sentId": 7,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "leak the database table",
        "em2Text": "impersonating users",
        "label": "PARENT"
      },
      {
        "em1Text": "impersonating users",
        "em2Text": "leak the database table",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 63,
        "text": "leak the database table",
        "label": "ATTACK"
      },
      {
        "start": 134,
        "text": "impersonating users",
        "label": "ATTACK"
      }
    ],
    "sentText": "this approach provides defense-in-depth. if someone manages to leak the database table, it does not give an attacker an open door for impersonating users. "
  },
  {
    "sentId": 95,
    "articleId": "6",
    "threatType": "D",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 64,
        "text": "an attacket uses this code to bypass the csrf token",
        "label": "ATTACK"
      }
    ],
    "sentText": "lets say we have a typical csrf protection like this onewhat if an attacket uses this code to bypass the csrf token? "
  },
  {
    "sentId": 12,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "people going to his website were getting 168 viruses trying to download to their computers",
        "em2Text": "his ftp password was a plain dictionary word six letters long",
        "label": "PARENT"
      },
      {
        "em1Text": "his ftp password was a plain dictionary word six letters long",
        "em2Text": "people going to his website were getting 168 viruses trying to download to their computers",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 32,
        "text": "people going to his website were getting 168 viruses trying to download to their computers",
        "label": "ATTACK"
      },
      {
        "start": 244,
        "text": "his ftp password was a plain dictionary word six letters long",
        "label": "ATTACK"
      }
    ],
    "sentText": "my dad called me today and said people going to his website were getting 168 viruses trying to download to their computers. he isn't technical at all, and built the whole thing with a wysiwyg editor. so i commented it out for now. it turns out his ftp password was a plain dictionary word six letters long, so we think that's how it got hacked. we've changed his password to an 8+ digit non-word string (he wouldn't go for a passphrase since he is a hunt-n-peck typer). "
  },
  {
    "sentId": 105,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "see data or change settings they shouldn't",
        "em2Text": "touching the blinkenlights",
        "label": "None"
      },
      {
        "em1Text": "touching the blinkenlights",
        "em2Text": "see data or change settings they shouldn't",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 89,
        "text": "see data or change settings they shouldn't",
        "label": "ATTACK"
      },
      {
        "start": 367,
        "text": "touching the blinkenlights",
        "label": "ATTACK"
      }
    ],
    "sentText": "we need some way of authenticating a user login/session so that we don't allow people to see data or change settings they shouldn't. the device is not intended to be directly exposed to the internet or be 100% impregnable to serious hacking (network security / separation is the customer's issue*), the security requirement is more about keeping the lower ranks from touching the blinkenlights ;) "
  },
  {
    "sentId": 75,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 120,
        "text": "the timestamp can be used to calculate server uptime",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have a security scan finding directing me to disable tcp timestamps. i understand the reasons for the recommendation: the timestamp can be used to calculate server uptime, which can be helpful to an attacker (good explanation under heading \"tcp timestamps\" at [link]). "
  },
  {
    "sentId": 88,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "get the token",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "get the token",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 425,
        "text": "get the token",
        "label": "ATTACK"
      },
      {
        "start": 285,
        "text": "csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "but what does that accomplish? aren't you just taking session data, putting it in the page, and then comparing it with the exact same session data? seems like circular reasoning. these articles keep talking about following the \"same-origin policy\" but that makes no sense, because all csrf attacks are of the same origin as the user, just tricking the user into doing actions he/she didn't intend. the attacker has no way to get the token. therefore the requests won't take any effect. i recommend this post from gnucitizen. it has a pretty decent csrf explanation: [link] "
  },
  {
    "sentId": 26,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "add malicious code",
        "em2Text": "upload to an alternate app store",
        "label": "None"
      },
      {
        "em1Text": "add malicious code",
        "em2Text": "dupe users in to downloading it",
        "label": "None"
      },
      {
        "em1Text": "upload to an alternate app store",
        "em2Text": "add malicious code",
        "label": "PARENT"
      },
      {
        "em1Text": "upload to an alternate app store",
        "em2Text": "dupe users in to downloading it",
        "label": "None"
      },
      {
        "em1Text": "dupe users in to downloading it",
        "em2Text": "add malicious code",
        "label": "None"
      },
      {
        "em1Text": "dupe users in to downloading it",
        "em2Text": "upload to an alternate app store",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 60,
        "text": "add malicious code",
        "label": "ATTACK"
      },
      {
        "start": 83,
        "text": "upload to an alternate app store",
        "label": "ATTACK"
      },
      {
        "start": 120,
        "text": "dupe users in to downloading it",
        "label": "ATTACK"
      }
    ],
    "sentText": "the concern is if the app is targeted by hackers they could add malicious code and upload to an alternate app store and dupe users in to downloading it.  "
  },
  {
    "sentId": 32,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "sql injection",
        "em2Text": "insert a proc call",
        "label": "PARENT"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "break out of the regexp",
        "label": "PARENT"
      },
      {
        "em1Text": "insert a proc call",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "insert a proc call",
        "em2Text": "break out of the regexp",
        "label": "OR"
      },
      {
        "em1Text": "break out of the regexp",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "break out of the regexp",
        "em2Text": "insert a proc call",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 195,
        "text": "sql injection",
        "label": "ATTACK"
      },
      {
        "start": 420,
        "text": "insert a proc call",
        "label": "ATTACK"
      },
      {
        "start": 455,
        "text": "break out of the regexp",
        "label": "ATTACK"
      }
    ],
    "sentText": "i want to write a function that allows users to match data based on a regexp, but i am concerned about sanitation of the user strings. i know with sql queries you can use bind variables to avoid sql injection attacks, but i am not sure if there's such a mechanism for regexps. i see that there's [link], but i want to allow valid regexps. since i am just matching directly on [code] is there a chance that someone could insert a proc call or something to break out of the regexp and cause havoc? "
  },
  {
    "sentId": 92,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "redirect attack",
        "em2Text": "modifying the url value to a malicious site",
        "label": "None"
      },
      {
        "em1Text": "redirect attack",
        "em2Text": "launch a phishing scam",
        "label": "None"
      },
      {
        "em1Text": "redirect attack",
        "em2Text": "steal user credentials",
        "label": "PARENT"
      },
      {
        "em1Text": "modifying the url value to a malicious site",
        "em2Text": "redirect attack",
        "label": "None"
      },
      {
        "em1Text": "modifying the url value to a malicious site",
        "em2Text": "launch a phishing scam",
        "label": "None"
      },
      {
        "em1Text": "modifying the url value to a malicious site",
        "em2Text": "steal user credentials",
        "label": "None"
      },
      {
        "em1Text": "launch a phishing scam",
        "em2Text": "redirect attack",
        "label": "None"
      },
      {
        "em1Text": "launch a phishing scam",
        "em2Text": "modifying the url value to a malicious site",
        "label": "PARENT"
      },
      {
        "em1Text": "launch a phishing scam",
        "em2Text": "steal user credentials",
        "label": "AND"
      },
      {
        "em1Text": "steal user credentials",
        "em2Text": "redirect attack",
        "label": "None"
      },
      {
        "em1Text": "steal user credentials",
        "em2Text": "modifying the url value to a malicious site",
        "label": "None"
      },
      {
        "em1Text": "steal user credentials",
        "em2Text": "launch a phishing scam",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 27,
        "text": "redirect attack",
        "label": "ATTACK"
      },
      {
        "start": 307,
        "text": "modifying the url value to a malicious site",
        "label": "ATTACK"
      },
      {
        "start": 381,
        "text": "launch a phishing scam",
        "label": "ATTACK"
      },
      {
        "start": 408,
        "text": "steal user credentials",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm trying to prevent open redirect attack. please look at the code below and check for security: is it enough for preventing open redirect attack or should i add anything else?   an http parameter may contain a url value and could cause the web application to redirect the request to the specified url. by modifying the url value to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance. the suggestion of [code] strategy to prevent open redirect attack: "
  },
  {
    "sentId": 77,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 71,
        "text": "inject javascript and manipulate the variables or access functions",
        "label": "ATTACK"
      }
    ],
    "sentText": "are there ways to prevent, or make it difficult enough, for someone to inject javascript and manipulate the variables or access functions? a thought i had is to change all var names randomly on each reload so the malware script would need to be rewritten every time? or are there other less painful ways? "
  },
  {
    "sentId": 72,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "some man-in-the-middle (mitm) to sniff the encryption keys during the pairing process",
        "em2Text": "compromise the connection",
        "label": "None"
      },
      {
        "em1Text": "compromise the connection",
        "em2Text": "some man-in-the-middle (mitm) to sniff the encryption keys during the pairing process",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 166,
        "text": "some man-in-the-middle (mitm) to sniff the encryption keys during the pairing process",
        "label": "ATTACK"
      },
      {
        "start": 261,
        "text": "compromise the connection",
        "label": "ATTACK"
      }
    ],
    "sentText": "is my data safe if i pair the phone to the device? - i suppose so, though i understand that the pairing process itself is flawed, so it is theoretically possible for some man-in-the-middle (mitm) to sniff the encryption keys during the pairing process and thus compromise the connection.i need each device to be paired to several phones (but only communicating to one at a time). what's the maximum number of pairings pr. device? - unfortunately i need to pair a rather large number of phones to my device(s).can i perhaps get the pairing data (long term keys etc.) from the device and store it on some external memory, to increase this limit.can i make a safe data connection to the device without pairing, or maybe by re-pairing when i need to do so? - how safe is this procedure with regards to mitm attacks? "
  },
  {
    "sentId": 52,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "sql injection",
        "em2Text": "blind sql injection",
        "label": "PARENT"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "attacker is able to execute sql",
        "label": "None"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "attacker will know that he can execute sql",
        "label": "None"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "follow it up with a [link] to infect your server",
        "label": "None"
      },
      {
        "em1Text": "blind sql injection",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "blind sql injection",
        "em2Text": "attacker is able to execute sql",
        "label": "PARENT"
      },
      {
        "em1Text": "blind sql injection",
        "em2Text": "attacker will know that he can execute sql",
        "label": "None"
      },
      {
        "em1Text": "blind sql injection",
        "em2Text": "follow it up with a [link] to infect your server",
        "label": "None"
      },
      {
        "em1Text": "attacker is able to execute sql",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "attacker is able to execute sql",
        "em2Text": "blind sql injection",
        "label": "None"
      },
      {
        "em1Text": "attacker is able to execute sql",
        "em2Text": "attacker will know that he can execute sql",
        "label": "PARENT"
      },
      {
        "em1Text": "attacker is able to execute sql",
        "em2Text": "follow it up with a [link] to infect your server",
        "label": "None"
      },
      {
        "em1Text": "attacker will know that he can execute sql",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "attacker will know that he can execute sql",
        "em2Text": "blind sql injection",
        "label": "None"
      },
      {
        "em1Text": "attacker will know that he can execute sql",
        "em2Text": "attacker is able to execute sql",
        "label": "None"
      },
      {
        "em1Text": "attacker will know that he can execute sql",
        "em2Text": "follow it up with a [link] to infect your server",
        "label": "AND"
      },
      {
        "em1Text": "follow it up with a [link] to infect your server",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "follow it up with a [link] to infect your server",
        "em2Text": "blind sql injection",
        "label": "None"
      },
      {
        "em1Text": "follow it up with a [link] to infect your server",
        "em2Text": "attacker is able to execute sql",
        "label": "None"
      },
      {
        "em1Text": "follow it up with a [link] to infect your server",
        "em2Text": "attacker will know that he can execute sql",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 30,
        "text": "sql injection",
        "label": "ATTACK"
      },
      {
        "start": 117,
        "text": "blind sql injection",
        "label": "ATTACK"
      },
      {
        "start": 148,
        "text": "attacker is able to execute sql",
        "label": "ATTACK"
      },
      {
        "start": 275,
        "text": "attacker will know that he can execute sql",
        "label": "ATTACK"
      },
      {
        "start": 377,
        "text": "follow it up with a [link] to infect your server",
        "label": "ATTACK"
      }
    ],
    "sentText": "he is testing your server for sql injection,  specifically this is a robust test that will work even if its [link].  blind sql injection is when an attacker is able to execute sql however,  there isn't a viewable response.   if the http request takes at least 15 seconds the attacker will know that he can execute sql, and that your running ms-sql.   after this attack he will follow it up with a [link] to infect your server.  "
  },
  {
    "sentId": 75,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "attacked by repeated remote form submissions",
        "em2Text": "requests the form page first",
        "label": "None"
      },
      {
        "em1Text": "attacked by repeated remote form submissions",
        "em2Text": "starting a valid session",
        "label": "None"
      },
      {
        "em1Text": "attacked by repeated remote form submissions",
        "em2Text": "then passes the session cookie in the following post request",
        "label": "None"
      },
      {
        "em1Text": "attacked by repeated remote form submissions",
        "em2Text": "having a valid session token",
        "label": "PARENT"
      },
      {
        "em1Text": "requests the form page first",
        "em2Text": "attacked by repeated remote form submissions",
        "label": "None"
      },
      {
        "em1Text": "requests the form page first",
        "em2Text": "starting a valid session",
        "label": "AND"
      },
      {
        "em1Text": "requests the form page first",
        "em2Text": "then passes the session cookie in the following post request",
        "label": "None"
      },
      {
        "em1Text": "requests the form page first",
        "em2Text": "having a valid session token",
        "label": "None"
      },
      {
        "em1Text": "starting a valid session",
        "em2Text": "attacked by repeated remote form submissions",
        "label": "None"
      },
      {
        "em1Text": "starting a valid session",
        "em2Text": "requests the form page first",
        "label": "None"
      },
      {
        "em1Text": "starting a valid session",
        "em2Text": "then passes the session cookie in the following post request",
        "label": "AND"
      },
      {
        "em1Text": "starting a valid session",
        "em2Text": "having a valid session token",
        "label": "None"
      },
      {
        "em1Text": "then passes the session cookie in the following post request",
        "em2Text": "attacked by repeated remote form submissions",
        "label": "None"
      },
      {
        "em1Text": "then passes the session cookie in the following post request",
        "em2Text": "requests the form page first",
        "label": "None"
      },
      {
        "em1Text": "then passes the session cookie in the following post request",
        "em2Text": "starting a valid session",
        "label": "None"
      },
      {
        "em1Text": "then passes the session cookie in the following post request",
        "em2Text": "having a valid session token",
        "label": "None"
      },
      {
        "em1Text": "having a valid session token",
        "em2Text": "attacked by repeated remote form submissions",
        "label": "None"
      },
      {
        "em1Text": "having a valid session token",
        "em2Text": "requests the form page first",
        "label": "None"
      },
      {
        "em1Text": "having a valid session token",
        "em2Text": "starting a valid session",
        "label": "None"
      },
      {
        "em1Text": "having a valid session token",
        "em2Text": "then passes the session cookie in the following post request",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 40,
        "text": "attacked by repeated remote form submissions",
        "label": "ATTACK"
      },
      {
        "start": 112,
        "text": "requests the form page first",
        "label": "ATTACK"
      },
      {
        "start": 142,
        "text": "starting a valid session",
        "label": "ATTACK"
      },
      {
        "start": 172,
        "text": "then passes the session cookie in the following post request",
        "label": "ATTACK"
      },
      {
        "start": 244,
        "text": "having a valid session token",
        "label": "ATTACK"
      }
    ],
    "sentText": "i inherited some code that was recently attacked by repeated remote form submissions. however, the attacker now requests the form page first, starting a valid session, and then passes the session cookie in the following post request. therefore having a valid session token. so fail on my part. "
  },
  {
    "sentId": 20,
    "articleId": "1",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "attacker can decrypt authentication cookies",
        "em2Text": "generate authentication cookies with the name of any user",
        "label": "OR"
      },
      {
        "em1Text": "attacker can decrypt authentication cookies",
        "em2Text": "appear as anyone on the site",
        "label": "None"
      },
      {
        "em1Text": "attacker can decrypt authentication cookies",
        "em2Text": "decrypt (and also generate) session cookies",
        "label": "None"
      },
      {
        "em1Text": "attacker can decrypt authentication cookies",
        "em2Text": "the attacker can download any arbitrary file from your web application",
        "label": "None"
      },
      {
        "em1Text": "attacker can decrypt authentication cookies",
        "em2Text": "attacker gets the  secret keys",
        "label": "None"
      },
      {
        "em1Text": "generate authentication cookies with the name of any user",
        "em2Text": "attacker can decrypt authentication cookies",
        "label": "None"
      },
      {
        "em1Text": "generate authentication cookies with the name of any user",
        "em2Text": "appear as anyone on the site",
        "label": "OR"
      },
      {
        "em1Text": "generate authentication cookies with the name of any user",
        "em2Text": "decrypt (and also generate) session cookies",
        "label": "None"
      },
      {
        "em1Text": "generate authentication cookies with the name of any user",
        "em2Text": "the attacker can download any arbitrary file from your web application",
        "label": "None"
      },
      {
        "em1Text": "generate authentication cookies with the name of any user",
        "em2Text": "attacker gets the  secret keys",
        "label": "None"
      },
      {
        "em1Text": "appear as anyone on the site",
        "em2Text": "attacker can decrypt authentication cookies",
        "label": "None"
      },
      {
        "em1Text": "appear as anyone on the site",
        "em2Text": "generate authentication cookies with the name of any user",
        "label": "None"
      },
      {
        "em1Text": "appear as anyone on the site",
        "em2Text": "decrypt (and also generate) session cookies",
        "label": "OR"
      },
      {
        "em1Text": "appear as anyone on the site",
        "em2Text": "the attacker can download any arbitrary file from your web application",
        "label": "None"
      },
      {
        "em1Text": "appear as anyone on the site",
        "em2Text": "attacker gets the  secret keys",
        "label": "None"
      },
      {
        "em1Text": "decrypt (and also generate) session cookies",
        "em2Text": "attacker can decrypt authentication cookies",
        "label": "None"
      },
      {
        "em1Text": "decrypt (and also generate) session cookies",
        "em2Text": "generate authentication cookies with the name of any user",
        "label": "None"
      },
      {
        "em1Text": "decrypt (and also generate) session cookies",
        "em2Text": "appear as anyone on the site",
        "label": "None"
      },
      {
        "em1Text": "decrypt (and also generate) session cookies",
        "em2Text": "the attacker can download any arbitrary file from your web application",
        "label": "None"
      },
      {
        "em1Text": "decrypt (and also generate) session cookies",
        "em2Text": "attacker gets the  secret keys",
        "label": "None"
      },
      {
        "em1Text": "the attacker can download any arbitrary file from your web application",
        "em2Text": "attacker can decrypt authentication cookies",
        "label": "None"
      },
      {
        "em1Text": "the attacker can download any arbitrary file from your web application",
        "em2Text": "generate authentication cookies with the name of any user",
        "label": "None"
      },
      {
        "em1Text": "the attacker can download any arbitrary file from your web application",
        "em2Text": "appear as anyone on the site",
        "label": "None"
      },
      {
        "em1Text": "the attacker can download any arbitrary file from your web application",
        "em2Text": "decrypt (and also generate) session cookies",
        "label": "None"
      },
      {
        "em1Text": "the attacker can download any arbitrary file from your web application",
        "em2Text": "attacker gets the  secret keys",
        "label": "PARENT"
      },
      {
        "em1Text": "attacker gets the  secret keys",
        "em2Text": "attacker can decrypt authentication cookies",
        "label": "PARENT"
      },
      {
        "em1Text": "attacker gets the  secret keys",
        "em2Text": "generate authentication cookies with the name of any user",
        "label": "None"
      },
      {
        "em1Text": "attacker gets the  secret keys",
        "em2Text": "appear as anyone on the site",
        "label": "None"
      },
      {
        "em1Text": "attacker gets the  secret keys",
        "em2Text": "decrypt (and also generate) session cookies",
        "label": "None"
      },
      {
        "em1Text": "attacker gets the  secret keys",
        "em2Text": "the attacker can download any arbitrary file from your web application",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 245,
        "text": "attacker can decrypt authentication cookies",
        "label": "ATTACK"
      },
      {
        "start": 318,
        "text": "generate authentication cookies with the name of any user",
        "label": "ATTACK"
      },
      {
        "start": 390,
        "text": "appear as anyone on the site",
        "label": "ATTACK"
      },
      {
        "start": 575,
        "text": "decrypt (and also generate) session cookies",
        "label": "ATTACK"
      },
      {
        "start": 876,
        "text": "the attacker can download any arbitrary file from your web application",
        "label": "ATTACK"
      },
      {
        "start": 94,
        "text": "attacker gets the  secret keys",
        "label": "ATTACK"
      }
    ],
    "sentText": "  the first stage of the attack takes a  few thousand requests, but once it  succeeds and the attacker gets the  secret keys, it's totally stealthy.the  cryptographic knowledge required is  very basic. in posession of the app's machine key, the attacker can decrypt authentication cookies.even worse than that, he can generate authentication cookies with the name of any user. thus, he can appear as anyone on the site. the application is unable to differentiate between you or the hacker who generated an authentication cookie with your name for himself.it also lets him to decrypt (and also generate) session cookies, although this is not as dangerous as the previous one.not so serious: he can decrypt the encrypted viewstate of pages. (if you use viewstate to store confidental data, you shouldn't do this anyways!)quite unexpected: with the knowledge of the machine key, the attacker can download any arbitrary file from your web application, even those that normally can't be downloaded! (including web.config, etc.) "
  },
  {
    "sentId": 18,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 338,
        "text": "pull data from my database",
        "label": "ATTACK"
      }
    ],
    "sentText": "i will preface this question by saying i am not a web developer, nor do i have much knowledge in this field. i am a business owner and have a low volume website that my customers purchase products on. i've noticed this set of queries a few minutes ago and they appear very suspicious to me, a layperson. it looks as if they are trying to pull data from my database? i could be totally wrong, but someone please let me know what they think is going on here.  "
  },
  {
    "sentId": 55,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "use all these cookie for authentication",
        "em2Text": "cookie spoofing attack",
        "label": "None"
      },
      {
        "em1Text": "cookie spoofing attack",
        "em2Text": "use all these cookie for authentication",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 20,
        "text": "use all these cookie for authentication",
        "label": "ATTACK"
      },
      {
        "start": 364,
        "text": "cookie spoofing attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "my question is: why use all these cookie for authentication? my guess would be that maybe generating a session hash would be to easy so using the hashedpassword and userid adds security but what about cookie spoofing? i'm basically leaving on the client all fundamental informations. my main concern is about these solution giving to much information when under a cookie spoofing attack. "
  },
  {
    "sentId": 27,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "man in the middle attack",
        "em2Text": "eavesdropping",
        "label": "AND"
      },
      {
        "em1Text": "eavesdropping",
        "em2Text": "man in the middle attack",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 343,
        "text": "man in the middle attack",
        "label": "ATTACK"
      },
      {
        "start": 398,
        "text": "eavesdropping",
        "label": "ATTACK"
      }
    ],
    "sentText": "now adding a 3rd participant to this communication will not work because key exchange algorithms are designed to derive a shared secret from 2 public keys only (especially using .net and bouncycastle). so the question is, how would you go about implementing a n-party public key cryptography schema which is still authentic (i.e. resistant to man in the middle attack) and secure (i.e. secure from eavesdropping). "
  },
  {
    "sentId": 82,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "write to the task queue",
        "em2Text": "pown the worker processes",
        "label": "None"
      },
      {
        "em1Text": "write to the task queue",
        "em2Text": "writing malicious pickled objects",
        "label": "AND"
      },
      {
        "em1Text": "write to the task queue",
        "em2Text": "running tasks serialized with pickle",
        "label": "None"
      },
      {
        "em1Text": "pown the worker processes",
        "em2Text": "write to the task queue",
        "label": "None"
      },
      {
        "em1Text": "pown the worker processes",
        "em2Text": "writing malicious pickled objects",
        "label": "None"
      },
      {
        "em1Text": "pown the worker processes",
        "em2Text": "running tasks serialized with pickle",
        "label": "PARENT"
      },
      {
        "em1Text": "writing malicious pickled objects",
        "em2Text": "write to the task queue",
        "label": "None"
      },
      {
        "em1Text": "writing malicious pickled objects",
        "em2Text": "pown the worker processes",
        "label": "None"
      },
      {
        "em1Text": "writing malicious pickled objects",
        "em2Text": "running tasks serialized with pickle",
        "label": "None"
      },
      {
        "em1Text": "running tasks serialized with pickle",
        "em2Text": "write to the task queue",
        "label": "PARENT"
      },
      {
        "em1Text": "running tasks serialized with pickle",
        "em2Text": "pown the worker processes",
        "label": "None"
      },
      {
        "em1Text": "running tasks serialized with pickle",
        "em2Text": "writing malicious pickled objects",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 265,
        "text": "write to the task queue",
        "label": "ATTACK"
      },
      {
        "start": 305,
        "text": "pown the worker processes",
        "label": "ATTACK"
      },
      {
        "start": 334,
        "text": "writing malicious pickled objects",
        "label": "ATTACK"
      },
      {
        "start": 411,
        "text": "running tasks serialized with pickle",
        "label": "ATTACK"
      }
    ],
    "sentText": "but this doesn't solve the security problem.  even if tasks are serialized with json or similar, the workers will still execute tasks inserted into the queue with pickle serialization -- they just respond to the [code] parameter in the message.  so anybody who can write to the task queue can effectively pown the worker processes by writing malicious pickled objects. how can i prevent the worker threads from running tasks serialized with pickle? "
  },
  {
    "sentId": 61,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "that could (in theory) be tampered with by a malicious user",
        "em2Text": "the malicious user can inject an arbitrary r object that can be full of harmful code",
        "label": "PARENT"
      },
      {
        "em1Text": "the malicious user can inject an arbitrary r object that can be full of harmful code",
        "em2Text": "that could (in theory) be tampered with by a malicious user",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 91,
        "text": "that could (in theory) be tampered with by a malicious user",
        "label": "ATTACK"
      },
      {
        "start": 172,
        "text": "the malicious user can inject an arbitrary r object that can be full of harmful code",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am considering unserializing parts of information that will get transmitted via network, that could (in theory) be tampered with by a malicious user.  i understand, that the malicious user can inject an arbitrary r object that can be full of harmful code. but this is not what i am worrying about, because i can (i think i can) prevent such code from ever executing by careful handling of the received objects. "
  },
  {
    "sentId": 17,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 105,
        "text": "xss on a httml attribute",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm having to work on an old web app that a previous developer left. it is using addslashes() to prevent xss on a httml attribute. "
  },
  {
    "sentId": 142,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "a hacker to do packet sniffing",
        "em2Text": "use some other method",
        "label": "OR"
      },
      {
        "em1Text": "use some other method",
        "em2Text": "a hacker to do packet sniffing",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 81,
        "text": "a hacker to do packet sniffing",
        "label": "ATTACK"
      },
      {
        "start": 115,
        "text": "use some other method",
        "label": "ATTACK"
      }
    ],
    "sentText": "if a web server and a database server are on different hosts, is it possible for a hacker to do packet sniffing or use some other method to get the database username/password when you use mysql_connect in the php code? "
  },
  {
    "sentId": 19,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "relies on web services to provide catalog access",
        "em2Text": "accessing my web",
        "label": "AND"
      },
      {
        "em1Text": "relies on web services to provide catalog access",
        "em2Text": "replicating/scraping my entire catalog",
        "label": "None"
      },
      {
        "em1Text": "accessing my web",
        "em2Text": "relies on web services to provide catalog access",
        "label": "None"
      },
      {
        "em1Text": "accessing my web",
        "em2Text": "replicating/scraping my entire catalog",
        "label": "None"
      },
      {
        "em1Text": "replicating/scraping my entire catalog",
        "em2Text": "relies on web services to provide catalog access",
        "label": "None"
      },
      {
        "em1Text": "replicating/scraping my entire catalog",
        "em2Text": "accessing my web",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 51,
        "text": "relies on web services to provide catalog access",
        "label": "ATTACK"
      },
      {
        "start": 147,
        "text": "accessing my web",
        "label": "ATTACK"
      },
      {
        "start": 176,
        "text": "replicating/scraping my entire catalog",
        "label": "ATTACK"
      }
    ],
    "sentText": "i'm managing the development of an iphone app that relies on web services to provide catalog access. my main security concern right now is someone accessing my web service and replicating/scraping my entire catalog (right now, it doesn't contain anything proprietary - but that would change). "
  },
  {
    "sentId": 42,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss attacks",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "xss attacks",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 84,
        "text": "xss attacks",
        "label": "ATTACK"
      },
      {
        "start": 1116,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am working on a asp.net c# + jquery ajax website project.  i am trying to prevent xss attacks and i know below  is not the full approach, but this is at the least what i should do - to use htmlencode when accepting free string input from users).  and i really someone to kindly check if i am doing the right thing. you need to keep in mind the content type of each string you deal with and where it came from - whether from a safe source or an untrusted source, and also know when concatenating two strings that both are strings of the same content-type and trust-level.i wrapped up the &quot;description&quot; text using [code], so the string will be interpreted as pure text before going into database i.e. [code] becomes [code].here it sounds like you're saying the description field is a string of plain text and what you're storing in the database is a string of safe html (since [code]'s output is guaranteed not to contain dangerous code).this shows the first problem with prematurely encoding content.  if you're composing a sql string to send to the server, pre-encoding as html does not protect you from sql injection.  using a sql prepared statement is a good way to overcome this for sql, but pre-encoding does not render a string safe in all contexts.the part that follows is what i am in doubt - how to handle the html encoded text before returning it back to the user?when the user wants to view the description text entered, the website retrieved from database and prints it out.if the user is receiving safe html, and you have a string of safe html, you can just send that to the user.if the user is receiving a plain text email, then you need to convert the safe html stored in the database to plain text.if the user is receiving rss, then you need to make sure you compose your rss using substrings of xml.[link] can help you make sure values are properly encoded on output. "
  },
  {
    "sentId": 57,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "[code]",
        "em2Text": "set the  x-forwarded-for or the client-ip header to any arbitrary value it  wants",
        "label": "None"
      },
      {
        "em1Text": "set the  x-forwarded-for or the client-ip header to any arbitrary value it  wants",
        "em2Text": "[code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "[code]",
        "label": "ATTACK"
      },
      {
        "start": 235,
        "text": "set the  x-forwarded-for or the client-ip header to any arbitrary value it  wants",
        "label": "ATTACK"
      }
    ],
    "sentText": "[code] but as i've read a lot, i have seen that to use [code] is unsafe, as the comment below highlights:    do not use the above code unless you know exactly what it does! i've  seen massive security holes due to this. the client can set the  x-forwarded-for or the client-ip header to any arbitrary value it  wants. unless you have a trusted reverse proxy, you shouldn't use any  of those values. i've tried the simple [code], but this returns the wrong ip. i've tested this and my real ip follows this pattern: [code], but i get an ip address like: [code] short answer:[code]<hr />as of 2021 (and still) [code] is the only reliable way to get users ip address, but it can show erroneous results if behind a proxy server.<br />all other solutions imply security risks or can be easily faked. "
  },
  {
    "sentId": 25,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "the setup will be probed by a malicious user",
        "em2Text": "gain improper access",
        "label": "PARENT"
      },
      {
        "em1Text": "gain improper access",
        "em2Text": "the setup will be probed by a malicious user",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 15,
        "text": "the setup will be probed by a malicious user",
        "label": "ATTACK"
      },
      {
        "start": 365,
        "text": "gain improper access",
        "label": "ATTACK"
      }
    ],
    "sentText": "we assume that the setup will be probed by a malicious user. what is the worst that could happen? mysql provides various statements like show etc. that a user even having only select privileges could use to gather information about the database server or about my databases. other information could be obtained from error messages. while probably not sufficient to gain improper access, this information could surely help in doing so.there might be flaws in the database software, or in my scripts, or in the scripting language itself, that could allow a visitor to do things they are not supposed to be able to do through this interface.doing this might violate a terms of service agreement, particularly if i am using shared hosting. "
  },
  {
    "sentId": 134,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "steal session id cookies with javascript functions planted in trusted sites by other users",
        "em2Text": "a valid session id be used from another host",
        "label": "PARENT"
      },
      {
        "em1Text": "a valid session id be used from another host",
        "em2Text": "steal session id cookies with javascript functions planted in trusted sites by other users",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 14,
        "text": "steal session id cookies with javascript functions planted in trusted sites by other users",
        "label": "ATTACK"
      },
      {
        "start": 435,
        "text": "a valid session id be used from another host",
        "label": "ATTACK"
      }
    ],
    "sentText": "it is easy to steal session id cookies with javascript functions planted in trusted sites by other users. what are the possible counter-measures for this kind of attack?  rejecting all javascript scripts on the client-side is probably difficult because almost all sites use js. what are the possible counter-measures on the server-side? is it possible to include a hash of the client ip-address in the session id value to prevent that a valid session id be used from another host? does this approach make sense? "
  },
  {
    "sentId": 8,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 20,
        "text": "the vulnerability around csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "as i understand it, the vulnerability around csrf is introduced by the assumption that (from the webserver's point of view) a valid session cookie in an incoming http request reflects the wishes of an authenticated user. but all cookies for the origin domain are magically attached to the request by the browser, so really all the server can infer from the presence of a valid session cookie in a request is that the request comes from a browser which has an authenticated session; it cannot further assume anything about the code running in that browser, or whether it really reflects user wishes. the way to prevent this is to include additional authentication information (the \"csrf token\") in the request, carried by some means other than the browser's automatic cookie handling. loosely speaking, then, the session cookie authenticates the user/browser and the csrf token authenticates the code running in the browser. "
  },
  {
    "sentId": 68,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss",
        "em2Text": "have cors-like access to all resources on that domain",
        "label": "PARENT"
      },
      {
        "em1Text": "xss",
        "em2Text": "have the same level of access as an xss vulenrablity",
        "label": "None"
      },
      {
        "em1Text": "have cors-like access to all resources on that domain",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "have cors-like access to all resources on that domain",
        "em2Text": "have the same level of access as an xss vulenrablity",
        "label": "OR"
      },
      {
        "em1Text": "have the same level of access as an xss vulenrablity",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "have the same level of access as an xss vulenrablity",
        "em2Text": "have cors-like access to all resources on that domain",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 89,
        "text": "xss",
        "label": "ATTACK"
      },
      {
        "start": 474,
        "text": "have cors-like access to all resources on that domain",
        "label": "ATTACK"
      },
      {
        "start": 848,
        "text": "have the same level of access as an xss vulenrablity",
        "label": "ATTACK"
      }
    ],
    "sentText": "does having this line of code make my site more vulnerable to attack?  i've always heard xss discussed as a security issue, are there legitimate uses for xss? xss is not a feature that can be enabled in jquery.  it would be very very unusual if the jquery core had an xss vulnerability, but it is possible and its called [link].   \"cross-origin resource sharing\" or cors isn't the same as xss, but,  but if a web application had an xss vulnerability, then an attacker would have cors-like access to all resources on that domain.   in short, cors gives you control over how you break the [link] such that you don't need to introduce a full on xss vulnerability.   the [code] query feature relies upon the [code] http response header.  this could be a vulnerability. for example, if a web application had [code] on every page, then an attacker would have the same level of access as an xss vulenrablity.   be careful what pages you introduce cors headers,  and try and avoid [code] as much as possible.  so to answer your question:  no a web application never needs to introduce an xss vulnerability because there are way around the sop such as cors/jsonp/cross domain proxies/[link].   "
  },
  {
    "sentId": 36,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 83,
        "text": "sql injection vulnerabilities",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am in a situation where i inherited a rather large web application that has some sql injection vulnerabilities.  i have found several just by looking through the code for other issues, but i'm wondering if a safe way to find all sql injection vulnerabilities would be to search all files for instances of [code] and then check to see if they are parametrized queries.  is this a solid plan? "
  },
  {
    "sentId": 14,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 59,
        "text": "sql injections attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "there is a major problem in the code - it is vulnerable to sql injections attacks since the query is not parameterized through db api and is constructed via string formatting. if you call the function this way: "
  },
  {
    "sentId": 37,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "see the full stack trace including your file name and file line numbers",
        "em2Text": "give them some idea of how your app is architected",
        "label": "None"
      },
      {
        "em1Text": "give them some idea of how your app is architected",
        "em2Text": "see the full stack trace including your file name and file line numbers",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 370,
        "text": "see the full stack trace including your file name and file line numbers",
        "label": "ATTACK"
      },
      {
        "start": 455,
        "text": "give them some idea of how your app is architected",
        "label": "ATTACK"
      }
    ],
    "sentText": "here is another question to look at:[link]and more info on pdb files:[link]in general, i always include pdb files in my deployments, the gains are too huge to ignore.if you never expose a stack trace to your users (and generally you shouldn't), there isn't really any additional security risk of deploying pdb files.when a user visible stack trace happens, the user can see the full stack trace including your file name and file line numbers.  this could give them some idea of how your app is architected which would potentially help them if hacking.a bigger security threat is something like [link] which when used on your dlls will allow them to view your source code, with or without pdb files. "
  },
  {
    "sentId": 129,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "session fixation",
        "em2Text": "steal, guess or fix session id",
        "label": "None"
      },
      {
        "em1Text": "session fixation",
        "em2Text": "use it",
        "label": "None"
      },
      {
        "em1Text": "session fixation",
        "em2Text": "log in on target website as victim",
        "label": "PARENT"
      },
      {
        "em1Text": "session fixation",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "session fixation",
        "em2Text": "victim performs malicious action itself but does not know about it",
        "label": "None"
      },
      {
        "em1Text": "session fixation",
        "em2Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "None"
      },
      {
        "em1Text": "steal, guess or fix session id",
        "em2Text": "session fixation",
        "label": "None"
      },
      {
        "em1Text": "steal, guess or fix session id",
        "em2Text": "use it",
        "label": "AND"
      },
      {
        "em1Text": "steal, guess or fix session id",
        "em2Text": "log in on target website as victim",
        "label": "None"
      },
      {
        "em1Text": "steal, guess or fix session id",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "steal, guess or fix session id",
        "em2Text": "victim performs malicious action itself but does not know about it",
        "label": "None"
      },
      {
        "em1Text": "steal, guess or fix session id",
        "em2Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "None"
      },
      {
        "em1Text": "use it",
        "em2Text": "session fixation",
        "label": "None"
      },
      {
        "em1Text": "use it",
        "em2Text": "steal, guess or fix session id",
        "label": "None"
      },
      {
        "em1Text": "use it",
        "em2Text": "log in on target website as victim",
        "label": "AND"
      },
      {
        "em1Text": "use it",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "use it",
        "em2Text": "victim performs malicious action itself but does not know about it",
        "label": "None"
      },
      {
        "em1Text": "use it",
        "em2Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "None"
      },
      {
        "em1Text": "log in on target website as victim",
        "em2Text": "session fixation",
        "label": "None"
      },
      {
        "em1Text": "log in on target website as victim",
        "em2Text": "steal, guess or fix session id",
        "label": "None"
      },
      {
        "em1Text": "log in on target website as victim",
        "em2Text": "use it",
        "label": "None"
      },
      {
        "em1Text": "log in on target website as victim",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "log in on target website as victim",
        "em2Text": "victim performs malicious action itself but does not know about it",
        "label": "None"
      },
      {
        "em1Text": "log in on target website as victim",
        "em2Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "session fixation",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "steal, guess or fix session id",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "use it",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "log in on target website as victim",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "victim performs malicious action itself but does not know about it",
        "label": "None"
      },
      {
        "em1Text": "csrf",
        "em2Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "PARENT"
      },
      {
        "em1Text": "victim performs malicious action itself but does not know about it",
        "em2Text": "session fixation",
        "label": "None"
      },
      {
        "em1Text": "victim performs malicious action itself but does not know about it",
        "em2Text": "steal, guess or fix session id",
        "label": "None"
      },
      {
        "em1Text": "victim performs malicious action itself but does not know about it",
        "em2Text": "use it",
        "label": "None"
      },
      {
        "em1Text": "victim performs malicious action itself but does not know about it",
        "em2Text": "log in on target website as victim",
        "label": "None"
      },
      {
        "em1Text": "victim performs malicious action itself but does not know about it",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "victim performs malicious action itself but does not know about it",
        "em2Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "None"
      },
      {
        "em1Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "em2Text": "session fixation",
        "label": "None"
      },
      {
        "em1Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "em2Text": "steal, guess or fix session id",
        "label": "None"
      },
      {
        "em1Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "em2Text": "use it",
        "label": "None"
      },
      {
        "em1Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "em2Text": "log in on target website as victim",
        "label": "None"
      },
      {
        "em1Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "em2Text": "csrf",
        "label": "None"
      },
      {
        "em1Text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "em2Text": "victim performs malicious action itself but does not know about it",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 34,
        "text": "session fixation",
        "label": "ATTACK"
      },
      {
        "start": 738,
        "text": "steal, guess or fix session id",
        "label": "ATTACK"
      },
      {
        "start": 775,
        "text": "use it",
        "label": "ATTACK"
      },
      {
        "start": 786,
        "text": "log in on target website as victim",
        "label": "ATTACK"
      },
      {
        "start": 343,
        "text": "csrf",
        "label": "ATTACK"
      },
      {
        "start": 1203,
        "text": "victim performs malicious action itself but does not know about it",
        "label": "ATTACK"
      },
      {
        "start": 1276,
        "text": "victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability ",
        "label": "ATTACK"
      }
    ],
    "sentText": "what defines the two respectively?session fixation is described as:session fixation is an attack that permits an attacker to hijack a valid user session. the attack explores a limitation in the way the web application manages the session id, more specifically the vulnerable web application.`the source: [link]which seems rather close to what csrf exploits. what distinguishes the two from eachother or is [code] simply a synonym or a branch coming from csrf?would also like to mention that key terminology coming from the owasp link i provided is almost identical to those mentioned in csrf no, it is not a synonym. session fixation and csrf are two different attacks. session fixation is a class of session hijacking. attacker tries to steal, guess or fix session id, then use it and log in on target website as victim. it could be done many ways. basic protection is if app uses httponly flag, does not transfer session id in url (session.use_trans_sid=0, session.use_only_cookies=1) and takes care of xss vulnerabilities. csrf is another kind of attack. attacker does not want victim session id but rather causing the victim to perform an action on server where victim is properly logged in. so the victim performs malicious action itself but does not know about it. how? victim loads a page somewhere that contains malicious link in html (ie. img src) or target website contains xss vulnerability and it is  good point for loading external malicious javascript and issuing ajax requests. standard protection is csrf token. it is another token (next of session id) that is included in each sensitive request. attacker should not know current csrf token for particular user and can not prepare malicious link or ajax request. csrf token should be unique for each session. sensitive requests are form submissions, deleting/setting of something (permission etc.). so app does not have to protect absolutely each request. it also is not good idea to transmit csrf token in url. "
  },
  {
    "sentId": 36,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "send the iv in \"plaintext\" by prepending it to the cipher text",
        "em2Text": "tampering with the iv could tamper with the resulting plaintext on decryption",
        "label": "None"
      },
      {
        "em1Text": "tampering with the iv could tamper with the resulting plaintext on decryption",
        "em2Text": "send the iv in \"plaintext\" by prepending it to the cipher text",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 84,
        "text": "send the iv in \"plaintext\" by prepending it to the cipher text",
        "label": "ATTACK"
      },
      {
        "start": 316,
        "text": "tampering with the iv could tamper with the resulting plaintext on decryption",
        "label": "ATTACK"
      }
    ],
    "sentText": "from all the posts that i've seen so far, i'm uncertain as to whether it is safe to send the iv in \"plaintext\" by prepending it to the cipher text. so the first question is, is it safe to do so?  that being said though, you need to make sure you mac it. depending on how you do message authentication codes, someone tampering with the iv could tamper with the resulting plaintext on decryption. encryption alone does not provide integrity of messages. "
  },
  {
    "sentId": 55,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 55,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "does named query feature of hibernate helps to prevent sql injection attack? i am defining named queries in hbm.xml file not as annotation.<br/> "
  },
  {
    "sentId": 63,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "a cookie is hijacked by a malicious person",
        "em2Text": "logging out makes the hijacked cookie useless",
        "label": "None"
      },
      {
        "em1Text": "logging out makes the hijacked cookie useless",
        "em2Text": "a cookie is hijacked by a malicious person",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 167,
        "text": "a cookie is hijacked by a malicious person",
        "label": "ATTACK"
      },
      {
        "start": 211,
        "text": "logging out makes the hijacked cookie useless",
        "label": "ATTACK"
      }
    ],
    "sentText": "no. it's not supposed to be used to authenticate. it's used by the framework to help against [code] cookie hijacking. the value is refreshed upon login and logout. if a cookie is hijacked by a malicious person, logging out makes the hijacked cookie useless since it doesn't match anymore. "
  },
  {
    "sentId": 89,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "gained access to the webserver",
        "em2Text": "append this javascript to my php files",
        "label": "None"
      },
      {
        "em1Text": "append this javascript to my php files",
        "em2Text": "gained access to the webserver",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 545,
        "text": "gained access to the webserver",
        "label": "ATTACK"
      },
      {
        "start": 579,
        "text": "append this javascript to my php files",
        "label": "ATTACK"
      }
    ],
    "sentText": "it is a calendar application, as mentioned above, and it is used only by my client's small company. login is required to do anything, and only 5 or so people have accounts. i can guarantee none of them would try any shenanigans. i obviously can't guarantee someone got a hold of their information and did try shenanigans, though.sadly enough, i did make this website almost 4 years ago, so i am not exactly 100% confident i protected against everything kids are trying nowadays, but i still cannot understand how an attacker could have possibly gained access to the webserver to append this javascript to my php files. "
  },
  {
    "sentId": 36,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss attacks",
        "em2Text": "sql injection",
        "label": "None"
      },
      {
        "em1Text": "sql injection",
        "em2Text": "xss attacks",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 67,
        "text": "xss attacks",
        "label": "ATTACK"
      },
      {
        "start": 80,
        "text": "sql injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "when you develop a website, there is several points you must know: xss attacks, sql injection, etc.it can be very very difficult (and take a long time to code) to secure all potential attacks. do not secure xss, sql injection... this can be really done when you trust your user: back end for a private enterprise. but do you secure this type of application?secure attacks only when user try to access non owned datas: this is for me the best approach.secure all, all, all: you secure all datas (owner or not): the user can't break its own datas and other user datas: this is very long to do and is it very useful?secure common attacks but don't secure very hard attacks (because it's too long to code comparing to the chance of being hacked). edit: i see a lot of replies talking about xss and sql injection, but this is not the only things to take care about. sql injections have really nothing to do with sql, it's just string manipulation, so if you don't feel comfortable with that, just use prepared statements with bound parameters and forget about the problemcross site exploit are easily negated by escaping (with htmlentities or so) every untrusted data before sending it out as output -- of course this should be coupled with extensive data filtering, but it's a good startcredentials theft: never store data which could provide a permanent access to protected areas -- instead save a hashed version of the username in the cookies and set a time limit to the sessions: this way an attacker who might happen to steal this data will have a limited access instead of permanentnever suppose that just because a user is logged in then he can be trusted -- apply security rules to everybodytreat everything you get from outside as potentially dangerous: even a trusted site you get data from might be compromised, and you don't want to fall down too -- even your own database could be compromised (especially if you're on a shared environment) so don't trust its data either "
  },
  {
    "sentId": 40,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "create links to this page",
        "em2Text": "put this link in an image's [code] attribute",
        "label": "OR"
      },
      {
        "em1Text": "create links to this page",
        "em2Text": "force users to get logged out",
        "label": "None"
      },
      {
        "em1Text": "put this link in an image's [code] attribute",
        "em2Text": "create links to this page",
        "label": "None"
      },
      {
        "em1Text": "put this link in an image's [code] attribute",
        "em2Text": "force users to get logged out",
        "label": "None"
      },
      {
        "em1Text": "force users to get logged out",
        "em2Text": "create links to this page",
        "label": "PARENT"
      },
      {
        "em1Text": "force users to get logged out",
        "em2Text": "put this link in an image's [code] attribute",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 121,
        "text": "create links to this page",
        "label": "ATTACK"
      },
      {
        "start": 155,
        "text": "put this link in an image's [code] attribute",
        "label": "ATTACK"
      },
      {
        "start": 211,
        "text": "force users to get logged out",
        "label": "ATTACK"
      }
    ],
    "sentText": "this will log the current user out of his/her session. since this is a simple get request, a malicious user could either create links to this page or even put this link in an image's [code] attribute that would force users to get logged out. i would still like to maintain the simplicity of the logout link without having to go too far, but at the same time i would like to be able to prevent the above scenario from occurring.  "
  },
  {
    "sentId": 1,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "password to be send plaintext over the wire",
        "em2Text": "someone has javascript turned off",
        "label": "PARENT"
      },
      {
        "em1Text": "someone has javascript turned off",
        "em2Text": "password to be send plaintext over the wire",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 270,
        "text": "password to be send plaintext over the wire",
        "label": "ATTACK"
      },
      {
        "start": 317,
        "text": "someone has javascript turned off",
        "label": "ATTACK"
      }
    ],
    "sentText": "i choose not to just rely on javascript, as the client-side is never a secure place. i have gotten into the habit of writing both the client and server-side code for such things. however, for a web application that i am writing that has optional ajax, i do not want the password to be send plaintext over the wire if someone has javascript turned off. "
  },
  {
    "sentId": 45,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 24,
        "text": "csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "secondly, i've disabled csrf protection with the line [code]. i have my doubts about whether this is a good idea - i see a lot of [link] or [link] advice about whether json apis are vulnerable to csrf attacks - but adding that line was the only way i could get the damn thing to work. is this login system secure? or is there something i've overlooked or misunderstood, e.g. when it comes to csrf attacks?is my understanding of how to authenticate requests once users are signed in correct? (see \"thirdly...\" above.)is there any way this code can be cleaned up or made nicer? particularly the ugly design of having one controller inherit from [code] and the others from [code]. you don't want to disable csrf, i have read that people think it doesn't apply to json apis for some reason, but this is a misunderstanding. to keep it enabled, you want to make a few changes: final piece of the puzzle is to understand that when logging in to devise, two subsequent sessions/csrf tokens are being used. a login flow would look like this: "
  },
  {
    "sentId": 23,
    "articleId": "6",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "a buffer overflow attack on a program",
        "em2Text": "keep supplying incrementally longer payloads",
        "label": "None"
      },
      {
        "em1Text": "a buffer overflow attack on a program",
        "em2Text": "dynamically generate larger payloads of junks",
        "label": "None"
      },
      {
        "em1Text": "keep supplying incrementally longer payloads",
        "em2Text": "a buffer overflow attack on a program",
        "label": "PARENT"
      },
      {
        "em1Text": "keep supplying incrementally longer payloads",
        "em2Text": "dynamically generate larger payloads of junks",
        "label": "None"
      },
      {
        "em1Text": "dynamically generate larger payloads of junks",
        "em2Text": "a buffer overflow attack on a program",
        "label": "None"
      },
      {
        "em1Text": "dynamically generate larger payloads of junks",
        "em2Text": "keep supplying incrementally longer payloads",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 23,
        "text": "a buffer overflow attack on a program",
        "label": "ATTACK"
      },
      {
        "start": 216,
        "text": "keep supplying incrementally longer payloads",
        "label": "ATTACK"
      },
      {
        "start": 303,
        "text": "dynamically generate larger payloads of junks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am trying to perform a buffer overflow attack on a program for a class assignment. both the attack program as well as the vulnerable programme is written by me. however, i would like to use the attack programme to keep supplying incrementally longer payloads till the programme crashes. so, i need to dynamically generate larger payloads of junks. i am using [code] to repeatedly call and test for an abnormal exit. "
  },
  {
    "sentId": 4,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 64,
        "text": "send a file with an exploit/code",
        "label": "ATTACK"
      }
    ],
    "sentText": "i need to validate all these files as imagespeople can probably send a file with an exploit/code that can likelybe a problem. but in my case i am mostly going to do a file open andsave and let the browser show the image     "
  },
  {
    "sentId": 21,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss and javascript injection attacks",
        "em2Text": "inject bad web code",
        "label": "None"
      },
      {
        "em1Text": "xss and javascript injection attacks",
        "em2Text": "arbitrary strings passed through it",
        "label": "None"
      },
      {
        "em1Text": "inject bad web code",
        "em2Text": "xss and javascript injection attacks",
        "label": "None"
      },
      {
        "em1Text": "inject bad web code",
        "em2Text": "arbitrary strings passed through it",
        "label": "PARENT"
      },
      {
        "em1Text": "arbitrary strings passed through it",
        "em2Text": "xss and javascript injection attacks",
        "label": "None"
      },
      {
        "em1Text": "arbitrary strings passed through it",
        "em2Text": "inject bad web code",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 119,
        "text": "xss and javascript injection attacks",
        "label": "ATTACK"
      },
      {
        "start": 280,
        "text": "inject bad web code",
        "label": "ATTACK"
      },
      {
        "start": 308,
        "text": "arbitrary strings passed through it",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have a page where i want to accept an email address in the get parameters. if i use [code], am i still vulnerable to xss and javascript injection attacks, and the like? i'm not asking if it's a good, or good enough, validator of email addresses. i want to know if one can still inject bad web code through arbitrary strings passed through it -- do i need to do additional filtering to prevent that? "
  },
  {
    "sentId": 115,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 22,
        "text": "cross-site  scripting vulnerability",
        "label": "ATTACK"
      }
    ],
    "sentText": "  the issue here is a cross-site  scripting vulnerability that is  commonly associated with e-commerce  applications. one of the tests  appended a harmless script in a get  request on the end of the your site  url. it flagged as a cross-site  scripting vulnerability because this  same script that was entered by the  user (our scanner) was returned by the  server unsanitized in the header. in  this case, the script was returned in  the header so our scanner flagged the  vulnerability.    here is the test i ran from my  terminal to duplicate this:    get  /?oscsid=%22%3e%3ciframe%20src=foo%3e%3c/iframe%3e  http/1.0      host:(removed) "
  },
  {
    "sentId": 34,
    "articleId": "3",
    "threatType": "D",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 110,
        "text": "ddos attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "could you please list some strategies or even approaches you have already applied to prevent/protect/minimize ddos attacks upon restful web services? "
  },
  {
    "sentId": 14,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 50,
        "text": "individual inject js alert",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have had issues with xss. specifically i had an individual inject js alert showing that the my input had vulnerabilities. i have done research on xss and found examples but for some reason i can't get them to work. "
  },
  {
    "sentId": 69,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "logs into your site",
        "em2Text": "then browses over to another website with a malicious flash app",
        "label": "AND"
      },
      {
        "em1Text": "logs into your site",
        "em2Text": "flash app can connect back to your site",
        "label": "None"
      },
      {
        "em1Text": "logs into your site",
        "em2Text": "cookies are shared to the flash app",
        "label": "None"
      },
      {
        "em1Text": "logs into your site",
        "em2Text": "the flash app to hijack the user's session",
        "label": "None"
      },
      {
        "em1Text": "then browses over to another website with a malicious flash app",
        "em2Text": "logs into your site",
        "label": "None"
      },
      {
        "em1Text": "then browses over to another website with a malicious flash app",
        "em2Text": "flash app can connect back to your site",
        "label": "None"
      },
      {
        "em1Text": "then browses over to another website with a malicious flash app",
        "em2Text": "cookies are shared to the flash app",
        "label": "None"
      },
      {
        "em1Text": "then browses over to another website with a malicious flash app",
        "em2Text": "the flash app to hijack the user's session",
        "label": "None"
      },
      {
        "em1Text": "flash app can connect back to your site",
        "em2Text": "logs into your site",
        "label": "None"
      },
      {
        "em1Text": "flash app can connect back to your site",
        "em2Text": "then browses over to another website with a malicious flash app",
        "label": "PARENT"
      },
      {
        "em1Text": "flash app can connect back to your site",
        "em2Text": "cookies are shared to the flash app",
        "label": "None"
      },
      {
        "em1Text": "flash app can connect back to your site",
        "em2Text": "the flash app to hijack the user's session",
        "label": "None"
      },
      {
        "em1Text": "cookies are shared to the flash app",
        "em2Text": "logs into your site",
        "label": "None"
      },
      {
        "em1Text": "cookies are shared to the flash app",
        "em2Text": "then browses over to another website with a malicious flash app",
        "label": "None"
      },
      {
        "em1Text": "cookies are shared to the flash app",
        "em2Text": "flash app can connect back to your site",
        "label": "PARENT"
      },
      {
        "em1Text": "cookies are shared to the flash app",
        "em2Text": "the flash app to hijack the user's session",
        "label": "None"
      },
      {
        "em1Text": "the flash app to hijack the user's session",
        "em2Text": "logs into your site",
        "label": "None"
      },
      {
        "em1Text": "the flash app to hijack the user's session",
        "em2Text": "then browses over to another website with a malicious flash app",
        "label": "None"
      },
      {
        "em1Text": "the flash app to hijack the user's session",
        "em2Text": "flash app can connect back to your site",
        "label": "None"
      },
      {
        "em1Text": "the flash app to hijack the user's session",
        "em2Text": "cookies are shared to the flash app",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 131,
        "text": "logs into your site",
        "label": "ATTACK"
      },
      {
        "start": 156,
        "text": "then browses over to another website with a malicious flash app",
        "label": "ATTACK"
      },
      {
        "start": 226,
        "text": "flash app can connect back to your site",
        "label": "ATTACK"
      },
      {
        "start": 293,
        "text": "cookies are shared to the flash app",
        "label": "ATTACK"
      },
      {
        "start": 343,
        "text": "the flash app to hijack the user's session",
        "label": "ATTACK"
      }
    ],
    "sentText": "by adding the crossdomain.xml, the main security concern is that flash applications can now connect to your server.  so if someone logs into your site, and then browses over to another website with a malicious flash app, that flash app can connect back to your site.  since it's in a browser, cookies are shared to the flash app.  this allows the flash app to hijack the user's session to do whatever it is your website does without the user knowing about it. "
  },
  {
    "sentId": 22,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 47,
        "text": "sql injection attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "it can also give you a fighting chance against sql injection attacks. "
  },
  {
    "sentId": 55,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "uses an unsafe [code] extension",
        "em2Text": "break [code] ",
        "label": "None"
      },
      {
        "em1Text": "uses an unsafe [code] extension",
        "em2Text": "inserting different elements with different [code] instances",
        "label": "None"
      },
      {
        "em1Text": "break [code] ",
        "em2Text": "uses an unsafe [code] extension",
        "label": "None"
      },
      {
        "em1Text": "break [code] ",
        "em2Text": "inserting different elements with different [code] instances",
        "label": "PARENT"
      },
      {
        "em1Text": "inserting different elements with different [code] instances",
        "em2Text": "uses an unsafe [code] extension",
        "label": "PARENT"
      },
      {
        "em1Text": "inserting different elements with different [code] instances",
        "em2Text": "break [code] ",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 15,
        "text": "uses an unsafe [code] extension",
        "label": "ATTACK"
      },
      {
        "start": 50,
        "text": "break [code] ",
        "label": "ATTACK"
      },
      {
        "start": 66,
        "text": "inserting different elements with different [code] instances",
        "label": "ATTACK"
      }
    ],
    "sentText": "the code below uses an unsafe [code] extension to break [code] by inserting different elements with different [code] instances: "
  },
  {
    "sentId": 6,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 53,
        "text": "injection",
        "label": "ATTACK"
      }
    ],
    "sentText": "there where no sql calls, so i wasn't afraid for sql injection. but, apparently, sql isn't the only kind of injection. this website has an explanation and a few examples of avoiding code injection: [link] how would you protect this code from code injection? "
  },
  {
    "sentId": 155,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 193,
        "text": "keep attackers from defeating ios keychain or such data protection",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am developing an ios app that it has to store username and password and other sensitive data. i am considering using nsuserdefaults or keychain storage. are there other more secure method to keep attackers from defeating ios keychain or such data protection?  "
  },
  {
    "sentId": 137,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 53,
        "text": "xss attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i read a comment about malformed tags being used for xss attacks. how am i supposed to sanitize against these. if i use a library like htmlpurifier, does it take of this as part of its work? or is this an independent thing? i don't hear people talking about it much. "
  },
  {
    "sentId": 68,
    "articleId": "2",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 86,
        "text": "uploads something harmful",
        "label": "ATTACK"
      }
    ],
    "sentText": "for instance if my website allows the users to upload a profile picture, and one user uploads something harmful instead, what could happen? what kind of security should i set up to prevent attacks like this? "
  },
  {
    "sentId": 81,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "a hacker can log in with the saved password",
        "em2Text": "a hacker has access to the user's computer",
        "label": "None"
      },
      {
        "em1Text": "a hacker can log in with the saved password",
        "em2Text": "he can catch the password",
        "label": "None"
      },
      {
        "em1Text": "a hacker can log in with the saved password",
        "em2Text": "brute force",
        "label": "None"
      },
      {
        "em1Text": "a hacker can log in with the saved password",
        "em2Text": "rainbow tables",
        "label": "None"
      },
      {
        "em1Text": "a hacker can log in with the saved password",
        "em2Text": "discover the original password",
        "label": "None"
      },
      {
        "em1Text": "a hacker has access to the user's computer",
        "em2Text": "a hacker can log in with the saved password",
        "label": "None"
      },
      {
        "em1Text": "a hacker has access to the user's computer",
        "em2Text": "he can catch the password",
        "label": "None"
      },
      {
        "em1Text": "a hacker has access to the user's computer",
        "em2Text": "brute force",
        "label": "None"
      },
      {
        "em1Text": "a hacker has access to the user's computer",
        "em2Text": "rainbow tables",
        "label": "None"
      },
      {
        "em1Text": "a hacker has access to the user's computer",
        "em2Text": "discover the original password",
        "label": "None"
      },
      {
        "em1Text": "he can catch the password",
        "em2Text": "a hacker can log in with the saved password",
        "label": "None"
      },
      {
        "em1Text": "he can catch the password",
        "em2Text": "a hacker has access to the user's computer",
        "label": "PARENT"
      },
      {
        "em1Text": "he can catch the password",
        "em2Text": "brute force",
        "label": "None"
      },
      {
        "em1Text": "he can catch the password",
        "em2Text": "rainbow tables",
        "label": "None"
      },
      {
        "em1Text": "he can catch the password",
        "em2Text": "discover the original password",
        "label": "None"
      },
      {
        "em1Text": "brute force",
        "em2Text": "a hacker can log in with the saved password",
        "label": "None"
      },
      {
        "em1Text": "brute force",
        "em2Text": "a hacker has access to the user's computer",
        "label": "None"
      },
      {
        "em1Text": "brute force",
        "em2Text": "he can catch the password",
        "label": "None"
      },
      {
        "em1Text": "brute force",
        "em2Text": "rainbow tables",
        "label": "OR"
      },
      {
        "em1Text": "brute force",
        "em2Text": "discover the original password",
        "label": "None"
      },
      {
        "em1Text": "rainbow tables",
        "em2Text": "a hacker can log in with the saved password",
        "label": "None"
      },
      {
        "em1Text": "rainbow tables",
        "em2Text": "a hacker has access to the user's computer",
        "label": "None"
      },
      {
        "em1Text": "rainbow tables",
        "em2Text": "he can catch the password",
        "label": "None"
      },
      {
        "em1Text": "rainbow tables",
        "em2Text": "brute force",
        "label": "None"
      },
      {
        "em1Text": "rainbow tables",
        "em2Text": "discover the original password",
        "label": "None"
      },
      {
        "em1Text": "discover the original password",
        "em2Text": "a hacker can log in with the saved password",
        "label": "None"
      },
      {
        "em1Text": "discover the original password",
        "em2Text": "a hacker has access to the user's computer",
        "label": "None"
      },
      {
        "em1Text": "discover the original password",
        "em2Text": "he can catch the password",
        "label": "None"
      },
      {
        "em1Text": "discover the original password",
        "em2Text": "brute force",
        "label": "PARENT"
      },
      {
        "em1Text": "discover the original password",
        "em2Text": "rainbow tables",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 126,
        "text": "a hacker can log in with the saved password",
        "label": "ATTACK"
      },
      {
        "start": 174,
        "text": "a hacker has access to the user's computer",
        "label": "ATTACK"
      },
      {
        "start": 218,
        "text": "he can catch the password",
        "label": "ATTACK"
      },
      {
        "start": 726,
        "text": "brute force",
        "label": "ATTACK"
      },
      {
        "start": 741,
        "text": "rainbow tables",
        "label": "ATTACK"
      },
      {
        "start": 759,
        "text": "discover the original password",
        "label": "ATTACK"
      }
    ],
    "sentText": "there are many discussions about security risk for saving hash password in cookies, as upon accessing to the user's computer, a hacker can log in with the saved password. if a hacker has access to the user's computer, he can catch the password, as browsers also save passwords locally (encrypted of course). what is the difference between password set in cookies with that saved by the browser? most important is the risk of exposing the password. this would not only put your site at risk, but potentially other sites as well. most users re-use their password for everything, and the password would probably give an intruder access to both the users email account and netbank. someone with access to the hashed value may use brute force or rainbow tables to discover the original password (rainbow tables are long lists of pre-calculated hashes). rainbow tables are easily available for passwords up to more than 8 characters, and even longer. you may avoid this by salting the password so that it is i.e. more than 20 characters before you create the hash (remember to store the salt in the cookie as well). a properly salted password hash calculated with a safe hashing algorithm should be quite safe. "
  },
  {
    "sentId": 40,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 42,
        "text": "execution of any scripts (php, perl, cgi scripts, whatever i may install in the future) in the upload folder",
        "label": "ATTACK"
      }
    ],
    "sentText": "what i'd like to do is to simply disallow execution of any scripts (php, perl, cgi scripts, whatever i may install in the future) in the upload folder. [link] suggests adding the following line in a [code] file in that folder: "
  },
  {
    "sentId": 111,
    "articleId": "4",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "man-in-the-middle attacks",
        "em2Text": "replay attacks",
        "label": "AND"
      },
      {
        "em1Text": "replay attacks",
        "em2Text": "man-in-the-middle attacks",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 51,
        "text": "man-in-the-middle attacks",
        "label": "ATTACK"
      },
      {
        "start": 198,
        "text": "replay attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "how does challenge-response authentication prevent man-in-the-middle attacks? i read the wiki article but still i cannot understand. where challenge/response protocols really shine is in preventing replay attacks: if alice just sends bob a message along the lines of \"please debit my account $5 and credit your account $5\", mallory could record the message and replay the message to deplete alice's account. "
  },
  {
    "sentId": 14,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "run fortify scan",
        "em2Text": "i'm logging the exceptions using [code]",
        "label": "AND"
      },
      {
        "em1Text": "run fortify scan",
        "em2Text": "get access to this info and get system info",
        "label": "None"
      },
      {
        "em1Text": "i'm logging the exceptions using [code]",
        "em2Text": "run fortify scan",
        "label": "None"
      },
      {
        "em1Text": "i'm logging the exceptions using [code]",
        "em2Text": "get access to this info and get system info",
        "label": "None"
      },
      {
        "em1Text": "get access to this info and get system info",
        "em2Text": "run fortify scan",
        "label": "None"
      },
      {
        "em1Text": "get access to this info and get system info",
        "em2Text": "i'm logging the exceptions using [code]",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 7,
        "text": "run fortify scan",
        "label": "ATTACK"
      },
      {
        "start": 52,
        "text": "i'm logging the exceptions using [code]",
        "label": "ATTACK"
      },
      {
        "start": 151,
        "text": "get access to this info and get system info",
        "label": "ATTACK"
      }
    ],
    "sentText": "when i run fortify scan on my project i do see that i'm logging the exceptions using [code] and it says this is not the right way because attckers may get access to this info and get system info from this and plan an attack. "
  },
  {
    "sentId": 8,
    "articleId": "6",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "a database is compromised",
        "em2Text": "prevents the use of generic rainbow tables to crack passwords",
        "label": "None"
      },
      {
        "em1Text": "prevents the use of generic rainbow tables to crack passwords",
        "em2Text": "a database is compromised",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 9,
        "text": "a database is compromised",
        "label": "ATTACK"
      },
      {
        "start": 51,
        "text": "prevents the use of generic rainbow tables to crack passwords",
        "label": "ATTACK"
      }
    ],
    "sentText": "assuming a database is compromised a per user salt prevents the use of generic rainbow tables to crack passwords.  a separate rainbow table would have to be generated for each and every user who had a unique salt in order to obtain their password.  this would be a time consuming process which is what makes salts effective.  this does not help a tremendous amount against dictionary or brute force attacks. "
  },
  {
    "sentId": 5,
    "articleId": "3",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 102,
        "text": "inserted javascript",
        "label": "ATTACK"
      }
    ],
    "sentText": "and yet, even with encoded special chars and quotes, the href may not be safe, due to the potentially inserted javascript, example of a bad link: "
  },
  {
    "sentId": 74,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 12,
        "text": "a file can be fooled as an image and run malicious code",
        "label": "ATTACK"
      }
    ],
    "sentText": "i know that a file can be fooled as an image and run malicious code so i searched about methods to avoid this. this is what i could find to check before store the image on the server: "
  },
  {
    "sentId": 51,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 61,
        "text": "csrf attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "but my question is , i dont understand how does this prevent csrf attacks in json format? attacker can always send a json request to our endpoint from their site. anyone has insights into this? i couldn't find any clear answer to this. "
  },
  {
    "sentId": 64,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 48,
        "text": "directory transversal (aka path transversal) attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have a java webapp which is vulnerable to the directory transversal (aka path transversal) attack via url encoding. after being authenticated: "
  },
  {
    "sentId": 80,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "multiple php files were modified",
        "em2Text": "this modification injected javascript at the top of the page",
        "label": "None"
      },
      {
        "em1Text": "this modification injected javascript at the top of the page",
        "em2Text": "multiple php files were modified",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 48,
        "text": "multiple php files were modified",
        "label": "ATTACK"
      },
      {
        "start": 82,
        "text": "this modification injected javascript at the top of the page",
        "label": "ATTACK"
      }
    ],
    "sentText": "one of our websites was attacked recently where multiple php files were modified. this modification injected javascript at the top of the page but after base64 decoding all of it i came across the following and i have no clue how to proceed.  "
  },
  {
    "sentId": 104,
    "articleId": "4",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 95,
        "text": "a security vulnerability",
        "label": "ATTACK"
      }
    ],
    "sentText": "the problem is i have to comment out the setting [code] when creating the [code]. this exposes a security vulnerability.  "
  },
  {
    "sentId": 14,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "man-in-the-middle attacks",
        "em2Text": "passively listening in on your encrypted traffic",
        "label": "PARENT"
      },
      {
        "em1Text": "man-in-the-middle attacks",
        "em2Text": "gain access to your shared symmetric key",
        "label": "None"
      },
      {
        "em1Text": "passively listening in on your encrypted traffic",
        "em2Text": "man-in-the-middle attacks",
        "label": "None"
      },
      {
        "em1Text": "passively listening in on your encrypted traffic",
        "em2Text": "gain access to your shared symmetric key",
        "label": "PARENT"
      },
      {
        "em1Text": "gain access to your shared symmetric key",
        "em2Text": "man-in-the-middle attacks",
        "label": "None"
      },
      {
        "em1Text": "gain access to your shared symmetric key",
        "em2Text": "passively listening in on your encrypted traffic",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 68,
        "text": "man-in-the-middle attacks",
        "label": "ATTACK"
      },
      {
        "start": 401,
        "text": "passively listening in on your encrypted traffic",
        "label": "ATTACK"
      },
      {
        "start": 477,
        "text": "gain access to your shared symmetric key",
        "label": "ATTACK"
      }
    ],
    "sentText": "how exactly is this done? what about the process makes it immune to man-in-the-middle attacks?what prevents some random person from setting up their own verification service to use in man-in-the-middle attacks, so everything \"looks\" secure? note that the certificate authority (ca) is essential to preventing man-in-the-middle attacks.  however, even an unsigned certificate will prevent someone from passively listening in on your encrypted traffic, since they have no way to gain access to your shared symmetric key. "
  },
  {
    "sentId": 128,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 91,
        "text": "a man in the middle attack",
        "label": "ATTACK"
      }
    ],
    "sentText": "the following [link] discusses how to destroy a flask token, however this does not prevent a man in the middle attack.  is there anyway to invalidate the token so it is no longer active before the time it expires? "
  },
  {
    "sentId": 73,
    "articleId": "1",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "[code] is somehow modified",
        "em2Text": "mess up your html and inject a script",
        "label": "None"
      },
      {
        "em1Text": "[code] is somehow modified",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "mess up your html and inject a script",
        "em2Text": "[code] is somehow modified",
        "label": "PARENT"
      },
      {
        "em1Text": "mess up your html and inject a script",
        "em2Text": "xss",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "[code] is somehow modified",
        "label": "None"
      },
      {
        "em1Text": "xss",
        "em2Text": "mess up your html and inject a script",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 439,
        "text": "[code] is somehow modified",
        "label": "ATTACK"
      },
      {
        "start": 513,
        "text": "mess up your html and inject a script",
        "label": "ATTACK"
      },
      {
        "start": 181,
        "text": "xss",
        "label": "ATTACK"
      }
    ],
    "sentText": "the company who hosts our site reviews our code before deploying - they've recently told us this:html strings should never be directly manipulated, as that opens us up to potential xss holes. instead, always use a dom api to create elements...that can be jquery or the direct dom apis.for example, instead of[code]is this really true? can anyone give us an example of an xss attack that could exploit an html string like the first one? if [code] is somehow modified, it might contain something like this: that'll mess up your html and inject a script: if you use dom manipulation to set the [code] attribute, the script (or whatever other xss you use) won't be executed, as it'll be properly escaped by the dom api. "
  },
  {
    "sentId": 82,
    "articleId": "6",
    "threatType": "D",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 104,
        "text": "ddos attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i am using cloudflare on my website and i want to keep my server's ip (the origin ip) private, to avoid ddos attacks being sent directly to my server's ip. my server uses apache, php, mysql. "
  },
  {
    "sentId": 78,
    "articleId": "6",
    "threatType": "I",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 120,
        "text": "beast",
        "label": "ATTACK"
      }
    ],
    "sentText": "is heroku currently preferring cbc cipher connections? if so, does this mean customer dynos are currently vulnerable to beast? since server-preferred order puts [code] at the bottom of the list, i'm concluding that heroku is currently vulnerable to beast.   beast attack  vulnerable   insecure ([link]) the best way to defend against the attack demonstrated by beast is adopting (both in clients &amp; servers) tls 1.1. in its absence, the next best thing would be tls_rsa_with_rc4_128_sha, in my opinion, even if it's considered \"less secure\" than aes. wikipedia has a decent writeup on the known attacks on rc4. most of them are biases of the output. to give you an idea of the severity of the attacks see the following quotes from the wikipedia page: "
  },
  {
    "sentId": 73,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 76,
        "text": "execution of malicious code in the browser",
        "label": "ATTACK"
      }
    ],
    "sentText": "i want to restrict the execution of javascript on my website to prevent the execution of malicious code in the browser. presuming, my html website is accessible via the uri [code], i want to make sure that only the script in [code] is executed by the browser. the browser should not: "
  },
  {
    "sentId": 13,
    "articleId": "3",
    "threatType": "E",
    "relationMentions": [
      {
        "em1Text": "an in-memory password can be leaked",
        "em2Text": "gain access to the system under the same user account as your code",
        "label": "PARENT"
      },
      {
        "em1Text": "an in-memory password can be leaked",
        "em2Text": "get access as the same user or as root",
        "label": "None"
      },
      {
        "em1Text": "an in-memory password can be leaked",
        "em2Text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "label": "None"
      },
      {
        "em1Text": "gain access to the system under the same user account as your code",
        "em2Text": "an in-memory password can be leaked",
        "label": "None"
      },
      {
        "em1Text": "gain access to the system under the same user account as your code",
        "em2Text": "get access as the same user or as root",
        "label": "None"
      },
      {
        "em1Text": "gain access to the system under the same user account as your code",
        "em2Text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "label": "None"
      },
      {
        "em1Text": "get access as the same user or as root",
        "em2Text": "an in-memory password can be leaked",
        "label": "None"
      },
      {
        "em1Text": "get access as the same user or as root",
        "em2Text": "gain access to the system under the same user account as your code",
        "label": "None"
      },
      {
        "em1Text": "get access as the same user or as root",
        "em2Text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "label": "None"
      },
      {
        "em1Text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "em2Text": "an in-memory password can be leaked",
        "label": "None"
      },
      {
        "em1Text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "em2Text": "gain access to the system under the same user account as your code",
        "label": "None"
      },
      {
        "em1Text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "em2Text": "get access as the same user or as root",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 0,
        "text": "an in-memory password can be leaked",
        "label": "ATTACK"
      },
      {
        "start": 55,
        "text": "gain access to the system under the same user account as your code",
        "label": "ATTACK"
      },
      {
        "start": 228,
        "text": "get access as the same user or as root",
        "label": "ATTACK"
      },
      {
        "start": 324,
        "text": "tamper with your code to send all passwords (when they are entered) to them remotely",
        "label": "ATTACK"
      }
    ],
    "sentText": "an in-memory password can be leaked if an attacker can gain access to the system under the same user account as your code.an on-device attacker, different user, root however, there's an important gotcha here. if an attacker can get access as the same user or as root, you've got far bigger problems. for example, they could tamper with your code to send all passwords (when they are entered) to them remotely. "
  },
  {
    "sentId": 81,
    "articleId": "4",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 40,
        "text": "man-in-the-middle attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "how frequent (and/or sophisticated) are man-in-the-middle attacks? "
  },
  {
    "sentId": 39,
    "articleId": "2",
    "threatType": "D",
    "relationMentions": [
      {
        "em1Text": "dos ",
        "em2Text": "maxed out post parameters",
        "label": "PARENT"
      },
      {
        "em1Text": "maxed out post parameters",
        "em2Text": "dos ",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 87,
        "text": "dos ",
        "label": "ATTACK"
      },
      {
        "start": 95,
        "text": "maxed out post parameters",
        "label": "ATTACK"
      }
    ],
    "sentText": "is password_verify() (and other functions of the same function set) vulnerable against dos via maxed out post parameters ? please also consider site-wide config situations of post upload sizes much larger than 4mb. "
  },
  {
    "sentId": 80,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "inject javascript into the page",
        "em2Text": "xsrf",
        "label": "None"
      },
      {
        "em1Text": "xsrf",
        "em2Text": "inject javascript into the page",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 431,
        "text": "inject javascript into the page",
        "label": "ATTACK"
      },
      {
        "start": 633,
        "text": "xsrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "why was it decided that using xmlhttprequest for doing xml calls should not do calls across the domain boundary?  you can retrieve javascript, images, css, iframes, and just about any other content i can think of from other domains. why are the ajax http requests not allowed to cross the domain boundaries?  it seems like an odd limitation to put, considering the only way i could see it being abused, would be if someone were to inject javascript into the page.  however, in this case, you could simply add an img, script, or iframe element to the document to get it to request the third party url and send it to the server.   <h2>xsrf (cross site request forgery, also known as csrf, xsrf)</h2> your can do xsrf attacks without using this at all.  as a general rule, xmlhttprequest isn't used at all, simply because it's so hard to make an xmlhttprequest in a way that's compatible with all major browsers.  it's much easier to just add an img tag to the url if you want them to load your url. i'm marking the answer from bobince as correct because he pointed out the critical problem.  because xmlhttprequest allows you to post, with credentials (cookies) to the destination site, and read the data sent back from the site, along with sending the persons credentials, you could orchestrate some javascript that would submit a series of forms, including confirmation forms, complete with any random keys generated that were put in place to try to prevent a xsrf.  in this way, you could browse through the target site, like a bank, and the bank's webserver would be unable to tell that it wasn't just a regular user submitting all these forms. that's not an xss attack. that's a cross-site request forgery attack (xsrf). there are known ways to solve xsrf attacks, such as including one-time or cryptographic tokens to verify that the submission came deliberately from the user and was not launched from attacker code. "
  },
  {
    "sentId": 65,
    "articleId": "2",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "gets ahold of the data in the datastore, as well as our hash salt",
        "em2Text": "brute force the sensitive data",
        "label": "None"
      },
      {
        "em1Text": "brute force the sensitive data",
        "em2Text": "gets ahold of the data in the datastore, as well as our hash salt",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 15,
        "text": "gets ahold of the data in the datastore, as well as our hash salt",
        "label": "ATTACK"
      },
      {
        "start": 105,
        "text": "brute force the sensitive data",
        "label": "ATTACK"
      }
    ],
    "sentText": "if an attacker gets ahold of the data in the datastore, as well as our hash salt, i'm worried they could brute force the sensitive data.  "
  },
  {
    "sentId": 44,
    "articleId": "4",
    "threatType": "E",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 221,
        "text": "renaming the superuser.apk to superuser0.apk.",
        "label": "ATTACK"
      }
    ],
    "sentText": "the major techniques used by developers in root detection are checking for the superuser.apk file,check for chainfire,busybox,executing su command,etc. but an attacker can simply bypass these checks by several means like renaming the superuser.apk to superuser0.apk.  "
  },
  {
    "sentId": 104,
    "articleId": "1",
    "threatType": "S",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 79,
        "text": "csrf",
        "label": "ATTACK"
      }
    ],
    "sentText": "if i understood it correctly, the goal of the same-origin policy is to prevent csrf attacks and the goal of cors is to enable resource sharing if (and only if) the server agrees to share its data with applications hosted on other sites (origins). "
  },
  {
    "sentId": 49,
    "articleId": "4",
    "threatType": "D",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 27,
        "text": "format string vulnerability in c++",
        "label": "ATTACK"
      }
    ],
    "sentText": "i have found out about the format string vulnerability in c++, but c++ is an old language. i want to know whether the format string vulnerability still exists in modern languages, like c# and java. "
  },
  {
    "sentId": 67,
    "articleId": "6",
    "threatType": "S",
    "relationMentions": [
      {
        "em1Text": "steal the encrypted sid",
        "em2Text": "start making requests",
        "label": "AND"
      },
      {
        "em1Text": "steal the encrypted sid",
        "em2Text": "generate encrypted values",
        "label": "None"
      },
      {
        "em1Text": "steal the encrypted sid",
        "em2Text": "break the decryption routine",
        "label": "None"
      },
      {
        "em1Text": "steal the encrypted sid",
        "em2Text": "throw exceptions",
        "label": "None"
      },
      {
        "em1Text": "start making requests",
        "em2Text": "steal the encrypted sid",
        "label": "None"
      },
      {
        "em1Text": "start making requests",
        "em2Text": "generate encrypted values",
        "label": "None"
      },
      {
        "em1Text": "start making requests",
        "em2Text": "break the decryption routine",
        "label": "None"
      },
      {
        "em1Text": "start making requests",
        "em2Text": "throw exceptions",
        "label": "None"
      },
      {
        "em1Text": "generate encrypted values",
        "em2Text": "steal the encrypted sid",
        "label": "None"
      },
      {
        "em1Text": "generate encrypted values",
        "em2Text": "start making requests",
        "label": "None"
      },
      {
        "em1Text": "generate encrypted values",
        "em2Text": "break the decryption routine",
        "label": "None"
      },
      {
        "em1Text": "generate encrypted values",
        "em2Text": "throw exceptions",
        "label": "None"
      },
      {
        "em1Text": "break the decryption routine",
        "em2Text": "steal the encrypted sid",
        "label": "None"
      },
      {
        "em1Text": "break the decryption routine",
        "em2Text": "start making requests",
        "label": "None"
      },
      {
        "em1Text": "break the decryption routine",
        "em2Text": "generate encrypted values",
        "label": "PARENT"
      },
      {
        "em1Text": "break the decryption routine",
        "em2Text": "throw exceptions",
        "label": "AND"
      },
      {
        "em1Text": "throw exceptions",
        "em2Text": "steal the encrypted sid",
        "label": "None"
      },
      {
        "em1Text": "throw exceptions",
        "em2Text": "start making requests",
        "label": "None"
      },
      {
        "em1Text": "throw exceptions",
        "em2Text": "generate encrypted values",
        "label": "None"
      },
      {
        "em1Text": "throw exceptions",
        "em2Text": "break the decryption routine",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 13,
        "text": "steal the encrypted sid",
        "label": "ATTACK"
      },
      {
        "start": 41,
        "text": "start making requests",
        "label": "ATTACK"
      },
      {
        "start": 134,
        "text": "generate encrypted values",
        "label": "ATTACK"
      },
      {
        "start": 170,
        "text": "break the decryption routine",
        "label": "ATTACK"
      },
      {
        "start": 203,
        "text": "throw exceptions",
        "label": "ATTACK"
      }
    ],
    "sentText": "somebody can steal the encrypted sid and start making requests as if they were that user. decrypt it, being careful that a hacker can generate encrypted values that will break the decryption routine and throw exceptions which you must hide.verify the session id, timestamp, unique number and client information all match what you recorded when you create the session.  if anything is wrong you immediately expire the session.  expired sessions then coming back on subsequent requests are not even verified, they simpy generate a 403.  if you are using network information to secure the token, this will mean that the user will have problems using the service if they are on a roaming network. "
  },
  {
    "sentId": 13,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 30,
        "text": "javascript injection attacks",
        "label": "ATTACK"
      }
    ],
    "sentText": "i know that i need to prevent javascript injection attacks. how do i do this? "
  },
  {
    "sentId": 140,
    "articleId": "6",
    "threatType": "T",
    "relationMentions": [
      {
        "em1Text": "xss vulnerability",
        "em2Text": "full proof-of-concept attack for injecting arbitrary javascript",
        "label": "None"
      },
      {
        "em1Text": "xss vulnerability",
        "em2Text": "injecting arbitrary javascript",
        "label": "None"
      },
      {
        "em1Text": "full proof-of-concept attack for injecting arbitrary javascript",
        "em2Text": "xss vulnerability",
        "label": "None"
      },
      {
        "em1Text": "full proof-of-concept attack for injecting arbitrary javascript",
        "em2Text": "injecting arbitrary javascript",
        "label": "None"
      },
      {
        "em1Text": "injecting arbitrary javascript",
        "em2Text": "xss vulnerability",
        "label": "None"
      },
      {
        "em1Text": "injecting arbitrary javascript",
        "em2Text": "full proof-of-concept attack for injecting arbitrary javascript",
        "label": "PARENT"
      }
    ],
    "entityMentions": [
      {
        "start": 107,
        "text": "xss vulnerability",
        "label": "ATTACK"
      },
      {
        "start": 762,
        "text": "full proof-of-concept attack for injecting arbitrary javascript",
        "label": "ATTACK"
      },
      {
        "start": 795,
        "text": "injecting arbitrary javascript",
        "label": "ATTACK"
      }
    ],
    "sentText": "i've run a pen test tool (burp) against my node(express)/angular application and it identified a reflected xss vulnerability specifically when attempting a [code] request for static assets (noticeably vulnerabilities were not found for any of the requests being made when a user interacts with the application).    the name of an arbitrarily supplied url parameter is copied into a  javascript expression which is not encapsulated in any quotation  marks. the payload 41b68(a)184a9=1 was submitted in the name of an  arbitrarily supplied url parameter. this input was echoed unmodified  in the application's response.    this behavior demonstrates that it is possible to inject javascript  commands into the returned document. an attempt was made to identify a  full proof-of-concept attack for injecting arbitrary javascript but  this was not successful. you should manually examine the application's  behavior and attempt to identify any unusual input validation or other  obstacles that may be in place. "
  },
  {
    "sentId": 54,
    "articleId": "4",
    "threatType": "I",
    "relationMentions": [
      {
        "em1Text": "store the key for encryption in a php file outside of the public_html directory",
        "em2Text": "gain access to this file and thus the key",
        "label": "None"
      },
      {
        "em1Text": "store the key for encryption in a php file outside of the public_html directory",
        "em2Text": "server (as in its os) is compromised",
        "label": "AND"
      },
      {
        "em1Text": "gain access to this file and thus the key",
        "em2Text": "store the key for encryption in a php file outside of the public_html directory",
        "label": "PARENT"
      },
      {
        "em1Text": "gain access to this file and thus the key",
        "em2Text": "server (as in its os) is compromised",
        "label": "None"
      },
      {
        "em1Text": "server (as in its os) is compromised",
        "em2Text": "store the key for encryption in a php file outside of the public_html directory",
        "label": "None"
      },
      {
        "em1Text": "server (as in its os) is compromised",
        "em2Text": "gain access to this file and thus the key",
        "label": "None"
      }
    ],
    "entityMentions": [
      {
        "start": 116,
        "text": "store the key for encryption in a php file outside of the public_html directory",
        "label": "ATTACK"
      },
      {
        "start": 274,
        "text": "gain access to this file and thus the key",
        "label": "ATTACK"
      },
      {
        "start": 325,
        "text": "server (as in its os) is compromised",
        "label": "ATTACK"
      }
    ],
    "sentText": "so i am encrypting data, storing it in the database, and decrypting it, using mcrypt.i am wondering if it's safe to store the key for encryption in a php file outside of the public_html directory? what are any potential security risks? is it at all possible for a hacker to gain access to this file and thus the key? if your server (as in its os) is compromised, it is \"game over\", no matter whether your key is stored in a file or the database. so yes, it is \"at all possible for a hacker to gain access to this file and thus the key\" - by breaking into your server's os. "
  },
  {
    "sentId": 54,
    "articleId": "2",
    "threatType": "T",
    "relationMentions": [],
    "entityMentions": [
      {
        "start": 159,
        "text": "inject something dangerous into a privileged shell command",
        "label": "ATTACK"
      }
    ],
    "sentText": "the daemon will pick up actions from a queue and execute them. however, since i'll be accepting input from users, i want to make sure they're not permitted to inject something dangerous into a privileged shell command. "
  }
]